
  /**
   * @license
   * author: Alvaro Canepa
   * vue-mc-gw.js v1.0.22
   * Released under the MIT license.
   */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueMc = require('@planetadeleste/vue-mc');
var lodash = require('lodash');

class Account extends vueMc.Model {
    defaults() {
        return {
            id: null,
            accounttype_id: null,
            currency_id: null,
            company_id: null,
            active: true,
            name: null,
            code: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            accounttype_id: (id) => lodash.toNumber(id) || null,
            currency_id: (id) => lodash.toNumber(id) || null,
            company_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "accounts.show",
            create: "accounts.store",
            update: "accounts.update",
            delete: "accounts.destroy",
        };
    }
}

class AccountCollection extends vueMc.Collection {
    model() {
        return Account;
    }
    routes() {
        return {
            fetch: "accounts.index",
        };
    }
}

class AccountType extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: true,
            name: null,
            code: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "accounttypes.show",
            create: "accounttypes.store",
            update: "accounttypes.update",
            delete: "accounttypes.destroy",
        };
    }
}

class AccountTypeCollection extends vueMc.Collection {
    model() {
        return AccountType;
    }
    routes() {
        return {
            fetch: "accounttypes.index",
        };
    }
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var validation = {};

(function (exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /**
   * Afrikaans
   */


  var en_us = {
    locale: 'en-US',
    messages: {
      after: 'Must be after ${date}',
      alpha: 'Can only use letters',
      alphanumeric: 'Must be alphanumeric',
      array: 'Must be an array',
      ascii: 'Must be ASCII',
      base64: 'Must be valid Base64',
      before: 'Must be before ${date}',
      between: 'Must be between ${min} and ${max}',
      between_inclusive: 'Must be between ${min} and ${max}, inclusive',
      "boolean": 'Must be true or false',
      creditcard: 'Must be a valid credit card number',
      date: 'Must be a valid date',
      dateformat: 'Must use "${format}" format',
      defined: 'Required',
      email: 'Must be a valid email address',
      empty: 'Must be empty',
      equals: 'Must be equal to ${other}',
      gt: 'Must be greater than ${min}',
      gte: 'Must be greater than or equal to ${min}',
      integer: 'Must be an integer',
      ip: 'Must be a valid IP address',
      isblank: 'May not be blank',
      isnil: 'Required',
      isnull: 'Required',
      iso8601: 'Must be a valid ISO8601 date',
      json: 'Must be a valid JSON',
      length: 'Must have a length of at least ${min}',
      length_between: 'Must have a length between ${min} and ${max}',
      lt: 'Must be less than ${max}',
      lte: 'Must be less than or equal to ${max}',
      match: 'Must match "${pattern}"',
      negative: 'Must be a negative number',
      not: 'Can not be ${value}',
      number: 'Must be a number',
      numeric: 'Must be numeric',
      object: 'Must be an object',
      positive: 'Must be a positive number',
      required: 'Required',
      same: 'Must have the same value as "${other}"',
      string: 'Must be a string',
      url: 'Must be a valid URL',
      uuid: 'Must be a valid UUID'
    }
    /**
     * Persian - Islamic Republic of Iran
     */

  };
  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

  function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  var assertString_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = assertString;

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }

    function assertString(input) {
      var isString = typeof input === 'string' || input instanceof String;

      if (!isString) {
        var invalidType;

        if (input === null) {
          invalidType = 'null';
        } else {
          invalidType = _typeof$1(input);

          if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
            invalidType = input.constructor.name;
          } else {
            invalidType = "a ".concat(invalidType);
          }
        }

        throw new TypeError("Expected string but received ".concat(invalidType, "."));
      }
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(assertString_1);
  var alpha_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commaDecimal = exports.dotDecimal = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
    var alpha = {
      'en-US': /^[A-Z]+$/i,
      'bg-BG': /^[А-Я]+$/i,
      'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      'da-DK': /^[A-ZÆØÅ]+$/i,
      'de-DE': /^[A-ZÄÖÜß]+$/i,
      'el-GR': /^[Α-ω]+$/i,
      'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      'nb-NO': /^[A-ZÆØÅ]+$/i,
      'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      'nn-NO': /^[A-ZÆØÅ]+$/i,
      'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      'pt-PT': /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
      'ru-RU': /^[А-ЯЁ]+$/i,
      'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
      'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
      'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
      'sv-SE': /^[A-ZÅÄÖ]+$/i,
      'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
      'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    exports.alpha = alpha;
    var alphanumeric = {
      'en-US': /^[0-9A-Z]+$/i,
      'bg-BG': /^[0-9А-Я]+$/i,
      'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      'da-DK': /^[0-9A-ZÆØÅ]+$/i,
      'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
      'el-GR': /^[0-9Α-ω]+$/i,
      'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
      'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
      'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      'pt-PT': /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
      'ru-RU': /^[0-9А-ЯЁ]+$/i,
      'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
      'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
      'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
      'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    exports.alphanumeric = alphanumeric;
    var decimal = {
      'en-US': '.',
      ar: '٫'
    };
    exports.decimal = decimal;
    var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
    exports.englishLocales = englishLocales;

    for (var locale, i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha['en-US'];
      alphanumeric[locale] = alphanumeric['en-US'];
      decimal[locale] = decimal['en-US'];
    } // Source: http://www.localeplanet.com/java/


    var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
    exports.arabicLocales = arabicLocales;

    for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    } // Source: https://en.wikipedia.org/wiki/Decimal_mark


    var dotDecimal = [];
    exports.dotDecimal = dotDecimal;
    var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA'];
    exports.commaDecimal = commaDecimal;

    for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
      decimal[dotDecimal[_i2]] = decimal['en-US'];
    }

    for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
      decimal[commaDecimal[_i3]] = ',';
    }

    alpha['pt-BR'] = alpha['pt-PT'];
    alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
    decimal['pt-BR'] = decimal['pt-PT']; // see #862

    alpha['pl-Pl'] = alpha['pl-PL'];
    alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
    decimal['pl-Pl'] = decimal['pl-PL'];
  });
  unwrapExports(alpha_1);
  alpha_1.commaDecimal;
  alpha_1.dotDecimal;
  alpha_1.arabicLocales;
  alpha_1.englishLocales;
  alpha_1.decimal;
  alpha_1.alphanumeric;
  alpha_1.alpha;
  var isAlpha_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isAlpha;
    exports.locales = void 0;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function isAlpha(str) {
      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
      (0, _assertString["default"])(str);

      if (locale in alpha_1.alpha) {
        return alpha_1.alpha[locale].test(str);
      }

      throw new Error("Invalid locale '".concat(locale, "'"));
    }

    var locales = Object.keys(alpha_1.alpha);
    exports.locales = locales;
  });
  var isAlpha = unwrapExports(isAlpha_1);
  isAlpha_1.locales;
  var isAlphanumeric_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isAlphanumeric;
    exports.locales = void 0;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function isAlphanumeric(str) {
      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
      (0, _assertString["default"])(str);

      if (locale in alpha_1.alphanumeric) {
        return alpha_1.alphanumeric[locale].test(str);
      }

      throw new Error("Invalid locale '".concat(locale, "'"));
    }

    var locales = Object.keys(alpha_1.alphanumeric);
    exports.locales = locales;
  });
  var isAlphanumeric = unwrapExports(isAlphanumeric_1);
  isAlphanumeric_1.locales;
  var isBase64_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isBase64;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var notBase64 = /[^A-Z0-9+\/=]/i;

    function isBase64(str) {
      (0, _assertString["default"])(str);
      var len = str.length;

      if (!len || len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }

      var firstPaddingChar = str.indexOf('=');
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isBase64 = unwrapExports(isBase64_1);
  var isCreditCard_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isCreditCard;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    /* eslint-disable max-len */


    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
    /* eslint-enable max-len */

    function isCreditCard(str) {
      (0, _assertString["default"])(str);
      var sanitized = str.replace(/[- ]+/g, '');

      if (!creditCard.test(sanitized)) {
        return false;
      }

      var sum = 0;
      var digit;
      var tmpNum;
      var shouldDouble;

      for (var i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, i + 1);
        tmpNum = parseInt(digit, 10);

        if (shouldDouble) {
          tmpNum *= 2;

          if (tmpNum >= 10) {
            sum += tmpNum % 10 + 1;
          } else {
            sum += tmpNum;
          }
        } else {
          sum += tmpNum;
        }

        shouldDouble = !shouldDouble;
      }

      return !!(sum % 10 === 0 ? sanitized : false);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isCreditCard = unwrapExports(isCreditCard_1);
  var merge_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = merge;

    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : undefined;

      for (var key in defaults) {
        if (typeof obj[key] === 'undefined') {
          obj[key] = defaults[key];
        }
      }

      return obj;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(merge_1);
  var isByteLength_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isByteLength;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }
    /* eslint-disable prefer-rest-params */


    function isByteLength(str, options) {
      (0, _assertString["default"])(str);
      var min;
      var max;

      if (_typeof$1(options) === 'object') {
        min = options.min || 0;
        max = options.max;
      } else {
        // backwards compatibility: isByteLength(str, min [, max])
        min = arguments[1];
        max = arguments[2];
      }

      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === 'undefined' || len <= max);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(isByteLength_1);
  var isFQDN_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isFQDN;

    var _assertString = _interopRequireDefault(assertString_1);

    var _merge = _interopRequireDefault(merge_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false
    };

    function isFQDN(str, options) {
      (0, _assertString["default"])(str);
      options = (0, _merge["default"])(options, default_fqdn_options);
      /* Remove the optional trailing dot before checking validity */

      if (options.allow_trailing_dot && str[str.length - 1] === '.') {
        str = str.substring(0, str.length - 1);
      }

      var parts = str.split('.');

      for (var i = 0; i < parts.length; i++) {
        if (parts[i].length > 63) {
          return false;
        }
      }

      if (options.require_tld) {
        var tld = parts.pop();

        if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        } // disallow spaces


        if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
          return false;
        }
      }

      for (var part, _i = 0; _i < parts.length; _i++) {
        part = parts[_i];

        if (options.allow_underscores) {
          part = part.replace(/_/g, '');
        }

        if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        } // disallow full-width chars


        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }

        if (part[0] === '-' || part[part.length - 1] === '-') {
          return false;
        }
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(isFQDN_1);
  var isIP_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isIP;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    var ipv6Block = /^[0-9A-F]{1,4}$/i;

    function isIP(str) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      (0, _assertString["default"])(str);
      version = String(version);

      if (!version) {
        return isIP(str, 4) || isIP(str, 6);
      } else if (version === '4') {
        if (!ipv4Maybe.test(str)) {
          return false;
        }

        var parts = str.split('.').sort(function (a, b) {
          return a - b;
        });
        return parts[3] <= 255;
      } else if (version === '6') {
        var blocks = str.split(':');
        var foundOmissionBlock = false; // marker to indicate ::
        // At least some OS accept the last 32 bits of an IPv6 address
        // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
        // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
        // and '::a.b.c.d' is deprecated, but also valid.

        var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
        var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

        if (blocks.length > expectedNumberOfBlocks) {
          return false;
        } // initial or final ::


        if (str === '::') {
          return true;
        } else if (str.substr(0, 2) === '::') {
          blocks.shift();
          blocks.shift();
          foundOmissionBlock = true;
        } else if (str.substr(str.length - 2) === '::') {
          blocks.pop();
          blocks.pop();
          foundOmissionBlock = true;
        }

        for (var i = 0; i < blocks.length; ++i) {
          // test for a :: which can not be at the string start/end
          // since those cases have been handled above
          if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
            if (foundOmissionBlock) {
              return false; // multiple :: in address
            }

            foundOmissionBlock = true;
          } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ;else if (!ipv6Block.test(blocks[i])) {
            return false;
          }
        }

        if (foundOmissionBlock) {
          return blocks.length >= 1;
        }

        return blocks.length === expectedNumberOfBlocks;
      }

      return false;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isIP = unwrapExports(isIP_1);
  var isEmail_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isEmail;

    var _assertString = _interopRequireDefault(assertString_1);

    var _merge = _interopRequireDefault(merge_1);

    var _isByteLength = _interopRequireDefault(isByteLength_1);

    var _isFQDN = _interopRequireDefault(isFQDN_1);

    var _isIP = _interopRequireDefault(isIP_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_email_options = {
      allow_display_name: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true
    };
    /* eslint-disable max-len */

    /* eslint-disable no-control-regex */

    var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    /* eslint-enable max-len */

    /* eslint-enable no-control-regex */

    function isEmail(str, options) {
      (0, _assertString["default"])(str);
      options = (0, _merge["default"])(options, default_email_options);

      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(displayName);

        if (display_email) {
          str = display_email[1];
        } else if (options.require_display_name) {
          return false;
        }
      }

      var parts = str.split('@');
      var domain = parts.pop();
      var user = parts.join('@');
      var lower_domain = domain.toLowerCase();

      if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
        /*
          Previously we removed dots for gmail addresses before validating.
          This was removed because it allows `multiple..dots@gmail.com`
          to be reported as valid, but it is not.
          Gmail only normalizes single dots, removing them from here is pointless,
          should be done in normalizeEmail
        */
        user = user.toLowerCase(); // Removing sub-address from username before gmail validation

        var username = user.split('+')[0]; // Dots are not included in gmail length restriction

        if (!(0, _isByteLength["default"])(username.replace('.', ''), {
          min: 6,
          max: 30
        })) {
          return false;
        }

        var _user_parts = username.split('.');

        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }

      if (!(0, _isByteLength["default"])(user, {
        max: 64
      }) || !(0, _isByteLength["default"])(domain, {
        max: 254
      })) {
        return false;
      }

      if (!(0, _isFQDN["default"])(domain, {
        require_tld: options.require_tld
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }

        if (!(0, _isIP["default"])(domain)) {
          if (!domain.startsWith('[') || !domain.endsWith(']')) {
            return false;
          }

          var noBracketdomain = domain.substr(1, domain.length - 2);

          if (noBracketdomain.length === 0 || !(0, _isIP["default"])(noBracketdomain)) {
            return false;
          }
        }
      }

      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }

      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split('.');

      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isEmail = unwrapExports(isEmail_1);
  var isISO8601_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isISO8601;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    /* eslint-disable max-len */
    // from http://goo.gl/0ejHHW


    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    /* eslint-enable max-len */

    var isValidDate = function isValidDate(str) {
      // str must have passed the ISO8601 check
      // this check is meant to catch invalid dates
      // like 2009-02-31
      // first check for ordinal dates
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);

      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]); // if is leap year

        if (oYear % 4 === 0 && oYear % 100 !== 0) return oDay <= 366;
        return oDay <= 365;
      }

      var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match[1];
      var month = match[2];
      var day = match[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day; // create a date object and compare

      var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
      if (isNaN(d.getUTCFullYear())) return false;

      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }

      return true;
    };

    function isISO8601(str, options) {
      (0, _assertString["default"])(str);
      var check = iso8601.test(str);
      if (!options) return check;
      if (check && options.strict) return isValidDate(str);
      return check;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isISO8601 = unwrapExports(isISO8601_1);
  var isJSON_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isJSON;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }

    function isJSON(str) {
      (0, _assertString["default"])(str);

      try {
        var obj = JSON.parse(str);
        return !!obj && _typeof$1(obj) === 'object';
      } catch (e) {
        /* ignore */
      }

      return false;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isJSON = unwrapExports(isJSON_1);
  var isURL_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isURL;

    var _assertString = _interopRequireDefault(assertString_1);

    var _isFQDN = _interopRequireDefault(isFQDN_1);

    var _isIP = _interopRequireDefault(isIP_1);

    var _merge = _interopRequireDefault(merge_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_url_options = {
      protocols: ['http', 'https', 'ftp'],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

    function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === '[object RegExp]';
    }

    function checkHost(host, matches) {
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];

        if (host === match || isRegExp(match) && match.test(host)) {
          return true;
        }
      }

      return false;
    }

    function isURL(url, options) {
      (0, _assertString["default"])(url);

      if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
        return false;
      }

      if (url.indexOf('mailto:') === 0) {
        return false;
      }

      options = (0, _merge["default"])(options, default_url_options);
      var protocol, auth, host, hostname, port, port_str, split, ipv6;
      split = url.split('#');
      url = split.shift();
      split = url.split('?');
      url = split.shift();
      split = url.split('://');

      if (split.length > 1) {
        protocol = split.shift().toLowerCase();

        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.substr(0, 2) === '//') {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }

        split[0] = url.substr(2);
      }

      url = split.join('://');

      if (url === '') {
        return false;
      }

      split = url.split('/');
      url = split.shift();

      if (url === '' && !options.require_host) {
        return true;
      }

      split = url.split('@');

      if (split.length > 1) {
        if (options.disallow_auth) {
          return false;
        }

        auth = split.shift();

        if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
          return false;
        }
      }

      hostname = split.join('@');
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);

      if (ipv6_match) {
        host = '';
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split = hostname.split(':');
        host = split.shift();

        if (split.length) {
          port_str = split.join(':');
        }
      }

      if (port_str !== null) {
        port = parseInt(port_str, 10);

        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      }

      if (!(0, _isIP["default"])(host) && !(0, _isFQDN["default"])(host, options) && (!ipv6 || !(0, _isIP["default"])(ipv6, 6))) {
        return false;
      }

      host = host || ipv6;

      if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
        return false;
      }

      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isURL = unwrapExports(isURL_1);
  var isUUID_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isUUID;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var uuid = {
      3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };

    function isUUID(str) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
      (0, _assertString["default"])(str);
      var pattern = uuid[version];
      return pattern && pattern.test(str);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isUUID = unwrapExports(isUUID_1);
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal$1) == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  var _freeGlobal = freeGlobal;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;
  /** Built-in value references. */

  var Symbol$1 = _root.Symbol;
  var _Symbol = Symbol$1;
  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;
  /** Used for built-in method references. */

  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;
  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  function isObject(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;
  /** `Object#toString` result references. */

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = _baseGetTag(value);

    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;
  /** Used for built-in method references. */

  var funcProto = Function.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$1 = funcProto$1.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */

  function getNative(object, key) {
    var value = _getValue(object, key);

    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var defineProperty = function () {
    try {
      var func = _getNative(Object, 'defineProperty');

      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  var _defineProperty = defineProperty;
  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;
  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }

    return object;
  }

  var _copyObject = copyObject;
  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */

  function identity(value) {
    return value;
  }

  var identity_1 = identity;
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  var _apply = apply;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max;
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;
  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */

  function constant(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant;
  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString;
  /** Used to detect hot functions by number of calls within a span of milliseconds. */

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeNow = Date.now;
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;
  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */

  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */

  function isIndex(value, length) {
    var type = _typeof(value);

    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;
  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */

  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }

    var type = _typeof(index);

    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
      return eq_1(object[index], value);
    }

    return false;
  }

  var _isIterateeCall = isIterateeCall;
  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */

  function createAssigner(assigner) {
    return _baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }

  var _createAssigner = createAssigner;
  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$4;
    return value === proto;
  }

  var _isPrototype = isPrototype;
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]';
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;
  /** Used for built-in method references. */

  var objectProto$5 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
  /** Built-in value references. */

  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */

  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments;
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray = Array.isArray;
  var isArray_1 = isArray;
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;
  var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Built-in value references. */

    var Buffer = moduleExports ? _root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse_1;
    module.exports = isBuffer;
  });
  /** `Object#toString` result references. */

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && _freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    module.exports = nodeUtil;
  });
  /* Node.js helper references. */


  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */

  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;
  /** Used for built-in method references. */

  var objectProto$6 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;
  /** Used for built-in method references. */

  var objectProto$7 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;
  /** Used for built-in method references. */

  var objectProto$8 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */

  var assign = _createAssigner(function (object, source) {
    if (_isPrototype(source) || isArrayLike_1(source)) {
      _copyObject(source, keys_1(source), object);

      return;
    }

    for (var key in source) {
      if (hasOwnProperty$6.call(source, key)) {
        _assignValue(object, key, source[key]);
      }
    }
  });

  var assign_1 = assign;
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;
  /** Built-in value references. */

  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */

  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  var _baseFlatten = baseFlatten;
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */

  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  var _copyArray = copyArray;
  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */

  function concat() {
    var length = arguments.length;

    if (!length) {
      return [];
    }

    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }

    return _arrayPush(isArray_1(array) ? _copyArray(array) : [array], _baseFlatten(args, 1));
  }

  var concat_1 = concat;
  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */

  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  var _basePropertyOf = basePropertyOf;
  /** Used to map Latin Unicode letters to basic Latin letters. */

  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',
    '\xc1': 'A',
    '\xc2': 'A',
    '\xc3': 'A',
    '\xc4': 'A',
    '\xc5': 'A',
    '\xe0': 'a',
    '\xe1': 'a',
    '\xe2': 'a',
    '\xe3': 'a',
    '\xe4': 'a',
    '\xe5': 'a',
    '\xc7': 'C',
    '\xe7': 'c',
    '\xd0': 'D',
    '\xf0': 'd',
    '\xc8': 'E',
    '\xc9': 'E',
    '\xca': 'E',
    '\xcb': 'E',
    '\xe8': 'e',
    '\xe9': 'e',
    '\xea': 'e',
    '\xeb': 'e',
    '\xcc': 'I',
    '\xcd': 'I',
    '\xce': 'I',
    '\xcf': 'I',
    '\xec': 'i',
    '\xed': 'i',
    '\xee': 'i',
    '\xef': 'i',
    '\xd1': 'N',
    '\xf1': 'n',
    '\xd2': 'O',
    '\xd3': 'O',
    '\xd4': 'O',
    '\xd5': 'O',
    '\xd6': 'O',
    '\xd8': 'O',
    '\xf2': 'o',
    '\xf3': 'o',
    '\xf4': 'o',
    '\xf5': 'o',
    '\xf6': 'o',
    '\xf8': 'o',
    '\xd9': 'U',
    '\xda': 'U',
    '\xdb': 'U',
    '\xdc': 'U',
    '\xf9': 'u',
    '\xfa': 'u',
    '\xfb': 'u',
    '\xfc': 'u',
    '\xdd': 'Y',
    '\xfd': 'y',
    '\xff': 'y',
    '\xc6': 'Ae',
    '\xe6': 'ae',
    '\xde': 'Th',
    '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    "\u0100": 'A',
    "\u0102": 'A',
    "\u0104": 'A',
    "\u0101": 'a',
    "\u0103": 'a',
    "\u0105": 'a',
    "\u0106": 'C',
    "\u0108": 'C',
    "\u010A": 'C',
    "\u010C": 'C',
    "\u0107": 'c',
    "\u0109": 'c',
    "\u010B": 'c',
    "\u010D": 'c',
    "\u010E": 'D',
    "\u0110": 'D',
    "\u010F": 'd',
    "\u0111": 'd',
    "\u0112": 'E',
    "\u0114": 'E',
    "\u0116": 'E',
    "\u0118": 'E',
    "\u011A": 'E',
    "\u0113": 'e',
    "\u0115": 'e',
    "\u0117": 'e',
    "\u0119": 'e',
    "\u011B": 'e',
    "\u011C": 'G',
    "\u011E": 'G',
    "\u0120": 'G',
    "\u0122": 'G',
    "\u011D": 'g',
    "\u011F": 'g',
    "\u0121": 'g',
    "\u0123": 'g',
    "\u0124": 'H',
    "\u0126": 'H',
    "\u0125": 'h',
    "\u0127": 'h',
    "\u0128": 'I',
    "\u012A": 'I',
    "\u012C": 'I',
    "\u012E": 'I',
    "\u0130": 'I',
    "\u0129": 'i',
    "\u012B": 'i',
    "\u012D": 'i',
    "\u012F": 'i',
    "\u0131": 'i',
    "\u0134": 'J',
    "\u0135": 'j',
    "\u0136": 'K',
    "\u0137": 'k',
    "\u0138": 'k',
    "\u0139": 'L',
    "\u013B": 'L',
    "\u013D": 'L',
    "\u013F": 'L',
    "\u0141": 'L',
    "\u013A": 'l',
    "\u013C": 'l',
    "\u013E": 'l',
    "\u0140": 'l',
    "\u0142": 'l',
    "\u0143": 'N',
    "\u0145": 'N',
    "\u0147": 'N',
    "\u014A": 'N',
    "\u0144": 'n',
    "\u0146": 'n',
    "\u0148": 'n',
    "\u014B": 'n',
    "\u014C": 'O',
    "\u014E": 'O',
    "\u0150": 'O',
    "\u014D": 'o',
    "\u014F": 'o',
    "\u0151": 'o',
    "\u0154": 'R',
    "\u0156": 'R',
    "\u0158": 'R',
    "\u0155": 'r',
    "\u0157": 'r',
    "\u0159": 'r',
    "\u015A": 'S',
    "\u015C": 'S',
    "\u015E": 'S',
    "\u0160": 'S',
    "\u015B": 's',
    "\u015D": 's',
    "\u015F": 's',
    "\u0161": 's',
    "\u0162": 'T',
    "\u0164": 'T',
    "\u0166": 'T',
    "\u0163": 't',
    "\u0165": 't',
    "\u0167": 't',
    "\u0168": 'U',
    "\u016A": 'U',
    "\u016C": 'U',
    "\u016E": 'U',
    "\u0170": 'U',
    "\u0172": 'U',
    "\u0169": 'u',
    "\u016B": 'u',
    "\u016D": 'u',
    "\u016F": 'u',
    "\u0171": 'u',
    "\u0173": 'u',
    "\u0174": 'W',
    "\u0175": 'w',
    "\u0176": 'Y',
    "\u0177": 'y',
    "\u0178": 'Y',
    "\u0179": 'Z',
    "\u017B": 'Z',
    "\u017D": 'Z',
    "\u017A": 'z',
    "\u017C": 'z',
    "\u017E": 'z',
    "\u0132": 'IJ',
    "\u0133": 'ij',
    "\u0152": 'Oe',
    "\u0153": 'oe',
    "\u0149": "'n",
    "\u017F": 's'
  };
  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */

  var deburrLetter = _basePropertyOf(deburredLetters);

  var _deburrLetter = deburrLetter;
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */

  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;
  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
  }

  var isSymbol_1 = isSymbol;
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  var _baseToString = baseToString;
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */

  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;
  /** Used to match Latin Unicode letters (excluding mathematical operators). */

  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  /** Used to compose unicode character classes. */

  var rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
  /** Used to compose unicode capture groups. */

  var rsCombo = '[' + rsComboRange + ']';
  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */

  var reComboMark = RegExp(rsCombo, 'g');
  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */

  function deburr(string) {
    string = toString_1(string);
    return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
  }

  var deburr_1 = deburr;
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */

  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var _arrayEach = arrayEach;
  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  var _createBaseFor = createBaseFor;
  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */

  var baseFor = _createBaseFor();

  var _baseFor = baseFor;
  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;
  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  var _createBaseEach = createBaseEach;
  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */

  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;
  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */

  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;
  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */

  function forEach(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayEach : _baseEach;
    return func(collection, _castFunction(iteratee));
  }

  var forEach_1 = forEach;
  var each = forEach_1;
  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = _typeof(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;
  /* Built-in method references that are verified to be native. */

  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used for built-in method references. */

  var objectProto$9 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;
  /** Used for built-in method references. */

  var objectProto$a = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
  }

  var _hashHas = hashHas;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `Hash`.


  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;
  /** Used for built-in method references. */

  var arrayProto = Array.prototype;
  /** Built-in value references. */

  var splice = arrayProto.splice;
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;
  /* Built-in method references that are verified to be native. */

  var Map = _getNative(_root, 'Map');

  var _Map = Map;
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */

  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);

    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;
  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = _MapCache;
  var memoize_1 = memoize;
  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;
  /** Used to match property names within property paths. */

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */

  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  var _stringToPath = stringToPath;
  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;
  /** Used as references for various `Number` constants. */

  var INFINITY$1 = 1 / 0;
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  var _toKey = toKey;
  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */

  function baseGet(object, path) {
    path = _castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  var _baseGet = baseGet;
  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;
  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */

  function baseGt(value, other) {
    return value > other;
  }

  var _baseGt = baseGt;
  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;
  /**
   * Creates a function that performs a relational operation on two values.
   *
   * @private
   * @param {Function} operator The function to perform the operation.
   * @returns {Function} Returns the new relational operation function.
   */

  function createRelationalOperation(operator) {
    return function (value, other) {
      if (!(typeof value == 'string' && typeof other == 'string')) {
        value = toNumber_1(value);
        other = toNumber_1(other);
      }

      return operator(value, other);
    };
  }

  var _createRelationalOperation = createRelationalOperation;
  /**
   * Checks if `value` is greater than `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   * @see _.lt
   * @example
   *
   * _.gt(3, 1);
   * // => true
   *
   * _.gt(3, 3);
   * // => false
   *
   * _.gt(1, 3);
   * // => false
   */

  var gt = _createRelationalOperation(_baseGt);

  var gt_1 = gt;
  /**
   * Checks if `value` is greater than or equal to `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than or equal to
   *  `other`, else `false`.
   * @see _.lte
   * @example
   *
   * _.gte(3, 1);
   * // => true
   *
   * _.gte(3, 3);
   * // => true
   *
   * _.gte(1, 3);
   * // => false
   */

  var gte = _createRelationalOperation(function (value, other) {
    return value >= other;
  });

  var gte_1 = gte;
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  var _baseFindIndex = baseFindIndex;
  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */

  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;
  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  var _strictIndexOf = strictIndexOf;
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;
  /** `Object#toString` result references. */

  var stringTag$1 = '[object String]';
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */

  function isString(value) {
    return typeof value == 'string' || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$1;
  }

  var isString_1 = isString;
  /** Used as references for various `Number` constants. */

  var INFINITY$2 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber_1(value);

    if (value === INFINITY$2 || value === -INFINITY$2) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;
  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */

  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var toInteger_1 = toInteger;
  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */

  function baseValues(object, props) {
    return _arrayMap(props, function (key) {
      return object[key];
    });
  }

  var _baseValues = baseValues;
  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */

  function values(object) {
    return object == null ? [] : _baseValues(object, keys_1(object));
  }

  var values_1 = values;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax$1 = Math.max;
  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */

  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike_1(collection) ? collection : values_1(collection);
    fromIndex = fromIndex && !guard ? toInteger_1(fromIndex) : 0;
    var length = collection.length;

    if (fromIndex < 0) {
      fromIndex = nativeMax$1(length + fromIndex, 0);
    }

    return isString_1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _baseIndexOf(collection, value, fromIndex) > -1;
  }

  var includes_1 = includes;
  /** `Object#toString` result references. */

  var boolTag$1 = '[object Boolean]';
  /**
   * Checks if `value` is classified as a boolean primitive or object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
   * @example
   *
   * _.isBoolean(false);
   * // => true
   *
   * _.isBoolean(null);
   * // => false
   */

  function isBoolean(value) {
    return value === true || value === false || isObjectLike_1(value) && _baseGetTag(value) == boolTag$1;
  }

  var isBoolean_1 = isBoolean;
  /* Built-in method references that are verified to be native. */

  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;
  /* Built-in method references that are verified to be native. */

  var Promise = _getNative(_root, 'Promise');

  var _Promise = Promise;
  /* Built-in method references that are verified to be native. */

  var Set = _getNative(_root, 'Set');

  var _Set = Set;
  /* Built-in method references that are verified to be native. */

  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;
  /** `Object#toString` result references. */

  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$1 = '[object DataView]';
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */


  var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;

          case mapCtorString:
            return mapTag$1;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$1;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;
  /** `Object#toString` result references. */

  var mapTag$2 = '[object Map]',
      setTag$2 = '[object Set]';
  /** Used for built-in method references. */

  var objectProto$b = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */

  function isEmpty(value) {
    if (value == null) {
      return true;
    }

    if (isArrayLike_1(value) && (isArray_1(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer_1(value) || isTypedArray_1(value) || isArguments_1(value))) {
      return !value.length;
    }

    var tag = _getTag(value);

    if (tag == mapTag$2 || tag == setTag$2) {
      return !value.size;
    }

    if (_isPrototype(value)) {
      return !_baseKeys(value).length;
    }

    for (var key in value) {
      if (hasOwnProperty$9.call(value, key)) {
        return false;
      }
    }

    return true;
  }

  var isEmpty_1 = isEmpty;
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;
  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  } // Add methods to `Stack`.


  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  var _setCacheAdd = setCacheAdd;
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;
  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;
  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */

  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;
  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;
  /** Built-in value references. */

  var Uint8Array = _root.Uint8Array;
  var _Uint8Array = Uint8Array;
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  /** `Object#toString` result references. */

  var boolTag$2 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$3 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$3 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]';
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$2:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$2:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag$3:
        var convert = _mapToArray;

      case setTag$3:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);

        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);

        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;
  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */

  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;
  /** Used for built-in method references. */

  var objectProto$c = Object.prototype;
  /** Built-in value references. */

  var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$2 = 1;
  /** Used for built-in method references. */

  var objectProto$d = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$a = objectProto$d.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$3 = 1;
  /** `Object#toString` result references. */

  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$2 = '[object Object]';
  /** Used for built-in method references. */

  var objectProto$e = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);
    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;
    var objIsObj = objTag == objectTag$2,
        othIsObj = othTag == objectTag$2,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;
  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;
  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */

  function isEqual(value, other) {
    return _baseIsEqual(value, other);
  }

  var isEqual_1 = isEqual;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsFinite = _root.isFinite;
  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */

  function isFinite(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  var _isFinite = isFinite;
  /**
   * Checks if `value` is an integer.
   *
   * **Note:** This method is based on
   * [`Number.isInteger`](https://mdn.io/Number/isInteger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
   * @example
   *
   * _.isInteger(3);
   * // => true
   *
   * _.isInteger(Number.MIN_VALUE);
   * // => false
   *
   * _.isInteger(Infinity);
   * // => false
   *
   * _.isInteger('3');
   * // => false
   */

  function isInteger(value) {
    return typeof value == 'number' && value == toInteger_1(value);
  }

  var isInteger_1 = isInteger;
  /** `Object#toString` result references. */

  var numberTag$2 = '[object Number]';
  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */

  function isNumber(value) {
    return typeof value == 'number' || isObjectLike_1(value) && _baseGetTag(value) == numberTag$2;
  }

  var isNumber_1 = isNumber;
  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */

  function isNaN$1(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber_1(value) && value != +value;
  }

  var _isNaN = isNaN$1;
  /**
   * Checks if `value` is `null` or `undefined`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
   * @example
   *
   * _.isNil(null);
   * // => true
   *
   * _.isNil(void 0);
   * // => true
   *
   * _.isNil(NaN);
   * // => false
   */

  function isNil(value) {
    return value == null;
  }

  var isNil_1 = isNil;
  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */

  function isNull(value) {
    return value === null;
  }

  var isNull_1 = isNull;
  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */

  function isUndefined(value) {
    return value === undefined;
  }

  var isUndefined_1 = isUndefined;
  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */

  function baseLt(value, other) {
    return value < other;
  }

  var _baseLt = baseLt;
  /**
   * Checks if `value` is less than `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   * @see _.gt
   * @example
   *
   * _.lt(1, 3);
   * // => true
   *
   * _.lt(3, 3);
   * // => false
   *
   * _.lt(3, 1);
   * // => false
   */

  var lt = _createRelationalOperation(_baseLt);

  var lt_1 = lt;
  /**
   * Checks if `value` is less than or equal to `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than or equal to
   *  `other`, else `false`.
   * @see _.gte
   * @example
   *
   * _.lte(1, 3);
   * // => true
   *
   * _.lte(3, 3);
   * // => true
   *
   * _.lte(3, 1);
   * // => false
   */

  var lte = _createRelationalOperation(function (value, other) {
    return value <= other;
  });

  var lte_1 = lte;
  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */

  function baseSet(object, path, value, customizer) {
    if (!isObject_1(object)) {
      return object;
    }

    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = _toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject_1(objValue) ? objValue : _isIndex(path[index + 1]) ? [] : {};
        }
      }

      _assignValue(nested, key, newValue);

      nested = nested[key];
    }

    return object;
  }

  var _baseSet = baseSet;
  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */

  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = _baseGet(object, path);

      if (predicate(value, path)) {
        _baseSet(result, _castPath(path, object), value);
      }
    }

    return result;
  }

  var _basePickBy = basePickBy;
  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;
  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;
  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */

  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;
  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */

  function basePick(object, paths) {
    return _basePickBy(object, paths, function (value, path) {
      return hasIn_1(object, path);
    });
  }

  var _basePick = basePick;
  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */

  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? _baseFlatten(array, 1) : [];
  }

  var flatten_1 = flatten;
  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */

  function flatRest(func) {
    return _setToString(_overRest(func, undefined, flatten_1), func + '');
  }

  var _flatRest = flatRest;
  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */

  var pick = _flatRest(function (object, paths) {
    return object == null ? {} : _basePick(object, paths);
  });

  var pick_1 = pick;
  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */

  function set(object, path, value) {
    return object == null ? object : _baseSet(object, path, value);
  }

  var set_1 = set;
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */

  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;
  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  var asciiSize = _baseProperty('length');

  var _asciiSize = asciiSize;
  /** Used to compose unicode character classes. */

  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange$1 = "\\u0300-\\u036f",
      reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsZWJ = "\\u200d";
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange$1 + rsVarRange + ']');
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */

  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;
  /** Used to compose unicode character classes. */

  var rsAstralRange$1 = "\\ud800-\\udfff",
      rsComboMarksRange$2 = "\\u0300-\\u036f",
      reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
      rsVarRange$1 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo$1 = '[' + rsComboRange$2 + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo$1 + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$1 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo$1 + '?', rsCombo$1, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;

    while (reUnicode.test(string)) {
      ++result;
    }

    return result;
  }

  var _unicodeSize = unicodeSize;
  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */

  function stringSize(string) {
    return _hasUnicode(string) ? _unicodeSize(string) : _asciiSize(string);
  }

  var _stringSize = stringSize;
  /** `Object#toString` result references. */

  var mapTag$4 = '[object Map]',
      setTag$4 = '[object Set]';
  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */

  function size(collection) {
    if (collection == null) {
      return 0;
    }

    if (isArrayLike_1(collection)) {
      return isString_1(collection) ? _stringSize(collection) : collection.length;
    }

    var tag = _getTag(collection);

    if (tag == mapTag$4 || tag == setTag$4) {
      return collection.size;
    }

    return _baseKeys(collection).length;
  }

  var size_1 = size;
  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  var _baseSlice = baseSlice;
  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;
  /** `Object#toString` result references. */

  var regexpTag$2 = '[object RegExp]';
  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */

  function baseIsRegExp(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == regexpTag$2;
  }

  var _baseIsRegExp = baseIsRegExp;
  /* Node.js helper references. */

  var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;
  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */

  var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;
  var isRegExp_1 = isRegExp;
  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;
  /** Used to compose unicode character classes. */

  var rsAstralRange$2 = "\\ud800-\\udfff",
      rsComboMarksRange$3 = "\\u0300-\\u036f",
      reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$3 = "\\u20d0-\\u20ff",
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsVarRange$2 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral$1 = '[' + rsAstralRange$2 + ']',
      rsCombo$2 = '[' + rsComboRange$3 + ']',
      rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
      rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$2 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$2 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsSymbol$1 = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral$1].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode$1 = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol$1 + rsSeq$1, 'g');
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function unicodeToArray(string) {
    return string.match(reUnicode$1) || [];
  }

  var _unicodeToArray = unicodeToArray;
  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function stringToArray(string) {
    return _hasUnicode(string) ? _unicodeToArray(string) : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;
  /** Used as references for the maximum length and index of an array. */

  var MAX_ARRAY_LENGTH = 4294967295;
  /**
   * Splits `string` by `separator`.
   *
   * **Note:** This method is based on
   * [`String#split`](https://mdn.io/String/split).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to split.
   * @param {RegExp|string} separator The separator pattern to split by.
   * @param {number} [limit] The length to truncate results to.
   * @returns {Array} Returns the string segments.
   * @example
   *
   * _.split('a-b-c', '-', 2);
   * // => ['a', 'b']
   */

  function split(string, separator, limit) {
    if (limit && typeof limit != 'number' && _isIterateeCall(string, separator, limit)) {
      separator = limit = undefined;
    }

    limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

    if (!limit) {
      return [];
    }

    string = toString_1(string);

    if (string && (typeof separator == 'string' || separator != null && !isRegExp_1(separator))) {
      separator = _baseToString(separator);

      if (!separator && _hasUnicode(string)) {
        return _castSlice(_stringToArray(string), 0, limit);
      }
    }

    return string.split(separator, limit);
  }

  var split_1 = split;
  /**
   * This method returns `true`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `true`.
   * @example
   *
   * _.times(2, _.stubTrue);
   * // => [true, true]
   */

  function stubTrue() {
    return true;
  }

  var stubTrue_1 = stubTrue;
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var _nativeKeysIn = nativeKeysIn;
  /** Used for built-in method references. */

  var objectProto$f = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$c = objectProto$f.hasOwnProperty;
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }

    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$c.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeysIn = baseKeysIn;
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */

  function keysIn(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn;
  /**
   * This method is like `_.assignIn` except that it accepts `customizer`
   * which is invoked to produce the assigned values. If `customizer` returns
   * `undefined`, assignment is handled by the method instead. The `customizer`
   * is invoked with five arguments: (objValue, srcValue, key, object, source).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extendWith
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} [customizer] The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @see _.assignWith
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   return _.isUndefined(objValue) ? srcValue : objValue;
   * }
   *
   * var defaults = _.partialRight(_.assignInWith, customizer);
   *
   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */

  var assignInWith = _createAssigner(function (object, source, srcIndex, customizer) {
    _copyObject(source, keysIn_1(source), object, customizer);
  });

  var assignInWith_1 = assignInWith;
  /** Built-in value references. */

  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;
  /** `Object#toString` result references. */

  var objectTag$3 = '[object Object]';
  /** Used for built-in method references. */

  var funcProto$2 = Function.prototype,
      objectProto$g = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$2 = funcProto$2.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$d = objectProto$g.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString$2.call(Object);
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$d.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;
  /** `Object#toString` result references. */

  var domExcTag = '[object DOMException]',
      errorTag$2 = '[object Error]';
  /**
   * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
   * `SyntaxError`, `TypeError`, or `URIError` object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
   * @example
   *
   * _.isError(new Error);
   * // => true
   *
   * _.isError(Error);
   * // => false
   */

  function isError(value) {
    if (!isObjectLike_1(value)) {
      return false;
    }

    var tag = _baseGetTag(value);

    return tag == errorTag$2 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject_1(value);
  }

  var isError_1 = isError;
  /**
   * Attempts to invoke `func`, returning either the result or the caught error
   * object. Any additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Function} func The function to attempt.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {*} Returns the `func` result or error object.
   * @example
   *
   * // Avoid throwing errors for invalid selectors.
   * var elements = _.attempt(function(selector) {
   *   return document.querySelectorAll(selector);
   * }, '>_>');
   *
   * if (_.isError(elements)) {
   *   elements = [];
   * }
   */

  var attempt = _baseRest(function (func, args) {
    try {
      return _apply(func, undefined, args);
    } catch (e) {
      return isError_1(e) ? e : new Error(e);
    }
  });

  var attempt_1 = attempt;
  /** Used for built-in method references. */

  var objectProto$h = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$e = objectProto$h.hasOwnProperty;
  /**
   * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
   * of source objects to the destination object for all destination properties
   * that resolve to `undefined`.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to assign.
   * @param {Object} object The parent object of `objValue`.
   * @returns {*} Returns the value to assign.
   */

  function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === undefined || eq_1(objValue, objectProto$h[key]) && !hasOwnProperty$e.call(object, key)) {
      return srcValue;
    }

    return objValue;
  }

  var _customDefaultsAssignIn = customDefaultsAssignIn;
  /** Used to escape characters for inclusion in compiled string literals. */

  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    "\u2028": 'u2028',
    "\u2029": 'u2029'
  };
  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  var _escapeStringChar = escapeStringChar;
  /** Used to match template delimiters. */

  var reInterpolate = /<%=([\s\S]+?)%>/g;
  var _reInterpolate = reInterpolate;
  /** Used to map characters to HTML entities. */

  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  var escapeHtmlChar = _basePropertyOf(htmlEscapes);

  var _escapeHtmlChar = escapeHtmlChar;
  /** Used to match HTML entities and HTML characters. */

  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */

  function escape(string) {
    string = toString_1(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, _escapeHtmlChar) : string;
  }

  var _escape = escape;
  /** Used to match template delimiters. */

  var reEscape = /<%-([\s\S]+?)%>/g;
  var _reEscape = reEscape;
  /** Used to match template delimiters. */

  var reEvaluate = /<%([\s\S]+?)%>/g;
  var _reEvaluate = reEvaluate;
  /**
   * By default, the template delimiters used by lodash are like those in
   * embedded Ruby (ERB) as well as ES2015 template strings. Change the
   * following template settings to use alternative delimiters.
   *
   * @static
   * @memberOf _
   * @type {Object}
   */

  var templateSettings = {
    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'escape': _reEscape,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'evaluate': _reEvaluate,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'interpolate': _reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type {string}
     */
    'variable': '',

    /**
     * Used to import variables into the compiled template.
     *
     * @memberOf _.templateSettings
     * @type {Object}
     */
    'imports': {
      /**
       * A reference to the `lodash` function.
       *
       * @memberOf _.templateSettings.imports
       * @type {Function}
       */
      '_': {
        'escape': _escape
      }
    }
  };
  var templateSettings_1 = templateSettings;
  /** Used to match empty string literals in compiled template source. */

  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */

  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  /** Used to ensure capturing order of template delimiters. */

  var reNoMatch = /($^)/;
  /** Used to match unescaped characters in compiled string literals. */

  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  /** Used for built-in method references. */

  var objectProto$i = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$f = objectProto$i.hasOwnProperty;
  /**
   * Creates a compiled template function that can interpolate data properties
   * in "interpolate" delimiters, HTML-escape interpolated data properties in
   * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
   * properties may be accessed as free variables in the template. If a setting
   * object is given, it takes precedence over `_.templateSettings` values.
   *
   * **Note:** In the development build `_.template` utilizes
   * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
   * for easier debugging.
   *
   * For more information on precompiling templates see
   * [lodash's custom builds documentation](https://lodash.com/custom-builds).
   *
   * For more information on Chrome extension sandboxes see
   * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The template string.
   * @param {Object} [options={}] The options object.
   * @param {RegExp} [options.escape=_.templateSettings.escape]
   *  The HTML "escape" delimiter.
   * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
   *  The "evaluate" delimiter.
   * @param {Object} [options.imports=_.templateSettings.imports]
   *  An object to import into the template as free variables.
   * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
   *  The "interpolate" delimiter.
   * @param {string} [options.sourceURL='templateSources[n]']
   *  The sourceURL of the compiled template.
   * @param {string} [options.variable='obj']
   *  The data object variable name.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Function} Returns the compiled template function.
   * @example
   *
   * // Use the "interpolate" delimiter to create a compiled template.
   * var compiled = _.template('hello <%= user %>!');
   * compiled({ 'user': 'fred' });
   * // => 'hello fred!'
   *
   * // Use the HTML "escape" delimiter to escape data property values.
   * var compiled = _.template('<b><%- value %></b>');
   * compiled({ 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
   * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the internal `print` function in "evaluate" delimiters.
   * var compiled = _.template('<% print("hello " + user); %>!');
   * compiled({ 'user': 'barney' });
   * // => 'hello barney!'
   *
   * // Use the ES template literal delimiter as an "interpolate" delimiter.
   * // Disable support by replacing the "interpolate" delimiter.
   * var compiled = _.template('hello ${ user }!');
   * compiled({ 'user': 'pebbles' });
   * // => 'hello pebbles!'
   *
   * // Use backslashes to treat delimiters as plain text.
   * var compiled = _.template('<%= "\\<%- value %\\>" %>');
   * compiled({ 'value': 'ignored' });
   * // => '<%- value %>'
   *
   * // Use the `imports` option to import `jQuery` as `jq`.
   * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
   * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the `sourceURL` option to specify a custom sourceURL for the template.
   * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
   *
   * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
   * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   * //   var __t, __p = '';
   * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
   * //   return __p;
   * // }
   *
   * // Use custom template delimiters.
   * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
   * var compiled = _.template('hello {{ user }}!');
   * compiled({ 'user': 'mustache' });
   * // => 'hello mustache!'
   *
   * // Use the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and stack traces.
   * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */

  function template(string, options, guard) {
    // Based on John Resig's `tmpl` implementation
    // (http://ejohn.org/blog/javascript-micro-templating/)
    // and Laura Doktorova's doT.js (https://github.com/olado/doT).
    var settings = templateSettings_1.imports._.templateSettings || templateSettings_1;

    if (guard && _isIterateeCall(string, options, guard)) {
      options = undefined;
    }

    string = toString_1(string);
    options = assignInWith_1({}, options, settings, _customDefaultsAssignIn);

    var imports = assignInWith_1({}, options.imports, settings.imports, _customDefaultsAssignIn),
        importsKeys = keys_1(imports),
        importsValues = _baseValues(imports, importsKeys);

    var isEscaping,
        isEvaluating,
        index = 0,
        interpolate = options.interpolate || reNoMatch,
        source = "__p += '"; // Compile the regexp to match each delimiter.

    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === _reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
    // The sourceURL gets injected into the source that's eval-ed, so be careful
    // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
    // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

    var sourceURL = hasOwnProperty$f.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
    string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

      source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar); // Replace delimiters with snippets.

      if (escapeValue) {
        isEscaping = true;
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }

      if (evaluateValue) {
        isEvaluating = true;
        source += "';\n" + evaluateValue + ";\n__p += '";
      }

      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }

      index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
      // order to produce the correct `offset` value.

      return match;
    });
    source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
    // code to add the data object to the top of the scope chain.
    // Like with sourceURL, we take care to not check the option's prototype,
    // as this configuration is a code injection vector.

    var variable = hasOwnProperty$f.call(options, 'variable') && options.variable;

    if (!variable) {
      source = 'with (obj) {\n' + source + '\n}\n';
    } // Cleanup code by stripping empty strings.


    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

    source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
    var result = attempt_1(function () {
      return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
    }); // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.

    result.source = source;

    if (isError_1(result)) {
      throw result;
    }

    return result;
  }

  var template_1 = template;
  /**
   * Converts `string`, as a whole, to lower case just like
   * [String#toLowerCase](https://mdn.io/toLowerCase).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the lower cased string.
   * @example
   *
   * _.toLower('--Foo-Bar--');
   * // => '--foo-bar--'
   *
   * _.toLower('fooBar');
   * // => 'foobar'
   *
   * _.toLower('__FOO_BAR__');
   * // => '__foo_bar__'
   */

  function toLower(value) {
    return toString_1(value).toLowerCase();
  }

  var toLower_1 = toLower;
  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   *
   * @param {Date|Number} argument - the value to convert
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Clone the date:
   * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert the timestamp to date:
   * const result = toDate(1392098430000)
   * //=> Tue Feb 11 2014 11:30:30
   */

  function toDate(argument) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var argStr = Object.prototype.toString.call(argument); // Clone the date

    if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime());
    } else if (typeof argument === 'number' || argStr === '[object Number]') {
      return new Date(argument);
    } else {
      if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
        // eslint-disable-next-line no-console
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

        console.warn(new Error().stack);
      }

      return new Date(NaN);
    }
  }

  function toInteger$1(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }

    var number = Number(dirtyNumber);

    if (isNaN(number)) {
      return number;
    }

    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }
  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be added
   * @returns {Date} the new date with the milliseconds added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */


  function addMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var timestamp = toDate(dirtyDate).getTime();
    var amount = toInteger$1(dirtyAmount);
    return new Date(timestamp + amount);
  }

  var MILLISECONDS_IN_MINUTE = 60000;
  /**
   * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
   * They usually appear for dates that denote time before the timezones were introduced
   * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
   * and GMT+01:00:00 after that date)
   *
   * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
   * which would lead to incorrect calculations.
   *
   * This function returns the timezone offset in milliseconds that takes seconds in account.
   */

  function getTimezoneOffsetInMilliseconds(dirtyDate) {
    var date = new Date(dirtyDate.getTime());
    var baseTimezoneOffset = date.getTimezoneOffset();
    date.setSeconds(0, 0);
    var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
    return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
  }
  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Now `isValid` doesn't throw an exception
   *   if the first argument is not an instance of Date.
   *   Instead, argument is converted beforehand using `toDate`.
   *
   *   Examples:
   *
   *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
   *   |---------------------------|---------------|---------------|
   *   | `new Date()`              | `true`        | `true`        |
   *   | `new Date('2016-01-01')`  | `true`        | `true`        |
   *   | `new Date('')`            | `false`       | `false`       |
   *   | `new Date(1488370835081)` | `true`        | `true`        |
   *   | `new Date(NaN)`           | `false`       | `false`       |
   *   | `'2016-01-01'`            | `TypeError`   | `true`        |
   *   | `''`                      | `TypeError`   | `false`       |
   *   | `1488370835081`           | `TypeError`   | `true`        |
   *   | `NaN`                     | `TypeError`   | `false`       |
   *
   *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
   *   that try to coerce arguments to the expected type
   *   (which is also the case with other *date-fns* functions).
   *
   * @param {*} date - the date to check
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // For the valid date:
   * var result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * var result = isValid(1393804800000)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * var result = isValid(new Date(''))
   * //=> false
   */


  function isValid(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    return !isNaN(date);
  }

  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },
    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },
    halfAMinute: 'half a minute',
    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },
    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },
    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },
    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },
    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },
    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },
    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },
    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },
    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },
    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },
    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  };

  function formatDistance(token, count, options) {
    options = options || {};
    var result;

    if (typeof formatDistanceLocale[token] === 'string') {
      result = formatDistanceLocale[token];
    } else if (count === 1) {
      result = formatDistanceLocale[token].one;
    } else {
      result = formatDistanceLocale[token].other.replace('{{count}}', count);
    }

    if (options.addSuffix) {
      if (options.comparison > 0) {
        return 'in ' + result;
      } else {
        return result + ' ago';
      }
    }

    return result;
  }

  function buildFormatLongFn(args) {
    return function (dirtyOptions) {
      var options = dirtyOptions || {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }

  var dateFormats = {
    full: 'EEEE, MMMM do, y',
    "long": 'MMMM do, y',
    medium: 'MMM d, y',
    "short": 'MM/dd/yyyy'
  };
  var timeFormats = {
    full: 'h:mm:ss a zzzz',
    "long": 'h:mm:ss a z',
    medium: 'h:mm:ss a',
    "short": 'h:mm a'
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    "long": "{{date}} 'at' {{time}}",
    medium: '{{date}}, {{time}}',
    "short": '{{date}}, {{time}}'
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: 'full'
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: 'full'
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: 'full'
    })
  };
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: 'P'
  };

  function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  }

  function buildLocalizeFn(args) {
    return function (dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var context = options.context ? String(options.context) : 'standalone';
      var valuesArray;

      if (context === 'formatting' && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;

        var _width = options.width ? String(options.width) : args.defaultWidth;

        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }

      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }

  var eraValues = {
    narrow: ['B', 'A'],
    abbreviated: ['BC', 'AD'],
    wide: ['Before Christ', 'Anno Domini']
  };
  var quarterValues = {
    narrow: ['1', '2', '3', '4'],
    abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
    wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

  };
  var monthValues = {
    narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
    abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };
  var dayValues = {
    narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    "short": ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  };
  var dayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    }
  };

  function ordinalNumber(dirtyNumber, _dirtyOptions) {
    var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`:
    //
    //   var options = dirtyOptions || {}
    //   var unit = String(options.unit)
    //
    // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'

    var rem100 = number % 100;

    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + 'st';

        case 2:
          return number + 'nd';

        case 3:
          return number + 'rd';
      }
    }

    return number + 'th';
  }

  var localize = {
    ordinalNumber: ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: 'wide'
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: 'wide',
      argumentCallback: function argumentCallback(quarter) {
        return Number(quarter) - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: 'wide'
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: 'wide'
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: 'wide',
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: 'wide'
    })
  };

  function buildMatchPatternFn(args) {
    return function (dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var matchResult = string.match(args.matchPattern);

      if (!matchResult) {
        return null;
      }

      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);

      if (!parseResult) {
        return null;
      }

      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value: value,
        rest: string.slice(matchedString.length)
      };
    };
  }

  function buildMatchFn(args) {
    return function (dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);

      if (!matchResult) {
        return null;
      }

      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var value;

      if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
        value = parsePatterns.findIndex(function (pattern) {
          return pattern.test(string);
        });
      } else {
        value = findKey(parsePatterns, function (pattern) {
          return pattern.test(string);
        });
      }

      value = args.valueCallback ? args.valueCallback(value) : value;
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value: value,
        rest: string.slice(matchedString.length)
      };
    };
  }

  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
  }

  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    "short": /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseEraPatterns,
      defaultParseWidth: 'any'
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: 'any',
      valueCallback: function valueCallback(index) {
        return index + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: 'any'
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseDayPatterns,
      defaultParseWidth: 'any'
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: 'any',
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: 'any'
    })
  };
  /**
   * @type {Locale}
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
   * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
   */

  var locale = {
    formatDistance: formatDistance,
    formatLong: formatLong,
    formatRelative: formatRelative,
    localize: localize,
    match: match,
    options: {
      weekStartsOn: 0
      /* Sunday */
      ,
      firstWeekContainsDate: 1
    }
  };
  /**
   * @name subMilliseconds
   * @category Millisecond Helpers
   * @summary Subtract the specified number of milliseconds from the given date.
   *
   * @description
   * Subtract the specified number of milliseconds from the given date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be subtracted
   * @returns {Date} the new date with the milliseconds subtracted
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
   * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:29.250
   */

  function subMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var amount = toInteger$1(dirtyAmount);
    return addMilliseconds(dirtyDate, -amount);
  }

  function addLeadingZeros(number, targetLength) {
    var sign = number < 0 ? '-' : '';
    var output = Math.abs(number).toString();

    while (output.length < targetLength) {
      output = '0' + output;
    }

    return sign + output;
  }
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* |                                |
   * |  d  | Day of month                   |  D  |                                |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  m  | Minute                         |  M  | Month                          |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  y  | Year (abs)                     |  Y  |                                |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   */


  var formatters = {
    // Year
    y: function y(date, token) {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
    },
    // Month
    M: function M(date, token) {
      var month = date.getUTCMonth();
      return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d: function d(date, token) {
      return addLeadingZeros(date.getUTCDate(), token.length);
    },
    // AM or PM
    a: function a(date, token) {
      var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return dayPeriodEnumValue.toUpperCase();

        case 'aaaaa':
          return dayPeriodEnumValue[0];

        case 'aaaa':
        default:
          return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
      }
    },
    // Hour [1-12]
    h: function h(date, token) {
      return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H: function H(date, token) {
      return addLeadingZeros(date.getUTCHours(), token.length);
    },
    // Minute
    m: function m(date, token) {
      return addLeadingZeros(date.getUTCMinutes(), token.length);
    },
    // Second
    s: function s(date, token) {
      return addLeadingZeros(date.getUTCSeconds(), token.length);
    },
    // Fraction of second
    S: function S(date, token) {
      var numberOfDigits = token.length;
      var milliseconds = date.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCDayOfYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCISOWeek(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function getUTCISOWeekYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCISOWeekYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var year = getUTCISOWeekYear(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary);
    return date;
  }

  var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCISOWeek(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)

    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCWeek(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function getUTCWeekYear(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var year = date.getUTCFullYear();
    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate);
    var year = getUTCWeekYear(dirtyDate, dirtyOptions);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek(firstWeek, dirtyOptions);
    return date;
  }

  var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCWeek(dirtyDate, options) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)

    return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
  }

  var dayPeriodEnum = {
    am: 'am',
    pm: 'pm',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */

  };
  var formatters$1 = {
    // Era
    G: function G(date, token, localize) {
      var era = date.getUTCFullYear() > 0 ? 1 : 0;

      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return localize.era(era, {
            width: 'abbreviated'
          });
        // A, B

        case 'GGGGG':
          return localize.era(era, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return localize.era(era, {
            width: 'wide'
          });
      }
    },
    // Year
    y: function y(date, token, localize) {
      // Ordinal number
      if (token === 'yo') {
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, {
          unit: 'year'
        });
      }

      return formatters.y(date, token);
    },
    // Local week-numbering year
    Y: function Y(date, token, localize, options) {
      var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

      if (token === 'YY') {
        var twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      } // Ordinal number


      if (token === 'Yo') {
        return localize.ordinalNumber(weekYear, {
          unit: 'year'
        });
      } // Padding


      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function R(date, token) {
      var isoWeekYear = getUTCISOWeekYear(date); // Padding

      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function u(date, token) {
      var year = date.getUTCFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function Q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
          return String(quarter);
        // 01, 02, 03, 04

        case 'QQ':
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone quarter
    q: function q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

      switch (token) {
        // 1, 2, 3, 4
        case 'q':
          return String(quarter);
        // 01, 02, 03, 04

        case 'qq':
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Month
    M: function M(date, token, localize) {
      var month = date.getUTCMonth();

      switch (token) {
        case 'M':
        case 'MM':
          return formatters.M(date, token);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return localize.month(month, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone month
    L: function L(date, token, localize) {
      var month = date.getUTCMonth();

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return String(month + 1);
        // 01, 02, ..., 12

        case 'LL':
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return localize.month(month, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Local week of year
    w: function w(date, token, localize, options) {
      var week = getUTCWeek(date, options);

      if (token === 'wo') {
        return localize.ordinalNumber(week, {
          unit: 'week'
        });
      }

      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function I(date, token, localize) {
      var isoWeek = getUTCISOWeek(date);

      if (token === 'Io') {
        return localize.ordinalNumber(isoWeek, {
          unit: 'week'
        });
      }

      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function d(date, token, localize) {
      if (token === 'do') {
        return localize.ordinalNumber(date.getUTCDate(), {
          unit: 'date'
        });
      }

      return formatters.d(date, token);
    },
    // Day of year
    D: function D(date, token, localize) {
      var dayOfYear = getUTCDayOfYear(date);

      if (token === 'Do') {
        return localize.ordinalNumber(dayOfYear, {
          unit: 'dayOfYear'
        });
      }

      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function E(date, token, localize) {
      var dayOfWeek = date.getUTCDay();

      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Local day of week
    e: function e(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case 'e':
          return String(localDayOfWeek);
        // Padded numerical value

        case 'ee':
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th

        case 'eo':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });

        case 'eee':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone local day of week
    c: function c(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

      switch (token) {
        // Numerical value (same as in `e`)
        case 'c':
          return String(localDayOfWeek);
        // Padded numerical value

        case 'cc':
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th

        case 'co':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });

        case 'ccc':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // ISO day of week
    i: function i(date, token, localize) {
      var dayOfWeek = date.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

      switch (token) {
        // 2
        case 'i':
          return String(isoDayOfWeek);
        // 02

        case 'ii':
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd

        case 'io':
          return localize.ordinalNumber(isoDayOfWeek, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'iiiii':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'iiiiii':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'iiii':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM or PM
    a: function a(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'aaaaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM, PM, midnight, noon
    b: function b(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;

      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
      }

      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'bbbbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function B(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;

      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }

      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'BBBBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Hour [1-12]
    h: function h(date, token, localize) {
      if (token === 'ho') {
        var hours = date.getUTCHours() % 12;
        if (hours === 0) hours = 12;
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return formatters.h(date, token);
    },
    // Hour [0-23]
    H: function H(date, token, localize) {
      if (token === 'Ho') {
        return localize.ordinalNumber(date.getUTCHours(), {
          unit: 'hour'
        });
      }

      return formatters.H(date, token);
    },
    // Hour [0-11]
    K: function K(date, token, localize) {
      var hours = date.getUTCHours() % 12;

      if (token === 'Ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function k(date, token, localize) {
      var hours = date.getUTCHours();
      if (hours === 0) hours = 24;

      if (token === 'ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function m(date, token, localize) {
      if (token === 'mo') {
        return localize.ordinalNumber(date.getUTCMinutes(), {
          unit: 'minute'
        });
      }

      return formatters.m(date, token);
    },
    // Second
    s: function s(date, token, localize) {
      if (token === 'so') {
        return localize.ordinalNumber(date.getUTCSeconds(), {
          unit: 'second'
        });
      }

      return formatters.s(date, token);
    },
    // Fraction of second
    S: function S(date, token) {
      return formatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function X(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      if (timezoneOffset === 0) {
        return 'Z';
      }

      switch (token) {
        // Hours and optional minutes
        case 'X':
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`

        case 'XXXX':
        case 'XX':
          // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`

        case 'XXXXX':
        case 'XXX': // Hours and minutes with `:` delimiter

        default:
          return formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function x(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Hours and optional minutes
        case 'x':
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`

        case 'xxxx':
        case 'xx':
          // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`

        case 'xxxxx':
        case 'xxx': // Hours and minutes with `:` delimiter

        default:
          return formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (GMT)
    O: function O(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case 'O':
        case 'OO':
        case 'OOO':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
        // Long

        case 'OOOO':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (specific non-location)
    z: function z(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case 'z':
        case 'zz':
        case 'zzz':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
        // Long

        case 'zzzz':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':');
      }
    },
    // Seconds timestamp
    t: function t(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = Math.floor(originalDate.getTime() / 1000);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function T(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = originalDate.getTime();
      return addLeadingZeros(timestamp, token.length);
    }
  };

  function formatTimezoneShort(offset, dirtyDelimiter) {
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;

    if (minutes === 0) {
      return sign + String(hours);
    }

    var delimiter = dirtyDelimiter || '';
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }

  function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? '-' : '+';
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }

    return formatTimezone(offset, dirtyDelimiter);
  }

  function formatTimezone(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    var minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }

  function dateLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'P':
        return formatLong.date({
          width: 'short'
        });

      case 'PP':
        return formatLong.date({
          width: 'medium'
        });

      case 'PPP':
        return formatLong.date({
          width: 'long'
        });

      case 'PPPP':
      default:
        return formatLong.date({
          width: 'full'
        });
    }
  }

  function timeLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'p':
        return formatLong.time({
          width: 'short'
        });

      case 'pp':
        return formatLong.time({
          width: 'medium'
        });

      case 'ppp':
        return formatLong.time({
          width: 'long'
        });

      case 'pppp':
      default:
        return formatLong.time({
          width: 'full'
        });
    }
  }

  function dateTimeLongFormatter(pattern, formatLong) {
    var matchResult = pattern.match(/(P+)(p+)?/);
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];

    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong);
    }

    var dateTimeFormat;

    switch (datePattern) {
      case 'P':
        dateTimeFormat = formatLong.dateTime({
          width: 'short'
        });
        break;

      case 'PP':
        dateTimeFormat = formatLong.dateTime({
          width: 'medium'
        });
        break;

      case 'PPP':
        dateTimeFormat = formatLong.dateTime({
          width: 'long'
        });
        break;

      case 'PPPP':
      default:
        dateTimeFormat = formatLong.dateTime({
          width: 'full'
        });
        break;
    }

    return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
  }

  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var protectedDayOfYearTokens = ['D', 'DD'];
  var protectedWeekYearTokens = ['YY', 'YYYY'];

  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }

  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }

  function throwProtectedError(token) {
    if (token === 'YYYY') {
      throw new RangeError('Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr');
    } else if (token === 'YY') {
      throw new RangeError('Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr');
    } else if (token === 'D') {
      throw new RangeError('Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr');
    } else if (token === 'DD') {
      throw new RangeError('Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr');
    }
  } // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps


  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'(.*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. The result may vary by locale.
   *
   * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   * (see the last example)
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 7 below the table).
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   | Notes |
   * |---------------------------------|---------|-----------------------------------|-------|
   * | Era                             | G..GGG  | AD, BC                            |       |
   * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 | GGGGG   | A, B                              |       |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
   * |                                 | yy      | 44, 01, 00, 17                    | 5     |
   * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
   * |                                 | yyyyy   | ...                               | 3,5   |
   * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
   * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
   * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
   * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
   * |                                 | YYYYY   | ...                               | 3,5   |
   * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
   * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
   * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
   * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
   * |                                 | RRRRR   | ...                               | 3,5,7 |
   * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
   * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
   * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
   * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
   * |                                 | uuuuu   | ...                               | 3,5   |
   * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
   * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | QQ      | 01, 02, 03, 04                    |       |
   * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
   * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | qq      | 01, 02, 03, 04                    |       |
   * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
   * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | MM      | 01, 02, ..., 12                   |       |
   * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 | MMMM    | January, February, ..., December  | 2     |
   * |                                 | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
   * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | LL      | 01, 02, ..., 12                   |       |
   * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 | LLLL    | January, February, ..., December  | 2     |
   * |                                 | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | w       | 1, 2, ..., 53                     |       |
   * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
   * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | II      | 01, 02, ..., 53                   | 7     |
   * | Day of month                    | d       | 1, 2, ..., 31                     |       |
   * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
   * |                                 | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
   * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
   * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
   * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 | DDDD    | ...                               | 3     |
   * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
   * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
   * |                                 | ii      | 01, 02, ..., 07                   | 7     |
   * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
   * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
   * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
   * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
   * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | ee      | 02, 03, ..., 01                   |       |
   * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | cc      | 02, 03, ..., 01                   |       |
   * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          | a..aaa  | AM, PM                            |       |
   * |                                 | aaaa    | a.m., p.m.                        | 2     |
   * |                                 | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
   * |                                 | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
   * |                                 | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
   * |                                 | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
   * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
   * |                                 | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          | m       | 0, 1, ..., 59                     |       |
   * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | mm      | 00, 01, ..., 59                   |       |
   * | Second                          | s       | 0, 1, ..., 59                     |       |
   * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | ss      | 00, 01, ..., 59                   |       |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
   * |                                 | SS      | 00, 01, ..., 99                   |       |
   * |                                 | SSS     | 000, 0001, ..., 999               |       |
   * |                                 | SSSS    | ...                               | 3     |
   * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
   * |                                 | XX      | -0800, +0530, Z                   |       |
   * |                                 | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
   * |                                 | xx      | -0800, +0530, +0000               |       |
   * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
   * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
   * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
   * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
   * | Seconds timestamp               | t       | 512969520                         | 7     |
   * |                                 | tt      | ...                               | 3,7   |
   * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
   * |                                 | TT      | ...                               | 3,7   |
   * | Long localized date             | P       | 05/29/1453                        | 7     |
   * |                                 | PP      | May 29, 1453                      | 7     |
   * |                                 | PPP     | May 29th, 1453                    | 7     |
   * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
   * | Long localized time             | p       | 12:00 AM                          | 7     |
   * |                                 | pp      | 12:00:00 AM                       | 7     |
   * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
   * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
   * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
   * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
   * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
   * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
   *    the output will be the same as default pattern for this unit, usually
   *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
   *    are marked with "2" in the last column of the table.
   *
   *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
   *
   * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
   *    The output will be padded with zeros to match the length of the pattern.
   *
   *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
   *
   * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 5. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` always returns the last two digits of a year,
   *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
   *
   *    | Year | `yy` | `uu` |
   *    |------|------|------|
   *    | 1    |   01 |   01 |
   *    | 14   |   14 |   14 |
   *    | 376  |   76 |  376 |
   *    | 1453 |   53 | 1453 |
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
   *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
   *
   * 6. Specific non-location timezones are currently unavailable in `date-fns`,
   *    so right now these tokens fall back to GMT timezones.
   *
   * 7. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `t`: seconds timestamp
   *    - `T`: milliseconds timestamp
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The second argument is now required for the sake of explicitness.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   format(new Date(2016, 0, 1))
   *
   *   // v2.0.0 onward
   *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
   *   ```
   *
   * - New format string API for `format` function
   *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
   *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
   *
   * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
   *
   * @param {Date|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://git.io/fxCyr
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://git.io/fxCyr
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
   *   locale: eoLocale
   * })
   * //=> '2-a de julio 2014'
   *
   * @example
   * // Escape string by single quote characters:
   * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
   * //=> "3 o'clock"
   */

  function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var formatStr = String(dirtyFormatStr);
    var options = dirtyOptions || {};
    var locale$1 = options.locale || locale;
    var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    if (!locale$1.localize) {
      throw new RangeError('locale must contain localize property');
    }

    if (!locale$1.formatLong) {
      throw new RangeError('locale must contain formatLong property');
    }

    var originalDate = toDate(dirtyDate);

    if (!isValid(originalDate)) {
      throw new RangeError('Invalid time value');
    } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


    var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
    var utcDate = subMilliseconds(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale$1,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
      var firstCharacter = substring[0];

      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale$1.formatLong, formatterOptions);
      }

      return substring;
    }).join('').match(formattingTokensRegExp).map(function (substring) {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return "'";
      }

      var firstCharacter = substring[0];

      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }

      var formatter = formatters$1[firstCharacter];

      if (formatter) {
        if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
          throwProtectedError(substring);
        }

        if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
          throwProtectedError(substring);
        }

        return formatter(utcDate, substring, locale$1.localize, formatterOptions);
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      }

      return substring;
    }).join('');
    return result;
  }

  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }

  function assign$1(target, dirtyObject) {
    if (target == null) {
      throw new TypeError('assign requires that input parameter not be null or undefined');
    }

    dirtyObject = dirtyObject || {};

    for (var property in dirtyObject) {
      if (dirtyObject.hasOwnProperty(property)) {
        target[property] = dirtyObject[property];
      }
    }

    return target;
  }
  /**
   * @name isAfter
   * @category Common Helpers
   * @summary Is the first date after the second one?
   *
   * @description
   * Is the first date after the second one?
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date that should be after the other one to return true
   * @param {Date|Number} dateToCompare - the date to compare with
   * @returns {Boolean} the first date is after the second date
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Is 10 July 1989 after 11 February 1987?
   * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> true
   */


  function isAfter(dirtyDate, dirtyDateToCompare) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() > dateToCompare.getTime();
  }
  /**
   * @name isBefore
   * @category Common Helpers
   * @summary Is the first date before the second one?
   *
   * @description
   * Is the first date before the second one?
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date that should be before the other one to return true
   * @param {Date|Number} dateToCompare - the date to compare with
   * @returns {Boolean} the first date is before the second date
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Is 10 July 1989 before 11 February 1987?
   * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> false
   */


  function isBefore(dirtyDate, dirtyDateToCompare) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() < dateToCompare.getTime();
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    var date = toDate(dirtyDate);
    var day = toInteger$1(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCISODay(dirtyDate, dirtyDay) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var day = toInteger$1(dirtyDay);

    if (day % 7 === 0) {
      day = day - 7;
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var isoWeek = toInteger$1(dirtyISOWeek);
    var diff = getUTCISOWeek(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var week = toInteger$1(dirtyWeek);
    var diff = getUTCWeek(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE$1 = 60000;
  var MILLISECONDS_IN_SECOND = 1000;
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59
    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

  };
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

  function parseNumericPattern(pattern, string, valueCallback) {
    var matchResult = string.match(pattern);

    if (!matchResult) {
      return null;
    }

    var value = parseInt(matchResult[0], 10);
    return {
      value: valueCallback ? valueCallback(value) : value,
      rest: string.slice(matchResult[0].length)
    };
  }

  function parseTimezonePattern(pattern, string) {
    var matchResult = string.match(pattern);

    if (!matchResult) {
      return null;
    } // Input is 'Z'


    if (matchResult[0] === 'Z') {
      return {
        value: 0,
        rest: string.slice(1)
      };
    }

    var sign = matchResult[1] === '+' ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1 + seconds * MILLISECONDS_IN_SECOND),
      rest: string.slice(matchResult[0].length)
    };
  }

  function parseAnyDigitsSigned(string, valueCallback) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
  }

  function parseNDigits(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

      default:
        return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
    }
  }

  function parseNDigitsSigned(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

      default:
        return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
    }
  }

  function dayPeriodEnumToHours(enumValue) {
    switch (enumValue) {
      case 'morning':
        return 4;

      case 'evening':
        return 17;

      case 'pm':
      case 'noon':
      case 'afternoon':
        return 12;

      case 'am':
      case 'midnight':
      case 'night':
      default:
        return 0;
    }
  }

  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0; // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC

    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;

    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }

    return isCommonEra ? result : 1 - result;
  }

  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // User for validation

  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
   * |  p  |                                |  P  |                                |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   */


  var parsers = {
    // Era
    G: {
      priority: 140,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return match.era(string, {
              width: 'abbreviated'
            }) || match.era(string, {
              width: 'narrow'
            });
          // A, B

          case 'GGGGG':
            return match.era(string, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return match.era(string, {
              width: 'wide'
            }) || match.era(string, {
              width: 'abbreviated'
            }) || match.era(string, {
              width: 'narrow'
            });
        }
      },
      set: function set(date, flags, value, _options) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['R', 'u', 't', 'T']
    },
    // Year
    y: {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
      priority: 130,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'yy'
          };
        };

        switch (token) {
          case 'y':
            return parseNDigits(4, string, valueCallback);

          case 'yo':
            return match.ordinalNumber(string, {
              unit: 'year',
              valueCallback: valueCallback
            });

          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function validate(_date, value, _options) {
        return value.isTwoDigitYear || value.year > 0;
      },
      set: function set(date, flags, value, _options) {
        var currentYear = date.getUTCFullYear();

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
    },
    // Local week-numbering year
    Y: {
      priority: 130,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'YY'
          };
        };

        switch (token) {
          case 'Y':
            return parseNDigits(4, string, valueCallback);

          case 'Yo':
            return match.ordinalNumber(string, {
              unit: 'year',
              valueCallback: valueCallback
            });

          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function validate(_date, value, _options) {
        return value.isTwoDigitYear || value.year > 0;
      },
      set: function set(date, flags, value, options) {
        var currentYear = getUTCWeekYear(date, options);

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      },
      incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
    },
    // ISO week-numbering year
    R: {
      priority: 130,
      parse: function parse(string, token, _match, _options) {
        if (token === 'R') {
          return parseNDigitsSigned(4, string);
        }

        return parseNDigitsSigned(token.length, string);
      },
      set: function set(_date, _flags, value, _options) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek(firstWeekOfYear);
      },
      incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
    },
    // Extended year
    u: {
      priority: 130,
      parse: function parse(string, token, _match, _options) {
        if (token === 'u') {
          return parseNDigitsSigned(4, string);
        }

        return parseNDigitsSigned(token.length, string);
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
    },
    // Quarter
    Q: {
      priority: 120,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
          case 'QQ':
            // 01, 02, 03, 04
            return parseNDigits(token.length, string);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return match.ordinalNumber(string, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return match.quarter(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return match.quarter(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 4;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Stand-alone quarter
    q: {
      priority: 120,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
          case 'qq':
            // 01, 02, 03, 04
            return parseNDigits(token.length, string);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return match.ordinalNumber(string, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return match.quarter(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return match.quarter(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 4;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Month
    M: {
      priority: 110,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'M':
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          // 01, 02, ..., 12

          case 'MM':
            return parseNDigits(2, string, valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return match.ordinalNumber(string, {
              unit: 'month',
              valueCallback: valueCallback
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return match.month(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return match.month(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.month(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Stand-alone month
    L: {
      priority: 110,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          // 01, 02, ..., 12

          case 'LL':
            return parseNDigits(2, string, valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return match.ordinalNumber(string, {
              unit: 'month',
              valueCallback: valueCallback
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return match.month(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return match.month(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.month(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Local week of year
    w: {
      priority: 100,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'w':
            return parseNumericPattern(numericPatterns.week, string);

          case 'wo':
            return match.ordinalNumber(string, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 53;
      },
      set: function set(date, _flags, value, options) {
        return startOfUTCWeek(setUTCWeek(date, value, options), options);
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
    },
    // ISO week of year
    I: {
      priority: 100,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'I':
            return parseNumericPattern(numericPatterns.week, string);

          case 'Io':
            return match.ordinalNumber(string, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 53;
      },
      set: function set(date, _flags, value, options) {
        return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
      },
      incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
    },
    // Day of the month
    d: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'd':
            return parseNumericPattern(numericPatterns.date, string);

          case 'do':
            return match.ordinalNumber(string, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(date, value, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();

        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Day of year
    D: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'D':
          case 'DD':
            return parseNumericPattern(numericPatterns.dayOfYear, string);

          case 'Do':
            return match.ordinalNumber(string, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(date, value, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
    },
    // Day of week
    E: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
    },
    // Local day of week
    e: {
      priority: 90,
      parse: function parse(string, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'e':
          case 'ee':
            // 03
            return parseNDigits(token.length, string, valueCallback);
          // 3rd

          case 'eo':
            return match.ordinalNumber(string, {
              unit: 'day',
              valueCallback: valueCallback
            });
          // Tue

          case 'eee':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
    },
    // Stand-alone local day of week
    c: {
      priority: 90,
      parse: function parse(string, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'c':
          case 'cc':
            // 03
            return parseNDigits(token.length, string, valueCallback);
          // 3rd

          case 'co':
            return match.ordinalNumber(string, {
              unit: 'day',
              valueCallback: valueCallback
            });
          // Tue

          case 'ccc':
            return match.day(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
    },
    // ISO day of week
    i: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          if (value === 0) {
            return 7;
          }

          return value;
        };

        switch (token) {
          // 2
          case 'i':
          case 'ii':
            // 02
            return parseNDigits(token.length, string);
          // 2nd

          case 'io':
            return match.ordinalNumber(string, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // T

          case 'iiiii':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // Tu

          case 'iiiiii':
            return match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // Tuesday

          case 'iiii':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 7;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCISODay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
    },
    // AM or PM
    a: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaaa':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['b', 'B', 'H', 'K', 'k', 't', 'T']
    },
    // AM, PM, midnight
    b: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbbb':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'B', 'H', 'K', 'k', 't', 'T']
    },
    // in the morning, in the afternoon, in the evening, at night
    B: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBBB':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 't', 'T']
    },
    // Hour [1-12]
    h: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'h':
            return parseNumericPattern(numericPatterns.hour12h, string);

          case 'ho':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 12;
      },
      set: function set(date, _flags, value, _options) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      },
      incompatibleTokens: ['H', 'K', 'k', 't', 'T']
    },
    // Hour [0-23]
    H: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'H':
            return parseNumericPattern(numericPatterns.hour23h, string);

          case 'Ho':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 23;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
    },
    // Hour [0-11]
    K: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'K':
            return parseNumericPattern(numericPatterns.hour11h, string);

          case 'Ko':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'H', 'k', 't', 'T']
    },
    // Hour [1-24]
    k: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'k':
            return parseNumericPattern(numericPatterns.hour24h, string);

          case 'ko':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 24;
      },
      set: function set(date, _flags, value, _options) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
    },
    // Minute
    m: {
      priority: 60,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'm':
            return parseNumericPattern(numericPatterns.minute, string);

          case 'mo':
            return match.ordinalNumber(string, {
              unit: 'minute'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 59;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Second
    s: {
      priority: 50,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 's':
            return parseNumericPattern(numericPatterns.second, string);

          case 'so':
            return match.ordinalNumber(string, {
              unit: 'second'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 59;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCSeconds(value, 0);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Fraction of second
    S: {
      priority: 30,
      parse: function parse(string, token, _match, _options) {
        var valueCallback = function valueCallback(value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };

        return parseNDigits(token.length, string, valueCallback);
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMilliseconds(value);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Timezone (ISO-8601. +00:00 is `'Z'`)
    X: {
      priority: 10,
      parse: function parse(string, token, _match, _options) {
        switch (token) {
          case 'X':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

          case 'XX':
            return parseTimezonePattern(timezonePatterns.basic, string);

          case 'XXXX':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

          case 'XXXXX':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

          case 'XXX':
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function set(date, flags, value, _options) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      },
      incompatibleTokens: ['t', 'T', 'x']
    },
    // Timezone (ISO-8601)
    x: {
      priority: 10,
      parse: function parse(string, token, _match, _options) {
        switch (token) {
          case 'x':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

          case 'xx':
            return parseTimezonePattern(timezonePatterns.basic, string);

          case 'xxxx':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

          case 'xxxxx':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

          case 'xxx':
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function set(date, flags, value, _options) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      },
      incompatibleTokens: ['t', 'T', 'X']
    },
    // Seconds timestamp
    t: {
      priority: 40,
      parse: function parse(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function set(_date, _flags, value, _options) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: '*'
    },
    // Milliseconds timestamp
    T: {
      priority: 20,
      parse: function parse(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function set(_date, _flags, value, _options) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: '*'
    }
  };
  var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps

  var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

  var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp$1 = /^'(.*?)'?$/;
  var doubleQuoteRegExp$1 = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format string.
   *
   * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters in the format string wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the format string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 5 below the table).
   *
   * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
   * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
   *
   * ```javascript
   * parse('23 AM', 'HH a', new Date())
   * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
   * ```
   *
   * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
   *
   * Accepted format string patterns:
   * | Unit                            |Prior| Pattern | Result examples                   | Notes |
   * |---------------------------------|-----|---------|-----------------------------------|-------|
   * | Era                             | 140 | G..GGG  | AD, BC                            |       |
   * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 |     | GGGGG   | A, B                              |       |
   * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
   * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
   * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
   * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
   * |                                 |     | yyyyy   | ...                               | 2,4   |
   * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
   * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
   * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
   * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
   * |                                 |     | YYYYY   | ...                               | 2,4   |
   * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
   * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
   * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
   * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
   * |                                 |     | RRRRR   | ...                               | 2,4,5 |
   * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
   * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
   * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
   * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
   * |                                 |     | uuuuu   | ...                               | 2,4   |
   * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
   * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
   * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
   * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | qq      | 01, 02, 03, 04                    |       |
   * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
   * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
   * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | MM      | 01, 02, ..., 12                   |       |
   * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | MMMM    | January, February, ..., December  | 2     |
   * |                                 |     | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
   * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | LL      | 01, 02, ..., 12                   |       |
   * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | LLLL    | January, February, ..., December  | 2     |
   * |                                 |     | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
   * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
   * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
   * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
   * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
   * |                                 |     | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
   * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
   * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
   * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 |     | DDDD    | ...                               | 2     |
   * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
   * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
   * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
   * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
   * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
   * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
   * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 5     |
   * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | ee      | 02, 03, ..., 01                   |       |
   * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | cc      | 02, 03, ..., 01                   |       |
   * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
   * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
   * |                                 |     | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 |     | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
   * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
   * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
   * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
   * |                                 |     | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
   * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
   * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | mm      | 00, 01, ..., 59                   |       |
   * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
   * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | ss      | 00, 01, ..., 59                   |       |
   * | Seconds timestamp               |  40 | t       | 512969520                         |       |
   * |                                 |     | tt      | ...                               | 2     |
   * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
   * |                                 |     | SS      | 00, 01, ..., 99                   |       |
   * |                                 |     | SSS     | 000, 0001, ..., 999               |       |
   * |                                 |     | SSSS    | ...                               | 2     |
   * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
   * |                                 |     | TT      | ...                               | 2     |
   * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
   * |                                 |     | XX      | -0800, +0530, Z                   |       |
   * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
   * |                                 |     | xx      | -0800, +0530, +0000               |       |
   * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
   * |                                 |     | PP      | May 29, 1453                      |       |
   * |                                 |     | PPP     | May 29th, 1453                    |       |
   * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
   * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
   * |                                 |     | pp      | 12:00:00 AM                       |       |
   * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
   * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
   * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
   * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular.
   *    In `format` function, they will produce different result:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   *    `parse` will try to match both formatting and stand-alone units interchangably.
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table:
   *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
   *      as wide as the sequence
   *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
   *      These variations are marked with "2" in the last column of the table.
   *
   * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 4. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` will try to guess the century of two digit year by proximity with `backupDate`:
   *
   *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
   *
   *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
   *
   *    while `uu` will just assign the year as is:
   *
   *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
   *
   *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
   *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
   *
   * 5. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
   *    on the given locale.
   *
   *    using `en-US` locale: `P` => `MM/dd/yyyy`
   *    using `en-US` locale: `p` => `hh:mm a`
   *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
   *    using `pt-BR` locale: `p` => `HH:mm`
   *
   * Values will be assigned to the date in the descending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `backupDate` which works as a context of parsing.
   *
   * `backupDate` must be passed for correct work of the function.
   * If you're not sure which `backupDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `backupDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `backupDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Old `parse` was renamed to `toDate`.
   *   Now `parse` is a new function which parses a string using a provided format.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   toDate('2016-01-01')
   *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
   *   ```
   *
   * @param {String} dateString - the string to parse
   * @param {String} formatString - the string of tokens
   * @param {Date|Number} backupDate - defines values missing from the parsed dateString
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://git.io/fxCyr
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://git.io/fxCyr
   * @returns {Date} the parsed date
   * @throws {TypeError} 3 arguments required
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} `options.locale` must contain `match` property
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in Esperanto locale in the context of 2010 year:
   * import eo from 'date-fns/locale/eo'
   * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
   *   locale: eo
   * })
   * //=> Sun Feb 28 2010 00:00:00
   */

  function parse(dirtyDateString, dirtyFormatString, dirtyBackupDate, dirtyOptions) {
    if (arguments.length < 3) {
      throw new TypeError('3 arguments required, but only ' + arguments.length + ' present');
    }

    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var options = dirtyOptions || {};
    var locale$1 = options.locale || locale;

    if (!locale$1.match) {
      throw new RangeError('locale must contain match property');
    }

    var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    if (formatString === '') {
      if (dateString === '') {
        return toDate(dirtyBackupDate);
      } else {
        return new Date(NaN);
      }
    }

    var subFnOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale$1 // If timezone isn't specified, it will be set to the system timezone

    };
    var setters = [{
      priority: TIMEZONE_UNIT_PRIORITY,
      set: dateToSystemTimezone,
      index: 0
    }];
    var i;
    var tokens = formatString.match(longFormattingTokensRegExp$1).map(function (substring) {
      var firstCharacter = substring[0];

      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale$1.formatLong, subFnOptions);
      }

      return substring;
    }).join('').match(formattingTokensRegExp$1);
    var usedTokens = [];

    for (i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
        throwProtectedError(token);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token);
      }

      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = void 0;

          for (var _i = 0; _i < usedTokens.length; _i++) {
            var usedToken = usedTokens[_i].token;

            if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
              incompatibleToken = usedTokens[_i];
              break;
            }
          }

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.parse(dateString, token, locale$1.match, subFnOptions);

        if (!parseResult) {
          return new Date(NaN);
        }

        setters.push({
          priority: parser.priority,
          set: parser.set,
          validate: parser.validate,
          value: parseResult.value,
          index: setters.length
        });
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString$1(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return new Date(NaN);
        }
      }
    } // Check if the remaining input contains something other than whitespace


    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }

    var uniquePrioritySetters = setters.map(function (setter) {
      return setter.priority;
    }).sort(function (a, b) {
      return b - a;
    }).filter(function (priority, index, array) {
      return array.indexOf(priority) === index;
    }).map(function (priority) {
      return setters.filter(function (setter) {
        return setter.priority === priority;
      }).reverse();
    }).map(function (setterArray) {
      return setterArray[0];
    });
    var date = toDate(dirtyBackupDate);

    if (isNaN(date)) {
      return new Date(NaN);
    } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


    var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
    var flags = {};

    for (i = 0; i < uniquePrioritySetters.length; i++) {
      var setter = uniquePrioritySetters[i];

      if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

      if (result[0]) {
        utcDate = result[0];
        assign$1(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }

    return utcDate;
  }

  function dateToSystemTimezone(date, flags) {
    if (flags.timestampIsSet) {
      return date;
    }

    var convertedDate = new Date(0);
    convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    return convertedDate;
  }

  function cleanEscapedString$1(input) {
    return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
  }

  var MILLISECONDS_IN_HOUR$1 = 3600000;
  var MILLISECONDS_IN_MINUTE$2 = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  /**
   * @name parseISO
   * @category Common Helpers
   * @summary Parse ISO string
   *
   * @description
   * Parse the given string in ISO 8601 format and return an instance of Date.
   *
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument isn't a string, the function cannot parse the string or
   * the values are invalid, it returns Invalid Date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The previous `parse` implementation was renamed to `parseISO`.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   parseISO('2016-01-01')
   *   ```
   *
   * - `parseISO` now validates separate date and time values in ISO-8601 strings
   *   and returns `Invalid Date` if the date is invalid.
   *
   *   ```javascript
   *   parseISO('2018-13-32')
   *   //=> Invalid Date
   *   ```
   *
   * - `parseISO` now doesn't fall back to `new Date` constructor
   *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
   *
   * @param {String} argument - the value to convert
   * @param {Object} [options] - an object with options.
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = parseISO('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = parseISO('+02014101', { additionalDigits: 1 })
   * //=> Fri Apr 11 2014 00:00:00
   */

  function parseISO(argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger$1(options.additionalDigits);

    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2');
    }

    if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
      return new Date(NaN);
    }

    var dateStrings = splitDateString(argument);
    var date;

    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }

    if (isNaN(date) || !date) {
      return new Date(NaN);
    }

    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);

      if (isNaN(time) || time === null) {
        return new Date(NaN);
      }
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);

      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var fullTime = timestamp + time;
      var fullTimeDate = new Date(fullTime);
      offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST

      var fullTimeDateNextDay = new Date(fullTime);
      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);
      var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - offset;

      if (offsetDiff > 0) {
        offset += offsetDiff;
      }
    }

    return new Date(timestamp + time + offset);
  }

  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;

    if (/:/.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];

      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }

    if (timeString) {
      var token = patterns.timezone.exec(timeString);

      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings;
  }

  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
    var captures = dateString.match(regex); // Invalid ISO-formatted year

    if (!captures) return {
      year: null
    };
    var year = captures[1] && parseInt(captures[1]);
    var century = captures[2] && parseInt(captures[2]);
    return {
      year: century == null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }

  function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return null;
    var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

    if (!captures) return null;
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;

    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }

      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date = new Date(0);

      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }

      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }

  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }

  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures) return null; // Invalid ISO-formatted time

    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);

    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }

    return hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2 + seconds * 1000;
  }

  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(',', '.')) || 0;
  }

  function parseTimezone(timezoneString) {
    if (timezoneString === 'Z') return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    var sign = captures[1] === '+' ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;

    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }

    return sign * (hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2);
  }

  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // Validation functions
  // February is null to handle the leap year (using ||)


  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function isLeapYearIndex$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100;
  }

  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex$1(year) ? 29 : 28));
  }

  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$1(year) ? 366 : 365);
  }

  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }

  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }

    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }

  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  var parseDate$1 = function parseDate(value, format) {
    if (isString_1(value)) {
      return format ? parse(value, format, new Date()) : parseISO(value);
    } else {
      return toDate(value);
    }
  }; // We want to set the messages a superglobal so that imports across files
  // reference the same messages object.


  var _global = typeof window !== 'undefined' ? window : commonjsGlobal || {};
  /**
   * Global validation message registry.
   */


  var messages = _global.__vuemc_validation_messages = _global.__vuemc_validation_messages || new ( /*#__PURE__*/function () {
    function _class() {
      _classCallCheck(this, _class);

      this.reset();
    }
    /**
     * Resets everything to the default configuration.
     */


    _createClass(_class, [{
      key: "reset",
      value: function reset() {
        this.$locale = 'en-us';
        this.$fallback = 'en-us';
        this.$locales = {};
        this.register(en_us);
      }
      /**
       * Sets the active locale.
       *
       * @param {string} locale
       */

    }, {
      key: "locale",
      value: function locale(_locale) {
        this.$locale = toLower_1(_locale);
      }
      /**
       * Registers a language pack.
       */

    }, {
      key: "register",
      value: function register(bundle) {
        var _this = this;

        var locale = toLower_1(bundle.locale);
        each(get_1(bundle, 'messages', {}), function (message, name) {
          set_1(_this.$locales, [locale, name], template_1(message));
        });
      }
      /**
       * Replaces or adds a new message for a given name and optional locale.
       *
       * @param {string} name
       * @param {string} format
       */

    }, {
      key: "set",
      value: function set(name, format, locale) {
        var $template = isString_1(format) ? template_1(format) : format; // Use the given locale.

        if (locale) {
          set_1(this.$locales, [locale, name], $template); // Otherwise use the active locale.
        } else if (this.$locale) {
          set_1(this.$locales, [this.$locale, name], $template); // Otherwise fall back to the default locale.
        } else {
          set_1(this.$locales, [this.$fallback, name], $template);
        }
      }
      /**
       * Returns a formatted string for a given message name and context data.
       *
       * @param {string} name
       * @param {Object} data
       *
       * @returns {string} The formatted message.
       */

    }, {
      key: "get",
      value: function get(name) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Attempt to find the name using the active locale, falling back to the
        // active locale's language, and finally falling back to the default.

        var template = get_1(this.$locales, [this.$locale, name], get_1(this.$locales, [split_1(this.$locale, '-')[0], name], get_1(this.$locales, [this.$fallback, name]))); // Fall back to a blank string so that we don't potentially
        // leak message names or context data into the template.

        if (!template) {
          return '';
        }

        return template(data);
      }
    }]);

    return _class;
  }())();
  /**
   * Rule helpers for easy validation.
   * These can all be used directly in a model's validation configuration.
   *
   * @example
   *
   * import {ascii, length} from 'vue-mc/validation'
   *
   * class User extends Model {
   *     validation() {
   *         return {
   *             password: ascii.and(length(6)),
   *         }
   *     }
   * }
   */

  /**
   * Creates a new validation rule.
   *
   * Rules returned by this function can be chained with `or` and `and`.
   * For example: `ruleA.or(ruleB.and(RuleC)).and(RuleD)`
   *
   * The error message can be set or replaced using `format(message|template)`.
   *
   * @param {Object} config:
   *     - name: Name of the error message.
   *     - data: Context for the error message.
   *     - test: Function accepting (value, model), which should
   *             return `true` if the value is valid.
   *
   * @returns {Function} Validation rule.
   */

  var rule = function rule(config) {
    var name = get_1(config, 'name');
    var data = get_1(config, 'data', {});
    var test = get_1(config, 'test', stubTrue_1);
    /**
     * This is the function that is called when using this rule.
     * It has some extra metadata to allow rule chaining and custom formats.
     */

    var $rule = function $rule(value, attribute, model) {
      // `true` if this rule's core acceptance criteria was met.
      var valid = test(value, attribute, model); // If valid, check that all rules in the "and" chain also pass.

      if (valid) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = $rule._and[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _and = _step.value;

            var result = _and(value, attribute, model); // If any of the chained rules return a string, we know that
            // that rule has failed, and therefore this chain is invalid.


            if (isString_1(result)) {
              return result;
            }
          } // Either there weren't any "and" rules or they all passed.

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true; // This rule's acceptance criteria was not met, but there is a chance
        // that a rule in the "or" chain's might pass.
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = $rule._or[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _or = _step2.value;

            var _result = _or(value, attribute, model); // A rule should either return true in the event of a general
            // "pass", or nothing at all. A failure would have to be a
            // string message (usually from another rule).


            if (_result === true || isUndefined_1(_result)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } // At this point we want to report that this rule has failed, because
      // none of the "and" or "or" chains passed either.
      // Add the invalid value to the message context, which is made available
      // to all rules by default. This allows for ${value} interpolation.


      assign_1(data, {
        attribute: attribute,
        value: value
      }); // This would be a custom format explicitly set on this rule.

      var format = get_1($rule, '_format'); // Use the default message if an explicit format isn't set.

      if (!format) {
        return messages.get(name, data);
      } // Replace the custom format with a template if it's still a string.


      if (isString_1(format)) {
        $rule._format = format = template_1(format);
      }

      return format(data);
    };
    /**
     * @returns {Function} A copy of this rule, so that appending to a chain or
     *                     setting a custom format doesn't modify the base rule.
     */


    $rule.copy = function () {
      return assign_1(rule({
        name: name,
        test: test,
        data: data
      }), pick_1($rule, ['_format', '_and', '_or']));
    };
    /**
     * Sets a custom error message format on this rule.
     *
     * @param {string|Function} format
     */


    $rule.format = function (format) {
      return assign_1($rule.copy(), {
        _format: format
      });
    };
    /**
     * Adds another rule or function to this rule's OR chain. If the given rule
     * passes when this one fails, this rule will return `true`.
     *
     * @param {Function|Function[]} rules One or more functions to add to the chain.
     */


    $rule.or = function (rules) {
      return assign_1($rule.copy(), {
        _or: concat_1($rule._or, rules)
      });
    };
    /**
     * Adds another rule or function to this rule's AND chain. If the given rule
     * fails when this one passes, this rule will return `false`.
     *
     * @param {Function|Function[]} rules One or more functions to add to the chain.
     */


    $rule.and = function (rules) {
      return assign_1($rule.copy(), {
        _and: concat_1($rule._and, rules)
      });
    };

    $rule._and = []; // "and" chain

    $rule._or = []; // "or" chain

    $rule._format = null; // Custom format

    return $rule;
  };
  /**
   * AVAILABLE RULES
   */

  /**
   * Checks if the value is after a given date string or `Date` object.
   */


  var after = function after(date) {
    return rule({
      name: 'after',
      data: {
        date: date
      },
      test: function test(value) {
        return isAfter(parseDate$1(value), parseDate$1(date));
      }
    });
  };
  /**
   * Checks if a value only has letters.
   */


  var alpha = rule({
    name: 'alpha',
    test: function test(value) {
      return isString_1(value) && isAlpha(deburr_1(value));
    }
  });
  /**
   * Checks if a value only has letters or numbers.
   */

  var alphanumeric = rule({
    name: 'alphanumeric',
    test: function test(value) {
      return isString_1(value) && isAlphanumeric(deburr_1(value));
    }
  });
  /**
   * Checks if a value is an array.
   */

  var array = rule({
    name: 'array',
    test: isArray_1
  });
  /**
   * Checks if a value is a string consisting only of ASCII characters.
   */

  var ascii = rule({
    name: 'ascii',
    test: function test(value) {
      return isString_1(value) && /^[\x00-\x7F]+$/.test(value);
    }
  });
  /**
   * Checks if a value is a valid Base64 string.
   */

  var base64 = rule({
    name: 'base64',
    test: function test(value) {
      return isString_1(value) && isBase64(value);
    }
  });
  /**
   * Checks if a value is before a given date string or `Date` object.
   */

  var before = function before(date) {
    return rule({
      name: 'before',
      data: {
        date: date
      },
      test: function test(value) {
        return isBefore(parseDate$1(value), parseDate$1(date));
      }
    });
  };
  /**
   * Checks if a value is between a given minimum or maximum, inclusive by default.
   */


  var between = function between(min, max) {
    var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var _min = +(isString_1(min) ? parseDate$1(min) : min);

    var _max = +(isString_1(max) ? parseDate$1(max) : max);

    return rule({
      data: {
        min: min,
        max: max
      },
      name: inclusive ? 'between_inclusive' : 'between',
      test: function test(value) {
        var _value = +(isString_1(value) ? parseDate$1(value) : value);

        return inclusive ? gte_1(_value, _min) && lte_1(_value, _max) : gt_1(_value, _min) && lt_1(_value, _max);
      }
    });
  };
  /**
   * Checks if a value is a boolean (strictly true or false).
   */


  var _boolean = rule({
    name: 'boolean',
    test: isBoolean_1
  });

  var creditcard = rule({
    name: 'creditcard',
    test: function test(value) {
      return isString_1(value) && isCreditCard(value);
    }
  });
  /**
   * Checks if a value is parseable as a date.
   */

  var date = rule({
    name: 'date',
    test: function test(value) {
      return isValid(parseDate$1(value));
    }
  });
  /**
   * Checks if a value matches the given date format.
   *
   * @see https://date-fns.org/v2.0.0-alpha.9/docs/format
   */

  var dateformat = function dateformat(format$1) {
    return rule({
      name: 'dateformat',
      data: {
        format: format$1
      },
      test: function test(value) {
        try {
          return isValid(parseDate$1(value.toString(), format$1)) && format(parseDate$1(value.toString(), format$1), format$1) === value.toString();
        } catch (error) {
          if (error instanceof RangeError) {
            return false;
          } else {
            throw error;
          }
        }
      }
    });
  };
  /**
   * Checks if a value is not `undefined`
   */


  var defined = rule({
    name: 'defined',
    test: function test(value) {
      return !isUndefined_1(value);
    }
  });
  /**
   * Checks if a value is a valid email address.
   */

  var email = rule({
    name: 'email',
    test: function test(value) {
      return isString_1(value) && isEmail(value);
    }
  });
  /**
   * Checks if value is considered empty.
   *
   * @see https://lodash.com/docs/#isEmpty
   */

  var empty = rule({
    name: 'empty',
    test: isEmpty_1
  });
  /**
   * Alias for `equals`
   */

  var equal = function equal(other) {
    return equals(other);
  };
  /**
   * Checks if a value equals the given value.
   */


  var equals = function equals(other) {
    return rule({
      name: 'equals',
      data: {
        other: other
      },
      test: function test(value) {
        return isEqual_1(value, other);
      }
    });
  };
  /**
   * Checks if a value is greater than a given minimum.
   */


  var gt$1 = function gt(min) {
    return rule({
      name: 'gt',
      data: {
        min: min
      },
      test: function test(value) {
        return gt_1(value, min);
      }
    });
  };
  /**
   * Checks if a value is greater than or equal to a given minimum.
   */


  var gte$1 = function gte(min) {
    return rule({
      name: 'gte',
      data: {
        min: min
      },
      test: function test(value) {
        return gte_1(value, min);
      }
    });
  };
  /**
   * Checks if a value is an integer.
   */


  var integer = rule({
    name: 'integer',
    test: isInteger_1
  });
  /**
   * Checks if a value is a valid IP address.
   */

  var ip = rule({
    name: 'ip',
    test: function test(value) {
      return isString_1(value) && isIP(value);
    }
  });
  /**
   * Checks if a value is a zero-length string.
   */

  var isblank = rule({
    name: 'isblank',
    test: function test(value) {
      return value === '';
    }
  });
  /**
   * Checks if a value is `null` or `undefined`.
   */

  var isnil = rule({
    name: 'isnil',
    test: isNil_1
  });
  /**
   * Checks if a value is `null`.
   */

  var isnull = rule({
    name: 'isnull',
    test: isNull_1
  });
  /**
   * Checks if a value is a valid ISO8601 date string.
   */

  var iso8601 = rule({
    name: 'iso8601',
    test: function test(value) {
      return isString_1(value) && isISO8601(value);
    }
  });
  /**
   * Checks if a value is valid JSON.
   */

  var json = rule({
    name: 'json',
    test: function test(value) {
      return isString_1(value) && isJSON(value);
    }
  });
  /**
   * Checks if a value's length is at least a given minimum, and no more than an
   * optional maximum.
   *
   * @see https://lodash.com/docs/#toLength
   */

  var length = function length(min, max) {
    // No maximum means the value must be *at least* the minimum.
    if (isUndefined_1(max)) {
      return rule({
        name: 'length',
        data: {
          min: min,
          max: max
        },
        test: function test(value) {
          return size_1(value) >= min;
        }
      });
    } // Minimum and maximum given, so check that the value is within the range.


    return rule({
      name: 'length_between',
      data: {
        min: min,
        max: max
      },
      test: function test(value) {
        var length = size_1(value);
        return length >= min && length <= max;
      }
    });
  };
  /**
   * Checks if a value is less than a given maximum.
   */


  var lt$1 = function lt(max) {
    return rule({
      name: 'lt',
      data: {
        max: max
      },
      test: function test(value) {
        return lt_1(value, max);
      }
    });
  };
  /**
   * Checks if a value is less than or equal to a given maximum.
   */


  var lte$1 = function lte(max) {
    return rule({
      name: 'lte',
      data: {
        max: max
      },
      test: function test(value) {
        return lte_1(value, max);
      }
    });
  };
  /**
   * Checks if a value matches a given regular expression string or RegExp.
   */


  var match$1 = function match(pattern) {
    return rule({
      name: 'match',
      data: {
        pattern: pattern
      },
      test: function test(value) {
        return new RegExp(pattern).test(value);
      }
    });
  };
  /**
   * Alias for `lte`.
   */


  var max = function max(_max2) {
    return lte$1(_max2);
  };
  /**
   * Alias for `gte`.
   */


  var min = function min(_min2) {
    return gte$1(_min2);
  };
  /**
   * Checks if a value is negative.
   */


  var negative = rule({
    name: 'negative',
    test: function test(value) {
      return toNumber_1(value) < 0;
    }
  });
  /**
   *
   */

  var not = function not() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return rule({
      name: 'not',
      test: function test(value) {
        return !includes_1(values, value);
      }
    });
  };
  /**
   * Checks if a value is a number (integer or float), excluding `NaN`.
   */


  var number = rule({
    name: 'number',
    test: function test(value) {
      return _isFinite(value);
    }
  });
  /**
   * Checks if a value is a number or numeric string, excluding `NaN`.
   */

  var numeric = rule({
    name: 'numeric',
    test: function test(value) {
      return isNumber_1(value) && !_isNaN(value) || value && isString_1(value) && !_isNaN(toNumber_1(value));
    }
  });
  /**
   * Checks if a value is an object, excluding arrays and functions.
   */

  var object = rule({
    name: 'object',
    test: function test(value) {
      return isObject_1(value) && !isArray_1(value) && !isFunction_1(value);
    }
  });
  /**
   * Checks if a value is positive.
   */

  var positive = rule({
    name: 'positive',
    test: function test(value) {
      return toNumber_1(value) > 0;
    }
  });
  /**
   * Checks if a value is present, ie. not `null`, `undefined`, or a blank string.
   */

  var required = rule({
    name: 'required',
    test: function test(value) {
      return !(isNil_1(value) || value === '');
    }
  });
  /**
   * Checks if a value equals another attribute's value.
   */

  var same = function same(other) {
    return rule({
      name: 'same',
      data: {
        other: other
      },
      test: function test(value, attribute, model) {
        return isEqual_1(value, model.get(other));
      }
    });
  };
  /**
   * Checks if a value is a string.
   */


  var string = rule({
    name: 'string',
    test: isString_1
  });
  /**
   * Checks if a value is a valid URL string.
   */

  var url = rule({
    name: 'url',
    test: function test(value) {
      return isString_1(value) && isURL(value);
    }
  });
  /**
   * Checks if a value is a valid UUID.
   */

  var uuid = rule({
    name: 'uuid',
    test: function test(value) {
      return isString_1(value) && isUUID(value);
    }
  });
  exports.after = after;
  exports.alpha = alpha;
  exports.alphanumeric = alphanumeric;
  exports.array = array;
  exports.ascii = ascii;
  exports.base64 = base64;
  exports.before = before;
  exports.between = between;
  exports["boolean"] = _boolean;
  exports.creditcard = creditcard;
  exports.date = date;
  exports.dateformat = dateformat;
  exports.defined = defined;
  exports.email = email;
  exports.empty = empty;
  exports.equal = equal;
  exports.equals = equals;
  exports.gt = gt$1;
  exports.gte = gte$1;
  exports.integer = integer;
  exports.ip = ip;
  exports.isblank = isblank;
  exports.isnil = isnil;
  exports.isnull = isnull;
  exports.iso8601 = iso8601;
  exports.json = json;
  exports.length = length;
  exports.lt = lt$1;
  exports.lte = lte$1;
  exports.match = match$1;
  exports.max = max;
  exports.messages = messages;
  exports.min = min;
  exports.negative = negative;
  exports.not = not;
  exports.number = number;
  exports.numeric = numeric;
  exports.object = object;
  exports.positive = positive;
  exports.required = required;
  exports.rule = rule;
  exports.same = same;
  exports.string = string;
  exports.url = url;
  exports.uuid = uuid;
})(validation);

class Branch extends vueMc.Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            country_id: null,
            state_id: null,
            town_id: null,
            active: null,
            is_default: null,
            name: null,
            code: null,
            address: null,
            phone: null,
            email: null,
            ucfe_code: null,
            ucfe_terminal: null,
            ucfe_password: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            company_id: (id) => lodash.toNumber(id) || null,
            country_id: (id) => lodash.toNumber(id) || null,
            state_id: (id) => lodash.toNumber(id) || null,
            town_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {
            company: validation.required
        };
    }
    routes() {
        return {
            fetch: "branches.show",
            create: "branches.store",
            update: "branches.update",
            delete: "branches.destroy",
        };
    }
}

class BranchCollection extends vueMc.Collection {
    model() {
        return Branch;
    }
    routes() {
        return {
            fetch: "branches.index",
        };
    }
    byCompany(iCompanyID) {
        return this.filterBy({ company: iCompanyID });
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
    byDefault() {
        return this.filterBy({ default: 1 });
    }
}

class Company extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: true,
            preview_image: null,
            firm: {}
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "companies.show",
            create: "companies.store",
            update: "companies.update",
            delete: "companies.destroy",
        };
    }
}

class CompanyCollection extends vueMc.Collection {
    model() {
        return Company;
    }
    routes() {
        return {
            fetch: "companies.index",
        };
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
    bySearch(sValue) {
        return this.filterBy({ search: sValue });
    }
    byCategory(sValue) {
        return this.filterBy({ category: sValue });
    }
    byUser(sValue) {
        return this.filterBy({ user: sValue });
    }
}

class CurrencyRate extends vueMc.Model {
    defaults() {
        return {
            id: null,
            currency_id: null,
            name: null,
            rate: null,
            rated_at: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "currencyrates.show",
            create: "currencyrates.store",
            update: "currencyrates.update",
            delete: "currencyrates.destroy",
        };
    }
}

class CurrencyRates extends vueMc.Collection {
    model() {
        return CurrencyRate;
    }
    routes() {
        return {
            fetch: "currencyrates.index",
        };
    }
}

class Customer extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: true,
            type: 1,
            preview_image: null,
            firm: {},
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "customers.show",
            create: "customers.store",
            update: "customers.update",
            delete: "customers.destroy",
        };
    }
}

class CustomerCollection extends vueMc.Collection {
    model() {
        return Customer;
    }
    routes() {
        return {
            fetch: "customers.index",
        };
    }
    byCompany(iCompanyID) {
        return this.filterBy({ company: iCompanyID });
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
}

class Firm extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            slug: null,
            code: null,
            description: null,
            doc_id: null,
            doc_type: null,
            address: null,
            email: null,
            phone: null,
            mobile: null,
            // Location data
            country_id: null,
            state_id: null,
            town_id: null,
            // DGI Data
            dgi_local_sec_nro: null,
            dgi_dir_fiscal: null,
            dgi_loc_nom: null,
            dgi_dpto_nom: null,
            dgi_denominacion: null,
            dgi_nombre_fantasia: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "firms.show",
            create: "firms.store",
            update: "firms.update",
            delete: "firms.destroy",
        };
    }
}

class FirmCollection extends vueMc.Collection {
    model() {
        return Firm;
    }
    routes() {
        return {
            fetch: "firms.index",
        };
    }
}

class PaymentTerm extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: false,
            cash: false,
            name: null,
            code: null,
            type: "fixed",
            frequency: "month",
            frequency_interval: 0,
            cycles: 0,
            delay: 0,
            description: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "paymentterms.show",
            create: "paymentterms.store",
            update: "paymentterms.update",
            delete: "paymentterms.destroy",
        };
    }
}

class PaymentTerms extends vueMc.Collection {
    model() {
        return PaymentTerm;
    }
    routes() {
        return {
            fetch: "paymentterms.index",
        };
    }
}

class Settings extends vueMc.Model {
    defaults() {
        return {
            preview_image: null,
        };
    }
    mutations() {
        return {};
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "settings.show",
            create: "settings.store",
        };
    }
}

exports.Account = Account;
exports.AccountCollection = AccountCollection;
exports.AccountType = AccountType;
exports.AccountTypeCollection = AccountTypeCollection;
exports.Branch = Branch;
exports.BranchCollection = BranchCollection;
exports.Company = Company;
exports.CompanyCollection = CompanyCollection;
exports.CurrencyRate = CurrencyRate;
exports.CurrencyRates = CurrencyRates;
exports.Customer = Customer;
exports.CustomerCollection = CustomerCollection;
exports.Firm = Firm;
exports.FirmCollection = FirmCollection;
exports.PaymentTerm = PaymentTerm;
exports.PaymentTerms = PaymentTerms;
exports.Settings = Settings;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1jLWd3LmpzIiwic291cmNlcyI6WyIuLi9zcmMvbW9kZWxzL0FjY291bnQudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQWNjb3VudENvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0FjY291bnRUeXBlLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL0FjY291bnRUeXBlQ29sbGVjdGlvbi50cyIsIi4uL25vZGVfbW9kdWxlcy92dWUtbWMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uL3NyYy9tb2RlbHMvQnJhbmNoLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL0JyYW5jaENvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0NvbXBhbnkudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQ29tcGFueUNvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0N1cnJlbmN5UmF0ZS50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9DdXJyZW5jeVJhdGVzLnRzIiwiLi4vc3JjL21vZGVscy9DdXN0b21lci50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9DdXN0b21lckNvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0Zpcm0udHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvRmlybUNvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL1BheW1lbnRUZXJtLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL1BheW1lbnRUZXJtcy50cyIsIi4uL3NyYy9tb2RlbHMvU2V0dGluZ3MudHMiXSwic291cmNlc0NvbnRlbnQiOltudWxsLG51bGwsbnVsbCxudWxsLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuLyoqXG4gKiBBZnJpa2FhbnNcbiAqL1xudmFyIGVuX3VzID0ge1xuICBsb2NhbGU6ICdlbi1VUycsXG4gIG1lc3NhZ2VzOiB7XG4gICAgYWZ0ZXI6ICdNdXN0IGJlIGFmdGVyICR7ZGF0ZX0nLFxuICAgIGFscGhhOiAnQ2FuIG9ubHkgdXNlIGxldHRlcnMnLFxuICAgIGFscGhhbnVtZXJpYzogJ011c3QgYmUgYWxwaGFudW1lcmljJyxcbiAgICBhcnJheTogJ011c3QgYmUgYW4gYXJyYXknLFxuICAgIGFzY2lpOiAnTXVzdCBiZSBBU0NJSScsXG4gICAgYmFzZTY0OiAnTXVzdCBiZSB2YWxpZCBCYXNlNjQnLFxuICAgIGJlZm9yZTogJ011c3QgYmUgYmVmb3JlICR7ZGF0ZX0nLFxuICAgIGJldHdlZW46ICdNdXN0IGJlIGJldHdlZW4gJHttaW59IGFuZCAke21heH0nLFxuICAgIGJldHdlZW5faW5jbHVzaXZlOiAnTXVzdCBiZSBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9LCBpbmNsdXNpdmUnLFxuICAgIFwiYm9vbGVhblwiOiAnTXVzdCBiZSB0cnVlIG9yIGZhbHNlJyxcbiAgICBjcmVkaXRjYXJkOiAnTXVzdCBiZSBhIHZhbGlkIGNyZWRpdCBjYXJkIG51bWJlcicsXG4gICAgZGF0ZTogJ011c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgICBkYXRlZm9ybWF0OiAnTXVzdCB1c2UgXCIke2Zvcm1hdH1cIiBmb3JtYXQnLFxuICAgIGRlZmluZWQ6ICdSZXF1aXJlZCcsXG4gICAgZW1haWw6ICdNdXN0IGJlIGEgdmFsaWQgZW1haWwgYWRkcmVzcycsXG4gICAgZW1wdHk6ICdNdXN0IGJlIGVtcHR5JyxcbiAgICBlcXVhbHM6ICdNdXN0IGJlIGVxdWFsIHRvICR7b3RoZXJ9JyxcbiAgICBndDogJ011c3QgYmUgZ3JlYXRlciB0aGFuICR7bWlufScsXG4gICAgZ3RlOiAnTXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59JyxcbiAgICBpbnRlZ2VyOiAnTXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICBpcDogJ011c3QgYmUgYSB2YWxpZCBJUCBhZGRyZXNzJyxcbiAgICBpc2JsYW5rOiAnTWF5IG5vdCBiZSBibGFuaycsXG4gICAgaXNuaWw6ICdSZXF1aXJlZCcsXG4gICAgaXNudWxsOiAnUmVxdWlyZWQnLFxuICAgIGlzbzg2MDE6ICdNdXN0IGJlIGEgdmFsaWQgSVNPODYwMSBkYXRlJyxcbiAgICBqc29uOiAnTXVzdCBiZSBhIHZhbGlkIEpTT04nLFxuICAgIGxlbmd0aDogJ011c3QgaGF2ZSBhIGxlbmd0aCBvZiBhdCBsZWFzdCAke21pbn0nLFxuICAgIGxlbmd0aF9iZXR3ZWVuOiAnTXVzdCBoYXZlIGEgbGVuZ3RoIGJldHdlZW4gJHttaW59IGFuZCAke21heH0nLFxuICAgIGx0OiAnTXVzdCBiZSBsZXNzIHRoYW4gJHttYXh9JyxcbiAgICBsdGU6ICdNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH0nLFxuICAgIG1hdGNoOiAnTXVzdCBtYXRjaCBcIiR7cGF0dGVybn1cIicsXG4gICAgbmVnYXRpdmU6ICdNdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyxcbiAgICBub3Q6ICdDYW4gbm90IGJlICR7dmFsdWV9JyxcbiAgICBudW1iZXI6ICdNdXN0IGJlIGEgbnVtYmVyJyxcbiAgICBudW1lcmljOiAnTXVzdCBiZSBudW1lcmljJyxcbiAgICBvYmplY3Q6ICdNdXN0IGJlIGFuIG9iamVjdCcsXG4gICAgcG9zaXRpdmU6ICdNdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcbiAgICByZXF1aXJlZDogJ1JlcXVpcmVkJyxcbiAgICBzYW1lOiAnTXVzdCBoYXZlIHRoZSBzYW1lIHZhbHVlIGFzIFwiJHtvdGhlcn1cIicsXG4gICAgc3RyaW5nOiAnTXVzdCBiZSBhIHN0cmluZycsXG4gICAgdXJsOiAnTXVzdCBiZSBhIHZhbGlkIFVSTCcsXG4gICAgdXVpZDogJ011c3QgYmUgYSB2YWxpZCBVVUlEJ1xuICB9XG4gIC8qKlxuICAgKiBQZXJzaWFuIC0gSXNsYW1pYyBSZXB1YmxpYyBvZiBJcmFuXG4gICAqL1xuXG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGFzc2VydFN0cmluZ18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0U3RyaW5nO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcoaW5wdXQpIHtcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcblxuICBpZiAoIWlzU3RyaW5nKSB7XG4gICAgdmFyIGludmFsaWRUeXBlO1xuXG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICBpbnZhbGlkVHlwZSA9ICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YWxpZFR5cGUgPSBfdHlwZW9mKGlucHV0KTtcblxuICAgICAgaWYgKGludmFsaWRUeXBlID09PSAnb2JqZWN0JyAmJiBpbnB1dC5jb25zdHJ1Y3RvciAmJiBpbnB1dC5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKSB7XG4gICAgICAgIGludmFsaWRUeXBlID0gaW5wdXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRUeXBlID0gXCJhIFwiLmNvbmNhdChpbnZhbGlkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQgXCIuY29uY2F0KGludmFsaWRUeXBlLCBcIi5cIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFzc2VydFN0cmluZ18xKTtcblxudmFyIGFscGhhXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbW1hRGVjaW1hbCA9IGV4cG9ydHMuZG90RGVjaW1hbCA9IGV4cG9ydHMuYXJhYmljTG9jYWxlcyA9IGV4cG9ydHMuZW5nbGlzaExvY2FsZXMgPSBleHBvcnRzLmRlY2ltYWwgPSBleHBvcnRzLmFscGhhbnVtZXJpYyA9IGV4cG9ydHMuYWxwaGEgPSB2b2lkIDA7XG52YXIgYWxwaGEgPSB7XG4gICdlbi1VUyc6IC9eW0EtWl0rJC9pLFxuICAnYmctQkcnOiAvXlvQkC3Qr10rJC9pLFxuICAnY3MtQ1onOiAvXltBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1dKyQvaSxcbiAgJ2RhLURLJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdkZS1ERSc6IC9eW0EtWsOEw5bDnMOfXSskL2ksXG4gICdlbC1HUic6IC9eW86RLc+JXSskL2ksXG4gICdlcy1FUyc6IC9eW0EtWsOBw4nDjcORw5PDmsOcXSskL2ksXG4gICdmci1GUic6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSskL2ksXG4gICdpdC1JVCc6IC9eW0EtWsOAw4nDiMOMw47Dk8OSw5ldKyQvaSxcbiAgJ25iLU5PJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdubC1OTCc6IC9eW0EtWsOBw4nDi8OPw5PDlsOcw5pdKyQvaSxcbiAgJ25uLU5PJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdodS1IVSc6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsF0rJC9pLFxuICAncGwtUEwnOiAvXltBLVrEhMSGxJjFmsWBxYPDk8W7xbldKyQvaSxcbiAgJ3B0LVBUJzogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKyQvaSxcbiAgJ3J1LVJVJzogL15b0JAt0K/QgV0rJC9pLFxuICAnc2wtU0knOiAvXltBLVrEjMSGxJDFoMW9XSskL2ksXG4gICdzay1TSyc6IC9eW0EtWsOBxIzEjsOJw43Fh8OTxaDFpMOaw53FvcS5xZTEvcOEw5RdKyQvaSxcbiAgJ3NyLVJTQGxhdGluJzogL15bQS1axIzEhsW9xaDEkF0rJC9pLFxuICAnc3ItUlMnOiAvXlvQkC3Qr9CC0IjQidCK0IvQj10rJC9pLFxuICAnc3YtU0UnOiAvXltBLVrDhcOEw5ZdKyQvaSxcbiAgJ3RyLVRSJzogL15bQS1aw4fEnsSwxLHDlsWew5xdKyQvaSxcbiAgJ3VrLVVBJzogL15b0JAt0KnQrNCu0K/QhEnQh9KQ0ZZdKyQvaSxcbiAgJ2t1LUlRJzogL15b2KbYp9io2b7Yqtis2obYrdiu2K/YsdqV2LLamNiz2LTYudi62YHapNmC2qnar9mE2rXZhdmG2Yjbhtq+25XbjNuO2YrYt9ik2KvYotil2KPZg9i22LXYqdi42LBdKyQvaSxcbiAgYXI6IC9eW9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0rJC9cbn07XG5leHBvcnRzLmFscGhhID0gYWxwaGE7XG52YXIgYWxwaGFudW1lcmljID0ge1xuICAnZW4tVVMnOiAvXlswLTlBLVpdKyQvaSxcbiAgJ2JnLUJHJzogL15bMC050JAt0K9dKyQvaSxcbiAgJ2NzLUNaJzogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSskL2ksXG4gICdkYS1ESyc6IC9eWzAtOUEtWsOGw5jDhV0rJC9pLFxuICAnZGUtREUnOiAvXlswLTlBLVrDhMOWw5zDn10rJC9pLFxuICAnZWwtR1InOiAvXlswLTnOkS3PiV0rJC9pLFxuICAnZXMtRVMnOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF0rJC9pLFxuICAnZnItRlInOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0rJC9pLFxuICAnaXQtSVQnOiAvXlswLTlBLVrDgMOJw4jDjMOOw5PDksOZXSskL2ksXG4gICdodS1IVSc6IC9eWzAtOUEtWsOBw4nDjcOTw5bFkMOaw5zFsF0rJC9pLFxuICAnbmItTk8nOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ25sLU5MJzogL15bMC05QS1aw4HDicOLw4/Dk8OWw5zDml0rJC9pLFxuICAnbm4tTk8nOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ3BsLVBMJzogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSskL2ksXG4gICdwdC1QVCc6IC9eWzAtOUEtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSskL2ksXG4gICdydS1SVSc6IC9eWzAtOdCQLdCv0IFdKyQvaSxcbiAgJ3NsLVNJJzogL15bMC05QS1axIzEhsSQxaDFvV0rJC9pLFxuICAnc2stU0snOiAvXlswLTlBLVrDgcSMxI7DicONxYfDk8WgxaTDmsOdxb3EucWUxL3DhMOUXSskL2ksXG4gICdzci1SU0BsYXRpbic6IC9eWzAtOUEtWsSMxIbFvcWgxJBdKyQvaSxcbiAgJ3NyLVJTJzogL15bMC050JAt0K/QgtCI0InQitCL0I9dKyQvaSxcbiAgJ3N2LVNFJzogL15bMC05QS1aw4XDhMOWXSskL2ksXG4gICd0ci1UUic6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXSskL2ksXG4gICd1ay1VQSc6IC9eWzAtOdCQLdCp0KzQrtCv0IRJ0IfSkNGWXSskL2ksXG4gICdrdS1JUSc6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KbYp9io2b7Yqtis2obYrdiu2K/YsdqV2LLamNiz2LTYudi62YHapNmC2qnar9mE2rXZhdmG2Yjbhtq+25XbjNuO2YrYt9ik2KvYotil2KPZg9i22LXYqdi42LBdKyQvaSxcbiAgYXI6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXSskL1xufTtcbmV4cG9ydHMuYWxwaGFudW1lcmljID0gYWxwaGFudW1lcmljO1xudmFyIGRlY2ltYWwgPSB7XG4gICdlbi1VUyc6ICcuJyxcbiAgYXI6ICfZqydcbn07XG5leHBvcnRzLmRlY2ltYWwgPSBkZWNpbWFsO1xudmFyIGVuZ2xpc2hMb2NhbGVzID0gWydBVScsICdHQicsICdISycsICdJTicsICdOWicsICdaQScsICdaTSddO1xuZXhwb3J0cy5lbmdsaXNoTG9jYWxlcyA9IGVuZ2xpc2hMb2NhbGVzO1xuXG5mb3IgKHZhciBsb2NhbGUsIGkgPSAwOyBpIDwgZW5nbGlzaExvY2FsZXMubGVuZ3RoOyBpKyspIHtcbiAgbG9jYWxlID0gXCJlbi1cIi5jb25jYXQoZW5nbGlzaExvY2FsZXNbaV0pO1xuICBhbHBoYVtsb2NhbGVdID0gYWxwaGFbJ2VuLVVTJ107XG4gIGFscGhhbnVtZXJpY1tsb2NhbGVdID0gYWxwaGFudW1lcmljWydlbi1VUyddO1xuICBkZWNpbWFsW2xvY2FsZV0gPSBkZWNpbWFsWydlbi1VUyddO1xufSAvLyBTb3VyY2U6IGh0dHA6Ly93d3cubG9jYWxlcGxhbmV0LmNvbS9qYXZhL1xuXG5cbnZhciBhcmFiaWNMb2NhbGVzID0gWydBRScsICdCSCcsICdEWicsICdFRycsICdJUScsICdKTycsICdLVycsICdMQicsICdMWScsICdNQScsICdRTScsICdRQScsICdTQScsICdTRCcsICdTWScsICdUTicsICdZRSddO1xuZXhwb3J0cy5hcmFiaWNMb2NhbGVzID0gYXJhYmljTG9jYWxlcztcblxuZm9yICh2YXIgX2xvY2FsZSwgX2kgPSAwOyBfaSA8IGFyYWJpY0xvY2FsZXMubGVuZ3RoOyBfaSsrKSB7XG4gIF9sb2NhbGUgPSBcImFyLVwiLmNvbmNhdChhcmFiaWNMb2NhbGVzW19pXSk7XG4gIGFscGhhW19sb2NhbGVdID0gYWxwaGEuYXI7XG4gIGFscGhhbnVtZXJpY1tfbG9jYWxlXSA9IGFscGhhbnVtZXJpYy5hcjtcbiAgZGVjaW1hbFtfbG9jYWxlXSA9IGRlY2ltYWwuYXI7XG59IC8vIFNvdXJjZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVjaW1hbF9tYXJrXG5cblxudmFyIGRvdERlY2ltYWwgPSBbXTtcbmV4cG9ydHMuZG90RGVjaW1hbCA9IGRvdERlY2ltYWw7XG52YXIgY29tbWFEZWNpbWFsID0gWydiZy1CRycsICdjcy1DWicsICdkYS1ESycsICdkZS1ERScsICdlbC1HUicsICdlcy1FUycsICdmci1GUicsICdpdC1JVCcsICdrdS1JUScsICdodS1IVScsICduYi1OTycsICdubi1OTycsICdubC1OTCcsICdwbC1QTCcsICdwdC1QVCcsICdydS1SVScsICdzbC1TSScsICdzci1SU0BsYXRpbicsICdzci1SUycsICdzdi1TRScsICd0ci1UUicsICd1ay1VQSddO1xuZXhwb3J0cy5jb21tYURlY2ltYWwgPSBjb21tYURlY2ltYWw7XG5cbmZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGRvdERlY2ltYWwubGVuZ3RoOyBfaTIrKykge1xuICBkZWNpbWFsW2RvdERlY2ltYWxbX2kyXV0gPSBkZWNpbWFsWydlbi1VUyddO1xufVxuXG5mb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjb21tYURlY2ltYWwubGVuZ3RoOyBfaTMrKykge1xuICBkZWNpbWFsW2NvbW1hRGVjaW1hbFtfaTNdXSA9ICcsJztcbn1cblxuYWxwaGFbJ3B0LUJSJ10gPSBhbHBoYVsncHQtUFQnXTtcbmFscGhhbnVtZXJpY1sncHQtQlInXSA9IGFscGhhbnVtZXJpY1sncHQtUFQnXTtcbmRlY2ltYWxbJ3B0LUJSJ10gPSBkZWNpbWFsWydwdC1QVCddOyAvLyBzZWUgIzg2MlxuXG5hbHBoYVsncGwtUGwnXSA9IGFscGhhWydwbC1QTCddO1xuYWxwaGFudW1lcmljWydwbC1QbCddID0gYWxwaGFudW1lcmljWydwbC1QTCddO1xuZGVjaW1hbFsncGwtUGwnXSA9IGRlY2ltYWxbJ3BsLVBMJ107XG59KTtcblxudW53cmFwRXhwb3J0cyhhbHBoYV8xKTtcbnZhciBhbHBoYV8yID0gYWxwaGFfMS5jb21tYURlY2ltYWw7XG52YXIgYWxwaGFfMyA9IGFscGhhXzEuZG90RGVjaW1hbDtcbnZhciBhbHBoYV80ID0gYWxwaGFfMS5hcmFiaWNMb2NhbGVzO1xudmFyIGFscGhhXzUgPSBhbHBoYV8xLmVuZ2xpc2hMb2NhbGVzO1xudmFyIGFscGhhXzYgPSBhbHBoYV8xLmRlY2ltYWw7XG52YXIgYWxwaGFfNyA9IGFscGhhXzEuYWxwaGFudW1lcmljO1xudmFyIGFscGhhXzggPSBhbHBoYV8xLmFscGhhO1xuXG52YXIgaXNBbHBoYV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBbHBoYTtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuXG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQWxwaGEoc3RyKSB7XG4gIHZhciBsb2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdlbi1VUyc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiBhbHBoYV8xLmFscGhhKSB7XG4gICAgcmV0dXJuIGFscGhhXzEuYWxwaGFbbG9jYWxlXS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhhbHBoYV8xLmFscGhhKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7XG59KTtcblxudmFyIGlzQWxwaGEgPSB1bndyYXBFeHBvcnRzKGlzQWxwaGFfMSk7XG52YXIgaXNBbHBoYV8yID0gaXNBbHBoYV8xLmxvY2FsZXM7XG5cbnZhciBpc0FscGhhbnVtZXJpY18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBbHBoYW51bWVyaWM7XG5leHBvcnRzLmxvY2FsZXMgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cblxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0FscGhhbnVtZXJpYyhzdHIpIHtcbiAgdmFyIGxvY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2VuLVVTJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAobG9jYWxlIGluIGFscGhhXzEuYWxwaGFudW1lcmljKSB7XG4gICAgcmV0dXJuIGFscGhhXzEuYWxwaGFudW1lcmljW2xvY2FsZV0udGVzdChzdHIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChsb2NhbGUsIFwiJ1wiKSk7XG59XG5cbnZhciBsb2NhbGVzID0gT2JqZWN0LmtleXMoYWxwaGFfMS5hbHBoYW51bWVyaWMpO1xuZXhwb3J0cy5sb2NhbGVzID0gbG9jYWxlcztcbn0pO1xuXG52YXIgaXNBbHBoYW51bWVyaWMgPSB1bndyYXBFeHBvcnRzKGlzQWxwaGFudW1lcmljXzEpO1xudmFyIGlzQWxwaGFudW1lcmljXzIgPSBpc0FscGhhbnVtZXJpY18xLmxvY2FsZXM7XG5cbnZhciBpc0Jhc2U2NF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCYXNlNjQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBub3RCYXNlNjQgPSAvW15BLVowLTkrXFwvPV0vaTtcblxuZnVuY3Rpb24gaXNCYXNlNjQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGlmICghbGVuIHx8IGxlbiAlIDQgIT09IDAgfHwgbm90QmFzZTY0LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBmaXJzdFBhZGRpbmdDaGFyID0gc3RyLmluZGV4T2YoJz0nKTtcbiAgcmV0dXJuIGZpcnN0UGFkZGluZ0NoYXIgPT09IC0xIHx8IGZpcnN0UGFkZGluZ0NoYXIgPT09IGxlbiAtIDEgfHwgZmlyc3RQYWRkaW5nQ2hhciA9PT0gbGVuIC0gMiAmJiBzdHJbbGVuIC0gMV0gPT09ICc9Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc0Jhc2U2NCA9IHVud3JhcEV4cG9ydHMoaXNCYXNlNjRfMSk7XG5cbnZhciBpc0NyZWRpdENhcmRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQ3JlZGl0Q2FyZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIGNyZWRpdENhcmQgPSAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoMjIyWzEtOV18MjJbMy05XVswLTldfDJbMy02XVswLTldezJ9fDI3WzAxXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfXw2WzI3XVswLTldezE0fSkkLztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBpc0NyZWRpdENhcmQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZSgvWy0gXSsvZywgJycpO1xuXG4gIGlmICghY3JlZGl0Q2FyZC50ZXN0KHNhbml0aXplZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGRpZ2l0O1xuICB2YXIgdG1wTnVtO1xuICB2YXIgc2hvdWxkRG91YmxlO1xuXG4gIGZvciAodmFyIGkgPSBzYW5pdGl6ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBkaWdpdCA9IHNhbml0aXplZC5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIHRtcE51bSA9IHBhcnNlSW50KGRpZ2l0LCAxMCk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICB0bXBOdW0gKj0gMjtcblxuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gdG1wTnVtICUgMTAgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VtICs9IHRtcE51bTtcbiAgICB9XG5cbiAgICBzaG91bGREb3VibGUgPSAhc2hvdWxkRG91YmxlO1xuICB9XG5cbiAgcmV0dXJuICEhKHN1bSAlIDEwID09PSAwID8gc2FuaXRpemVkIDogZmFsc2UpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzQ3JlZGl0Q2FyZCA9IHVud3JhcEV4cG9ydHMoaXNDcmVkaXRDYXJkXzEpO1xuXG52YXIgbWVyZ2VfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1lcmdlO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgdmFyIG9iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWZhdWx0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnVud3JhcEV4cG9ydHMobWVyZ2VfMSk7XG5cbnZhciBpc0J5dGVMZW5ndGhfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQnl0ZUxlbmd0aDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG5mdW5jdGlvbiBpc0J5dGVMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKF90eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcbiAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgfSBlbHNlIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNCeXRlTGVuZ3RoKHN0ciwgbWluIFssIG1heF0pXG4gICAgbWluID0gYXJndW1lbnRzWzFdO1xuICAgIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmNvZGVVUkkoc3RyKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGlzQnl0ZUxlbmd0aF8xKTtcblxudmFyIGlzRlFETl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGUUROO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfZnFkbl9vcHRpb25zID0ge1xuICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlLFxuICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBpc0ZRRE4oc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcbiAgLyogUmVtb3ZlIHRoZSBvcHRpb25hbCB0cmFpbGluZyBkb3QgYmVmb3JlIGNoZWNraW5nIHZhbGlkaXR5ICovXG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcuJyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0c1tpXS5sZW5ndGggPiA2Mykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfdGxkKSB7XG4gICAgdmFyIHRsZCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggfHwgIS9eKFthLXpcXHUwMGExLVxcdWZmZmZdezIsfXx4blthLXowLTktXXsyLH0pJC9pLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gZGlzYWxsb3cgc3BhY2VzXG5cblxuICAgIGlmICgvW1xcc1xcdTIwMDItXFx1MjAwQlxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZcXHVEQjQwXFx1REMyMF0vLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHBhcnQsIF9pID0gMDsgX2kgPCBwYXJ0cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwYXJ0ID0gcGFydHNbX2ldO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dfdW5kZXJzY29yZXMpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL18vZywgJycpO1xuICAgIH1cblxuICAgIGlmICghL15bYS16XFx1MDBhMS1cXHVmZmZmMC05LV0rJC9pLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGRpc2FsbG93IGZ1bGwtd2lkdGggY2hhcnNcblxuXG4gICAgaWYgKC9bXFx1ZmYwMS1cXHVmZjVlXS8udGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJ0WzBdID09PSAnLScgfHwgcGFydFtwYXJ0Lmxlbmd0aCAtIDFdID09PSAnLScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXNGUUROXzEpO1xuXG52YXIgaXNJUF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJUDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlwdjRNYXliZSA9IC9eKFxcZHsxLDN9KVxcLihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KSQvO1xudmFyIGlwdjZCbG9jayA9IC9eWzAtOUEtRl17MSw0fSQvaTtcblxuZnVuY3Rpb24gaXNJUChzdHIpIHtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuXG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBpc0lQKHN0ciwgNCkgfHwgaXNJUChzdHIsIDYpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHNbM10gPD0gMjU1O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc2Jykge1xuICAgIHZhciBibG9ja3MgPSBzdHIuc3BsaXQoJzonKTtcbiAgICB2YXIgZm91bmRPbWlzc2lvbkJsb2NrID0gZmFsc2U7IC8vIG1hcmtlciB0byBpbmRpY2F0ZSA6OlxuICAgIC8vIEF0IGxlYXN0IHNvbWUgT1MgYWNjZXB0IHRoZSBsYXN0IDMyIGJpdHMgb2YgYW4gSVB2NiBhZGRyZXNzXG4gICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xuICAgIC8vIHRoYXQgJzo6ZmZmZjphLmIuYy5kJyBpcyB2YWxpZCBmb3IgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMsXG4gICAgLy8gYW5kICc6OmEuYi5jLmQnIGlzIGRlcHJlY2F0ZWQsIGJ1dCBhbHNvIHZhbGlkLlxuXG4gICAgdmFyIGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayA9IGlzSVAoYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXSwgNCk7XG4gICAgdmFyIGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MgPSBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPyA3IDogODtcblxuICAgIGlmIChibG9ja3MubGVuZ3RoID4gZXhwZWN0ZWROdW1iZXJPZkJsb2Nrcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxuXG5cbiAgICBpZiAoc3RyID09PSAnOjonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gMikgPT09ICc6OicpIHtcbiAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHRlc3QgZm9yIGEgOjogd2hpY2ggY2FuIG5vdCBiZSBhdCB0aGUgc3RyaW5nIHN0YXJ0L2VuZFxuICAgICAgLy8gc2luY2UgdGhvc2UgY2FzZXMgaGF2ZSBiZWVuIGhhbmRsZWQgYWJvdmVcbiAgICAgIGlmIChibG9ja3NbaV0gPT09ICcnICYmIGkgPiAwICYmIGkgPCBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtdWx0aXBsZSA6OiBpbiBhZGRyZXNzXG4gICAgICAgIH1cblxuICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgJiYgaSA9PT0gYmxvY2tzLmxlbmd0aCAtIDEpIDsgZWxzZSBpZiAoIWlwdjZCbG9jay50ZXN0KGJsb2Nrc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgIHJldHVybiBibG9ja3MubGVuZ3RoID49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3M7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNJUCA9IHVud3JhcEV4cG9ydHMoaXNJUF8xKTtcblxudmFyIGlzRW1haWxfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRW1haWw7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG52YXIgX2lzQnl0ZUxlbmd0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNCeXRlTGVuZ3RoXzEpO1xuXG52YXIgX2lzRlFETiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNGUUROXzEpO1xuXG52YXIgX2lzSVAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzSVBfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2VtYWlsX29wdGlvbnMgPSB7XG4gIGFsbG93X2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIHJlcXVpcmVfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgYWxsb3dfdXRmOF9sb2NhbF9wYXJ0OiB0cnVlLFxuICByZXF1aXJlX3RsZDogdHJ1ZVxufTtcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG52YXIgZGlzcGxheU5hbWUgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwsXFwuXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXFxzXSo8KC4rKT4kL2k7XG52YXIgZW1haWxVc2VyUGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XSskL2k7XG52YXIgZ21haWxVc2VyUGFydCA9IC9eW2EtelxcZF0rJC87XG52YXIgcXVvdGVkRW1haWxVc2VyID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXSkpKiQvaTtcbnZhciBlbWFpbFVzZXJVdGY4UGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSskL2k7XG52YXIgcXVvdGVkRW1haWxVc2VyVXRmOCA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3ZlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSokL2k7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmZ1bmN0aW9uIGlzRW1haWwoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZW1haWxfb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMucmVxdWlyZV9kaXNwbGF5X25hbWUgfHwgb3B0aW9ucy5hbGxvd19kaXNwbGF5X25hbWUpIHtcbiAgICB2YXIgZGlzcGxheV9lbWFpbCA9IHN0ci5tYXRjaChkaXNwbGF5TmFtZSk7XG5cbiAgICBpZiAoZGlzcGxheV9lbWFpbCkge1xuICAgICAgc3RyID0gZGlzcGxheV9lbWFpbFsxXTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9kaXNwbGF5X25hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJ0AnKTtcbiAgdmFyIGRvbWFpbiA9IHBhcnRzLnBvcCgpO1xuICB2YXIgdXNlciA9IHBhcnRzLmpvaW4oJ0AnKTtcbiAgdmFyIGxvd2VyX2RvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChvcHRpb25zLmRvbWFpbl9zcGVjaWZpY192YWxpZGF0aW9uICYmIChsb3dlcl9kb21haW4gPT09ICdnbWFpbC5jb20nIHx8IGxvd2VyX2RvbWFpbiA9PT0gJ2dvb2dsZW1haWwuY29tJykpIHtcbiAgICAvKlxuICAgICAgUHJldmlvdXNseSB3ZSByZW1vdmVkIGRvdHMgZm9yIGdtYWlsIGFkZHJlc3NlcyBiZWZvcmUgdmFsaWRhdGluZy5cbiAgICAgIFRoaXMgd2FzIHJlbW92ZWQgYmVjYXVzZSBpdCBhbGxvd3MgYG11bHRpcGxlLi5kb3RzQGdtYWlsLmNvbWBcbiAgICAgIHRvIGJlIHJlcG9ydGVkIGFzIHZhbGlkLCBidXQgaXQgaXMgbm90LlxuICAgICAgR21haWwgb25seSBub3JtYWxpemVzIHNpbmdsZSBkb3RzLCByZW1vdmluZyB0aGVtIGZyb20gaGVyZSBpcyBwb2ludGxlc3MsXG4gICAgICBzaG91bGQgYmUgZG9uZSBpbiBub3JtYWxpemVFbWFpbFxuICAgICovXG4gICAgdXNlciA9IHVzZXIudG9Mb3dlckNhc2UoKTsgLy8gUmVtb3Zpbmcgc3ViLWFkZHJlc3MgZnJvbSB1c2VybmFtZSBiZWZvcmUgZ21haWwgdmFsaWRhdGlvblxuXG4gICAgdmFyIHVzZXJuYW1lID0gdXNlci5zcGxpdCgnKycpWzBdOyAvLyBEb3RzIGFyZSBub3QgaW5jbHVkZWQgaW4gZ21haWwgbGVuZ3RoIHJlc3RyaWN0aW9uXG5cbiAgICBpZiAoISgwLCBfaXNCeXRlTGVuZ3RoLmRlZmF1bHQpKHVzZXJuYW1lLnJlcGxhY2UoJy4nLCAnJyksIHtcbiAgICAgIG1pbjogNixcbiAgICAgIG1heDogMzBcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBfdXNlcl9wYXJ0cyA9IHVzZXJuYW1lLnNwbGl0KCcuJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF91c2VyX3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWdtYWlsVXNlclBhcnQudGVzdChfdXNlcl9wYXJ0c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghKDAsIF9pc0J5dGVMZW5ndGguZGVmYXVsdCkodXNlciwge1xuICAgIG1heDogNjRcbiAgfSkgfHwgISgwLCBfaXNCeXRlTGVuZ3RoLmRlZmF1bHQpKGRvbWFpbiwge1xuICAgIG1heDogMjU0XG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzRlFETi5kZWZhdWx0KShkb21haW4sIHtcbiAgICByZXF1aXJlX3RsZDogb3B0aW9ucy5yZXF1aXJlX3RsZFxuICB9KSkge1xuICAgIGlmICghb3B0aW9ucy5hbGxvd19pcF9kb21haW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoISgwLCBfaXNJUC5kZWZhdWx0KShkb21haW4pKSB7XG4gICAgICBpZiAoIWRvbWFpbi5zdGFydHNXaXRoKCdbJykgfHwgIWRvbWFpbi5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vQnJhY2tldGRvbWFpbiA9IGRvbWFpbi5zdWJzdHIoMSwgZG9tYWluLmxlbmd0aCAtIDIpO1xuXG4gICAgICBpZiAobm9CcmFja2V0ZG9tYWluLmxlbmd0aCA9PT0gMCB8fCAhKDAsIF9pc0lQLmRlZmF1bHQpKG5vQnJhY2tldGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh1c2VyWzBdID09PSAnXCInKSB7XG4gICAgdXNlciA9IHVzZXIuc2xpY2UoMSwgdXNlci5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gb3B0aW9ucy5hbGxvd191dGY4X2xvY2FsX3BhcnQgPyBxdW90ZWRFbWFpbFVzZXJVdGY4LnRlc3QodXNlcikgOiBxdW90ZWRFbWFpbFVzZXIudGVzdCh1c2VyKTtcbiAgfVxuXG4gIHZhciBwYXR0ZXJuID0gb3B0aW9ucy5hbGxvd191dGY4X2xvY2FsX3BhcnQgPyBlbWFpbFVzZXJVdGY4UGFydCA6IGVtYWlsVXNlclBhcnQ7XG4gIHZhciB1c2VyX3BhcnRzID0gdXNlci5zcGxpdCgnLicpO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB1c2VyX3BhcnRzLmxlbmd0aDsgX2krKykge1xuICAgIGlmICghcGF0dGVybi50ZXN0KHVzZXJfcGFydHNbX2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzRW1haWwgPSB1bndyYXBFeHBvcnRzKGlzRW1haWxfMSk7XG5cbnZhciBpc0lTTzg2MDFfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPODYwMTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLy8gZnJvbSBodHRwOi8vZ29vLmdsLzBlakhIV1xudmFyIGlzbzg2MDEgPSAvXihbXFwrLV0/XFxkezR9KD8hXFxkezJ9XFxiKSkoKC0/KSgoMFsxLTldfDFbMC0yXSkoXFwzKFsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoWzAtNF1cXGR8NVswLTNdKSgtP1sxLTddKT98KDAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18MyhbMC01XVxcZHw2WzEtNl0pKSkoW1RcXHNdKCgoWzAxXVxcZHwyWzAtM10pKCg6PylbMC01XVxcZCk/fDI0Oj8wMCkoW1xcLixdXFxkKyg/ITopKT8pPyhcXDE3WzAtNV1cXGQoW1xcLixdXFxkKyk/KT8oW3paXXwoW1xcKy1dKShbMDFdXFxkfDJbMC0zXSk6PyhbMC01XVxcZCk/KT8pPyk/JC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIGlzVmFsaWREYXRlID0gZnVuY3Rpb24gaXNWYWxpZERhdGUoc3RyKSB7XG4gIC8vIHN0ciBtdXN0IGhhdmUgcGFzc2VkIHRoZSBJU084NjAxIGNoZWNrXG4gIC8vIHRoaXMgY2hlY2sgaXMgbWVhbnQgdG8gY2F0Y2ggaW52YWxpZCBkYXRlc1xuICAvLyBsaWtlIDIwMDktMDItMzFcbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG9yZGluYWwgZGF0ZXNcbiAgdmFyIG9yZGluYWxNYXRjaCA9IHN0ci5tYXRjaCgvXihcXGR7NH0pLT8oXFxkezN9KShbIFRdezF9XFwuKnwkKS8pO1xuXG4gIGlmIChvcmRpbmFsTWF0Y2gpIHtcbiAgICB2YXIgb1llYXIgPSBOdW1iZXIob3JkaW5hbE1hdGNoWzFdKTtcbiAgICB2YXIgb0RheSA9IE51bWJlcihvcmRpbmFsTWF0Y2hbMl0pOyAvLyBpZiBpcyBsZWFwIHllYXJcblxuICAgIGlmIChvWWVhciAlIDQgPT09IDAgJiYgb1llYXIgJSAxMDAgIT09IDApIHJldHVybiBvRGF5IDw9IDM2NjtcbiAgICByZXR1cm4gb0RheSA8PSAzNjU7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goLyhcXGR7NH0pLT8oXFxkezAsMn0pLT8oXFxkKikvKS5tYXAoTnVtYmVyKTtcbiAgdmFyIHllYXIgPSBtYXRjaFsxXTtcbiAgdmFyIG1vbnRoID0gbWF0Y2hbMl07XG4gIHZhciBkYXkgPSBtYXRjaFszXTtcbiAgdmFyIG1vbnRoU3RyaW5nID0gbW9udGggPyBcIjBcIi5jb25jYXQobW9udGgpLnNsaWNlKC0yKSA6IG1vbnRoO1xuICB2YXIgZGF5U3RyaW5nID0gZGF5ID8gXCIwXCIuY29uY2F0KGRheSkuc2xpY2UoLTIpIDogZGF5OyAvLyBjcmVhdGUgYSBkYXRlIG9iamVjdCBhbmQgY29tcGFyZVxuXG4gIHZhciBkID0gbmV3IERhdGUoXCJcIi5jb25jYXQoeWVhciwgXCItXCIpLmNvbmNhdChtb250aFN0cmluZyB8fCAnMDEnLCBcIi1cIikuY29uY2F0KGRheVN0cmluZyB8fCAnMDEnKSk7XG4gIGlmIChpc05hTihkLmdldFVUQ0Z1bGxZZWFyKCkpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKG1vbnRoICYmIGRheSkge1xuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZC5nZXRVVENNb250aCgpICsgMSA9PT0gbW9udGggJiYgZC5nZXRVVENEYXRlKCkgPT09IGRheTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNJU084NjAxKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgY2hlY2sgPSBpc284NjAxLnRlc3Qoc3RyKTtcbiAgaWYgKCFvcHRpb25zKSByZXR1cm4gY2hlY2s7XG4gIGlmIChjaGVjayAmJiBvcHRpb25zLnN0cmljdCkgcmV0dXJuIGlzVmFsaWREYXRlKHN0cik7XG4gIHJldHVybiBjaGVjaztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc0lTTzg2MDEgPSB1bndyYXBFeHBvcnRzKGlzSVNPODYwMV8xKTtcblxudmFyIGlzSlNPTl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNKU09OO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpc0pTT04oc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgdHJ5IHtcbiAgICB2YXIgb2JqID0gSlNPTi5wYXJzZShzdHIpO1xuICAgIHJldHVybiAhIW9iaiAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaWdub3JlICovXG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNKU09OID0gdW53cmFwRXhwb3J0cyhpc0pTT05fMSk7XG5cbnZhciBpc1VSTF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVUkw7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbnZhciBfaXNGUUROID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0ZRRE5fMSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNJUF8xKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobWVyZ2VfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X3VybF9vcHRpb25zID0ge1xuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmdHAnXSxcbiAgcmVxdWlyZV90bGQ6IHRydWUsXG4gIHJlcXVpcmVfcHJvdG9jb2w6IGZhbHNlLFxuICByZXF1aXJlX2hvc3Q6IHRydWUsXG4gIHJlcXVpcmVfdmFsaWRfcHJvdG9jb2w6IHRydWUsXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZSxcbiAgYWxsb3dfcHJvdG9jb2xfcmVsYXRpdmVfdXJsczogZmFsc2Vcbn07XG52YXIgd3JhcHBlZF9pcHY2ID0gL15cXFsoW15cXF1dKylcXF0oPzo6KFswLTldKykpPyQvO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gY2hlY2tIb3N0KGhvc3QsIG1hdGNoZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tpXTtcblxuICAgIGlmIChob3N0ID09PSBtYXRjaCB8fCBpc1JlZ0V4cChtYXRjaCkgJiYgbWF0Y2gudGVzdChob3N0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VSTCh1cmwsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkodXJsKTtcblxuICBpZiAoIXVybCB8fCB1cmwubGVuZ3RoID49IDIwODMgfHwgL1tcXHM8Pl0vLnRlc3QodXJsKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh1cmwuaW5kZXhPZignbWFpbHRvOicpID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF91cmxfb3B0aW9ucyk7XG4gIHZhciBwcm90b2NvbCwgYXV0aCwgaG9zdCwgaG9zdG5hbWUsIHBvcnQsIHBvcnRfc3RyLCBzcGxpdCwgaXB2NjtcbiAgc3BsaXQgPSB1cmwuc3BsaXQoJyMnKTtcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcbiAgc3BsaXQgPSB1cmwuc3BsaXQoJz8nKTtcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcbiAgc3BsaXQgPSB1cmwuc3BsaXQoJzovLycpO1xuXG4gIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgcHJvdG9jb2wgPSBzcGxpdC5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlX3ZhbGlkX3Byb3RvY29sICYmIG9wdGlvbnMucHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfcHJvdG9jb2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAodXJsLnN1YnN0cigwLCAyKSA9PT0gJy8vJykge1xuICAgIGlmICghb3B0aW9ucy5hbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3BsaXRbMF0gPSB1cmwuc3Vic3RyKDIpO1xuICB9XG5cbiAgdXJsID0gc3BsaXQuam9pbignOi8vJyk7XG5cbiAgaWYgKHVybCA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuXG4gIGlmICh1cmwgPT09ICcnICYmICFvcHRpb25zLnJlcXVpcmVfaG9zdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJ0AnKTtcblxuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIGlmIChvcHRpb25zLmRpc2FsbG93X2F1dGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhdXRoID0gc3BsaXQuc2hpZnQoKTtcblxuICAgIGlmIChhdXRoLmluZGV4T2YoJzonKSA+PSAwICYmIGF1dGguc3BsaXQoJzonKS5sZW5ndGggPiAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaG9zdG5hbWUgPSBzcGxpdC5qb2luKCdAJyk7XG4gIHBvcnRfc3RyID0gbnVsbDtcbiAgaXB2NiA9IG51bGw7XG4gIHZhciBpcHY2X21hdGNoID0gaG9zdG5hbWUubWF0Y2god3JhcHBlZF9pcHY2KTtcblxuICBpZiAoaXB2Nl9tYXRjaCkge1xuICAgIGhvc3QgPSAnJztcbiAgICBpcHY2ID0gaXB2Nl9tYXRjaFsxXTtcbiAgICBwb3J0X3N0ciA9IGlwdjZfbWF0Y2hbMl0gfHwgbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBzcGxpdCA9IGhvc3RuYW1lLnNwbGl0KCc6Jyk7XG4gICAgaG9zdCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgICBpZiAoc3BsaXQubGVuZ3RoKSB7XG4gICAgICBwb3J0X3N0ciA9IHNwbGl0LmpvaW4oJzonKTtcbiAgICB9XG4gIH1cblxuICBpZiAocG9ydF9zdHIgIT09IG51bGwpIHtcbiAgICBwb3J0ID0gcGFyc2VJbnQocG9ydF9zdHIsIDEwKTtcblxuICAgIGlmICghL15bMC05XSskLy50ZXN0KHBvcnRfc3RyKSB8fCBwb3J0IDw9IDAgfHwgcG9ydCA+IDY1NTM1KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEoMCwgX2lzSVAuZGVmYXVsdCkoaG9zdCkgJiYgISgwLCBfaXNGUUROLmRlZmF1bHQpKGhvc3QsIG9wdGlvbnMpICYmICghaXB2NiB8fCAhKDAsIF9pc0lQLmRlZmF1bHQpKGlwdjYsIDYpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhvc3QgPSBob3N0IHx8IGlwdjY7XG5cbiAgaWYgKG9wdGlvbnMuaG9zdF93aGl0ZWxpc3QgJiYgIWNoZWNrSG9zdChob3N0LCBvcHRpb25zLmhvc3Rfd2hpdGVsaXN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhvc3RfYmxhY2tsaXN0ICYmIGNoZWNrSG9zdChob3N0LCBvcHRpb25zLmhvc3RfYmxhY2tsaXN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzVVJMID0gdW53cmFwRXhwb3J0cyhpc1VSTF8xKTtcblxudmFyIGlzVVVJRF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVVUlEO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXVpZCA9IHtcbiAgMzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS0zWzAtOUEtRl17M30tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pLFxuICA0OiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTRbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksXG4gIDU6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tNVswLTlBLUZdezN9LVs4OUFCXVswLTlBLUZdezN9LVswLTlBLUZdezEyfSQvaSxcbiAgYWxsOiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaVxufTtcblxuZnVuY3Rpb24gaXNVVUlEKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FsbCc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBwYXR0ZXJuID0gdXVpZFt2ZXJzaW9uXTtcbiAgcmV0dXJuIHBhdHRlcm4gJiYgcGF0dGVybi50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNVVUlEID0gdW53cmFwRXhwb3J0cyhpc1VVSURfMSk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxudmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gX2ZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIF9yb290ID0gcm9vdDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sJDEgPSBfcm9vdC5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbn1cblxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnJDEgJiYgc3ltVG9TdHJpbmdUYWckMSBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gX2dldFJhd1RhZyh2YWx1ZSlcbiAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbnZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoX2NvcmVKc0RhdGEgJiYgX2NvcmVKc0RhdGEua2V5cyAmJiBfY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbnZhciBfaXNNYXNrZWQgPSBpc01hc2tlZDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZyQxLmNhbGwoaGFzT3duUHJvcGVydHkkMSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkgfHwgX2lzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fMSh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KF90b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IF9nZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBfYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gX2dldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgX2RlZmluZVByb3BlcnR5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxudmFyIF9iYXNlQXNzaWduVmFsdWUgPSBiYXNlQXNzaWduVmFsdWU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG52YXIgZXFfMSA9IGVxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eSQyLmNhbGwob2JqZWN0LCBrZXkpICYmIGVxXzEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBfYXNzaWduVmFsdWUgPSBhc3NpZ25WYWx1ZTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxudmFyIF9jb3B5T2JqZWN0ID0gY29weU9iamVjdDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGlkZW50aXR5XzEgPSBpZGVudGl0eTtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG52YXIgX2FwcGx5ID0gYXBwbHk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIF9hcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG52YXIgX292ZXJSZXN0ID0gb3ZlclJlc3Q7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG52YXIgY29uc3RhbnRfMSA9IGNvbnN0YW50O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhX2RlZmluZVByb3BlcnR5ID8gaWRlbnRpdHlfMSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50XzEoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxudmFyIF9iYXNlU2V0VG9TdHJpbmcgPSBiYXNlU2V0VG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9zaG9ydE91dCA9IHNob3J0T3V0O1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBfc2hvcnRPdXQoX2Jhc2VTZXRUb1N0cmluZyk7XG5cbnZhciBfc2V0VG9TdHJpbmcgPSBzZXRUb1N0cmluZztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIF9zZXRUb1N0cmluZyhfb3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5XzEpLCBmdW5jICsgJycpO1xufVxuXG52YXIgX2Jhc2VSZXN0ID0gYmFzZVJlc3Q7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxudmFyIGlzTGVuZ3RoXzEgPSBpc0xlbmd0aDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGhfMSh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uXzEodmFsdWUpO1xufVxuXG52YXIgaXNBcnJheUxpa2VfMSA9IGlzQXJyYXlMaWtlO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSJDEgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG52YXIgX2lzSW5kZXggPSBpc0luZGV4O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0XzEob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2VfMShvYmplY3QpICYmIF9pc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXFfMShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2lzSXRlcmF0ZWVDYWxsID0gaXNJdGVyYXRlZUNhbGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIF9iYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBfaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxudmFyIF9jcmVhdGVBc3NpZ25lciA9IGNyZWF0ZUFzc2lnbmVyO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG8kNDtcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG52YXIgX2lzUHJvdG90eXBlID0gaXNQcm90b3R5cGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRpbWVzID0gYmFzZVRpbWVzO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxudmFyIGlzT2JqZWN0TGlrZV8xID0gaXNPYmplY3RMaWtlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG52YXIgX2Jhc2VJc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kNS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQ1LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gX2Jhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkMy5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxudmFyIGlzQXJndW1lbnRzXzEgPSBpc0FyZ3VtZW50cztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBpc0FycmF5XzEgPSBpc0FycmF5O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBzdHViRmFsc2VfMSA9IHN0dWJGYWxzZTtcblxudmFyIGlzQnVmZmVyXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiAnb2JqZWN0JyA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IF9yb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2VfMTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbn0pO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyQxID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWckMV0gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZyQxXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aF8xKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tfYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG52YXIgX2Jhc2VJc1R5cGVkQXJyYXkgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbnZhciBfYmFzZVVuYXJ5ID0gYmFzZVVuYXJ5O1xuXG52YXIgX25vZGVVdGlsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBfZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbn0pO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBfbm9kZVV0aWwgJiYgX25vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBfYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogX2Jhc2VJc1R5cGVkQXJyYXk7XG5cbnZhciBpc1R5cGVkQXJyYXlfMSA9IGlzVHlwZWRBcnJheTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDYgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ0ID0gb2JqZWN0UHJvdG8kNi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXlfMSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50c18xKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXJfMSh2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5XzEodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBfYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQ0LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgX2lzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2FycmF5TGlrZUtleXMgPSBhcnJheUxpa2VLZXlzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxudmFyIF9vdmVyQXJnID0gb3ZlckFyZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBfb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxudmFyIF9uYXRpdmVLZXlzID0gbmF0aXZlS2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDcgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ1ID0gb2JqZWN0UHJvdG8kNy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIV9pc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIF9uYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkNS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlS2V5cyA9IGJhc2VLZXlzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZV8xKG9iamVjdCkgPyBfYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogX2Jhc2VLZXlzKG9iamVjdCk7XG59XG5cbnZhciBrZXlzXzEgPSBrZXlzO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kOCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDYgPSBvYmplY3RQcm90byQ4Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25JblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmMgPSAzO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBhc3NpZ24gPSBfY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgaWYgKF9pc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlXzEoc291cmNlKSkge1xuICAgIF9jb3B5T2JqZWN0KHNvdXJjZSwga2V5c18xKHNvdXJjZSksIG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkNi5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgX2Fzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfVxuICB9XG59KTtcblxudmFyIGFzc2lnbl8xID0gYXNzaWduO1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYXJyYXlQdXNoID0gYXJyYXlQdXNoO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gX1N5bWJvbCA/IF9TeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlfMSh2YWx1ZSkgfHwgaXNBcmd1bWVudHNfMSh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxudmFyIF9pc0ZsYXR0ZW5hYmxlID0gaXNGbGF0dGVuYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IF9pc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlRmxhdHRlbiA9IGJhc2VGbGF0dGVuO1xuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9jb3B5QXJyYXkgPSBjb3B5QXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAqIGFuZC9vciB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheSA9IFsxXTtcbiAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsxXVxuICovXG5mdW5jdGlvbiBjb25jYXQoKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICBpbmRleCA9IGxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIF9hcnJheVB1c2goaXNBcnJheV8xKGFycmF5KSA/IF9jb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgX2Jhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbn1cblxudmFyIGNvbmNhdF8xID0gY29uY2F0O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbnZhciBfYmFzZVByb3BlcnR5T2YgPSBiYXNlUHJvcGVydHlPZjtcblxuLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xudmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICdcXHhkZic6ICdzcycsXG4gIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG52YXIgZGVidXJyTGV0dGVyID0gX2Jhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbnZhciBfZGVidXJyTGV0dGVyID0gZGVidXJyTGV0dGVyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2FycmF5TWFwID0gYXJyYXlNYXA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxudmFyIGlzU3ltYm9sXzEgPSBpc1N5bWJvbDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBfU3ltYm9sID8gX1N5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gX2FycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRvU3RyaW5nID0gYmFzZVRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IF9iYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG52YXIgdG9TdHJpbmdfMSA9IHRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4vKipcbiAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICogLy8gPT4gJ2RlamEgdnUnXG4gKi9cbmZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmdfMShzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIF9kZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxudmFyIGRlYnVycl8xID0gZGVidXJyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYXJyYXlFYWNoID0gYXJyYXlFYWNoO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxudmFyIF9jcmVhdGVCYXNlRm9yID0gY3JlYXRlQmFzZUZvcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gX2NyZWF0ZUJhc2VGb3IoKTtcblxudmFyIF9iYXNlRm9yID0gYmFzZUZvcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBfYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzXzEpO1xufVxuXG52YXIgX2Jhc2VGb3JPd24gPSBiYXNlRm9yT3duO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2VfMShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gX2NyZWF0ZUJhc2VFYWNoKF9iYXNlRm9yT3duKTtcblxudmFyIF9iYXNlRWFjaCA9IGJhc2VFYWNoO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5XzE7XG59XG5cbnZhciBfY2FzdEZ1bmN0aW9uID0gY2FzdEZ1bmN0aW9uO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheV8xKGNvbGxlY3Rpb24pID8gX2FycmF5RWFjaCA6IF9iYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgX2Nhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG52YXIgZm9yRWFjaF8xID0gZm9yRWFjaDtcblxudmFyIGVhY2ggPSBmb3JFYWNoXzE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbnZhciBfaXNLZXkgPSBpc0tleTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IF9nZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBfbmF0aXZlQ3JlYXRlID8gX25hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhcjtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kOSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDcgPSBvYmplY3RQcm90byQ5Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoX25hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDcuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kYSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDggPSBvYmplY3RQcm90byRhLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIF9uYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkkOC5jYWxsKGRhdGEsIGtleSk7XG59XG5cbnZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCQxID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAoX25hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBfaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2hhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBfaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IF9oYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gX2hhc2hTZXQ7XG5cbnZhciBfSGFzaCA9IEhhc2g7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXFfMShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBfYXNzb2NJbmRleE9mID0gYXNzb2NJbmRleE9mO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgX2xpc3RDYWNoZURlbGV0ZSA9IGxpc3RDYWNoZURlbGV0ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbnZhciBfbGlzdENhY2hlR2V0ID0gbGlzdENhY2hlR2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gX2Fzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbnZhciBfbGlzdENhY2hlSGFzID0gbGlzdENhY2hlSGFzO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX2xpc3RDYWNoZVNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBfbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9saXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IF9saXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IF9saXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IF9saXN0Q2FjaGVTZXQ7XG5cbnZhciBfTGlzdENhY2hlID0gTGlzdENhY2hlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gX2dldE5hdGl2ZShfcm9vdCwgJ01hcCcpO1xuXG52YXIgX01hcCA9IE1hcDtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBfSGFzaCxcbiAgICAnbWFwJzogbmV3IChfTWFwIHx8IF9MaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgX0hhc2hcbiAgfTtcbn1cblxudmFyIF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG52YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIF9pc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxudmFyIF9nZXRNYXBEYXRhID0gZ2V0TWFwRGF0YTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gX2dldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX21hcENhY2hlRGVsZXRlID0gbWFwQ2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVIYXMgPSBtYXBDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gX2dldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9tYXBDYWNoZVNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gX21hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX21hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IF9tYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gX21hcENhY2hlU2V0O1xuXG52YXIgX01hcENhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IF9NYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gX01hcENhY2hlO1xuXG52YXIgbWVtb2l6ZV8xID0gbWVtb2l6ZTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZV8xKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWVtb2l6ZUNhcHBlZCA9IG1lbW9pemVDYXBwZWQ7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gX21lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbnZhciBfc3RyaW5nVG9QYXRoID0gc3RyaW5nVG9QYXRoO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gX2lzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IF9zdHJpbmdUb1BhdGgodG9TdHJpbmdfMSh2YWx1ZSkpO1xufVxuXG52YXIgX2Nhc3RQYXRoID0gY2FzdFBhdGg7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDEgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkkMSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG52YXIgX3RvS2V5ID0gdG9LZXk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFtfdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxudmFyIF9iYXNlR2V0ID0gYmFzZUdldDtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9iYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxudmFyIGdldF8xID0gZ2V0O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA+IG90aGVyO1xufVxuXG52YXIgX2Jhc2VHdCA9IGJhc2VHdDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdF8xKG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG52YXIgdG9OdW1iZXJfMSA9IHRvTnVtYmVyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgdmFsdWUgPSB0b051bWJlcl8xKHZhbHVlKTtcbiAgICAgIG90aGVyID0gdG9OdW1iZXJfMShvdGhlcik7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICB9O1xufVxuXG52YXIgX2NyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24gPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy45LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBzZWUgXy5sdFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmd0KDMsIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZ3QoMywgMyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZ3QoMSwgMyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgZ3QgPSBfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihfYmFzZUd0KTtcblxudmFyIGd0XzEgPSBndDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuOS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gKiBAc2VlIF8ubHRlXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZ3RlKDMsIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZ3RlKDMsIDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZ3RlKDEsIDMpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGd0ZSA9IF9jcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG59KTtcblxudmFyIGd0ZV8xID0gZ3RlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIF9iYXNlRmluZEluZGV4ID0gYmFzZUZpbmRJbmRleDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxudmFyIF9iYXNlSXNOYU4gPSBiYXNlSXNOYU47XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIF9zdHJpY3RJbmRleE9mID0gc3RyaWN0SW5kZXhPZjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gX3N0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBfYmFzZUZpbmRJbmRleChhcnJheSwgX2Jhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxudmFyIF9iYXNlSW5kZXhPZiA9IGJhc2VJbmRleE9mO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnJDEgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheV8xKHZhbHVlKSAmJiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyQxKTtcbn1cblxudmFyIGlzU3RyaW5nXzEgPSBpc1N0cmluZztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkkMiA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXJfMSh2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkkMiB8fCB2YWx1ZSA9PT0gLUlORklOSVRZJDIpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxudmFyIHRvRmluaXRlXzEgPSB0b0Zpbml0ZTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZV8xKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG52YXIgdG9JbnRlZ2VyXzEgPSB0b0ludGVnZXI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxudmFyIF9iYXNlVmFsdWVzID0gYmFzZVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogX2Jhc2VWYWx1ZXMob2JqZWN0LCBrZXlzXzEob2JqZWN0KSk7XG59XG5cbnZhciB2YWx1ZXNfMSA9IHZhbHVlcztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCQxID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2VfMShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXNfMShjb2xsZWN0aW9uKTtcbiAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyXzEoZnJvbUluZGV4KSA6IDA7XG5cbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heCQxKGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGlzU3RyaW5nXzEoY29sbGVjdGlvbilcbiAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgIDogKCEhbGVuZ3RoICYmIF9iYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbn1cblxudmFyIGluY2x1ZGVzXzEgPSBpbmNsdWRlcztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWckMSA9ICdbb2JqZWN0IEJvb2xlYW5dJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWckMSk7XG59XG5cbnZhciBpc0Jvb2xlYW5fMSA9IGlzQm9vbGVhbjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gX2dldE5hdGl2ZShfcm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbnZhciBfRGF0YVZpZXcgPSBEYXRhVmlldztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBfZ2V0TmF0aXZlKF9yb290LCAnUHJvbWlzZScpO1xuXG52YXIgX1Byb21pc2UgPSBQcm9taXNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gX2dldE5hdGl2ZShfcm9vdCwgJ1NldCcpO1xuXG52YXIgX1NldCA9IFNldDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBfZ2V0TmF0aXZlKF9yb290LCAnV2Vha01hcCcpO1xuXG52YXIgX1dlYWtNYXAgPSBXZWFrTWFwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnJDEgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWckMSA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnJDEgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnJDEgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyQxID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX0RhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gX3RvU291cmNlKF9NYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gX3RvU291cmNlKF9Qcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gX3RvU291cmNlKF9TZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gX3RvU291cmNlKF9XZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IF9iYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKF9EYXRhVmlldyAmJiBnZXRUYWcobmV3IF9EYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZyQxKSB8fFxuICAgIChfTWFwICYmIGdldFRhZyhuZXcgX01hcCkgIT0gbWFwVGFnJDEpIHx8XG4gICAgKF9Qcm9taXNlICYmIGdldFRhZyhfUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKF9TZXQgJiYgZ2V0VGFnKG5ldyBfU2V0KSAhPSBzZXRUYWckMSkgfHxcbiAgICAoX1dlYWtNYXAgJiYgZ2V0VGFnKG5ldyBfV2Vha01hcCkgIT0gd2Vha01hcFRhZyQxKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBfYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnJDEgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyBfdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZyQxO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWckMTtcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZyQxO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZyQxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG52YXIgX2dldFRhZyA9IGdldFRhZztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyQyID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnJDIgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ5ID0gb2JqZWN0UHJvdG8kYi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlXzEodmFsdWUpICYmXG4gICAgICAoaXNBcnJheV8xKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyXzEodmFsdWUpIHx8IGlzVHlwZWRBcnJheV8xKHZhbHVlKSB8fCBpc0FyZ3VtZW50c18xKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gX2dldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnJDIgfHwgdGFnID09IHNldFRhZyQyKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChfaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFfYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkOS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgaXNFbXB0eV8xID0gaXNFbXB0eTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IF9MaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfc3RhY2tDbGVhciA9IHN0YWNrQ2xlYXI7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9zdGFja0RlbGV0ZSA9IHN0YWNrRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbnZhciBfc3RhY2tHZXQgPSBzdGFja0dldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxudmFyIF9zdGFja0hhcyA9IHN0YWNrSGFzO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIV9NYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgX01hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9zdGFja1NldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBfTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBfc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gX3N0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IF9zdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBfc3RhY2tTZXQ7XG5cbnZhciBfU3RhY2sgPSBTdGFjaztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEJDIgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQkMik7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX3NldENhY2hlQWRkID0gc2V0Q2FjaGVBZGQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxudmFyIF9zZXRDYWNoZUhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBfTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IF9zZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBfc2V0Q2FjaGVIYXM7XG5cbnZhciBfU2V0Q2FjaGUgPSBTZXRDYWNoZTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9hcnJheVNvbWUgPSBhcnJheVNvbWU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG52YXIgX2NhY2hlSGFzID0gY2FjaGVIYXM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBfU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFfYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghX2NhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZXF1YWxBcnJheXMgPSBlcXVhbEFycmF5cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IF9yb290LlVpbnQ4QXJyYXk7XG5cbnZhciBfVWludDhBcnJheSA9IFVpbnQ4QXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwVG9BcnJheSA9IG1hcFRvQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc2V0VG9BcnJheSA9IHNldFRvQXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMSA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnJDIgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyQxID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnJDEgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyQzID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnJDEgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWckMSA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQzID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDIgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWckMSA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWckMSA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWckMiA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvJDEgPSBfU3ltYm9sID8gX1N5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvJDEgPyBzeW1ib2xQcm90byQxLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZyQyOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnJDE6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgX1VpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IF9VaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWckMjpcbiAgICBjYXNlIGRhdGVUYWckMTpcbiAgICBjYXNlIG51bWJlclRhZyQxOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXFfMSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZyQxOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnJDE6XG4gICAgY2FzZSBzdHJpbmdUYWckMjpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZyQzOlxuICAgICAgdmFyIGNvbnZlcnQgPSBfbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnJDM6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDE7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gX3NldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRyQxO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBfZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZyQxOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2VxdWFsQnlUYWcgPSBlcXVhbEJ5VGFnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheV8xKG9iamVjdCkgPyByZXN1bHQgOiBfYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbnZhciBfYmFzZUdldEFsbEtleXMgPSBiYXNlR2V0QWxsS2V5cztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2FycmF5RmlsdGVyID0gYXJyYXlGaWx0ZXI7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbnZhciBzdHViQXJyYXlfMSA9IHN0dWJBcnJheTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSQxID0gb2JqZWN0UHJvdG8kYy5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheV8xIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIF9hcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSQxLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbnZhciBfZ2V0U3ltYm9scyA9IGdldFN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIF9iYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNfMSwgX2dldFN5bWJvbHMpO1xufVxuXG52YXIgX2dldEFsbEtleXMgPSBnZXRBbGxLZXlzO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQyID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGQgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRhID0gb2JqZWN0UHJvdG8kZC5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQyLFxuICAgICAgb2JqUHJvcHMgPSBfZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBfZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eSRhLmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2VxdWFsT2JqZWN0cyA9IGVxdWFsT2JqZWN0cztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnJDIgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyQxID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWckMiA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JGIgPSBvYmplY3RQcm90byRlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXlfMShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5XzEob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyQxIDogX2dldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyQxIDogX2dldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWckMiA/IG9iamVjdFRhZyQyIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyQyID8gb2JqZWN0VGFnJDIgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyQyLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnJDIsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXJfMShvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcl8xKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBfU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5XzEob2JqZWN0KSlcbiAgICAgID8gX2VxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IF9lcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDMpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5JGIuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSRiLmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBfU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgX1N0YWNrKTtcbiAgcmV0dXJuIF9lcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbnZhciBfYmFzZUlzRXF1YWxEZWVwID0gYmFzZUlzRXF1YWxEZWVwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlXzEodmFsdWUpICYmICFpc09iamVjdExpa2VfMShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIF9iYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG52YXIgX2Jhc2VJc0VxdWFsID0gYmFzZUlzRXF1YWw7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBfYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxudmFyIGlzRXF1YWxfMSA9IGlzRXF1YWw7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0Zpbml0ZSA9IF9yb290LmlzRmluaXRlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGaW5pdGUoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0Zpbml0ZSgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG59XG5cbnZhciBfaXNGaW5pdGUgPSBpc0Zpbml0ZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzSW50ZWdlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzSW50ZWdlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyXzEodmFsdWUpO1xufVxuXG52YXIgaXNJbnRlZ2VyXzEgPSBpc0ludGVnZXI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudW1iZXJUYWckMiA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWckMik7XG59XG5cbnZhciBpc051bWJlcl8xID0gaXNOdW1iZXI7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hTihOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBpc05hTih1bmRlZmluZWQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmFOJDEodmFsdWUpIHtcbiAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgcmV0dXJuIGlzTnVtYmVyXzEodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbn1cblxudmFyIF9pc05hTiA9IGlzTmFOJDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05pbChudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmlsKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05pbChOYU4pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG59XG5cbnZhciBpc05pbF8xID0gaXNOaWw7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVsbChudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVsbCh2b2lkIDApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cblxudmFyIGlzTnVsbF8xID0gaXNOdWxsO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbnZhciBpc1VuZGVmaW5lZF8xID0gaXNVbmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG59XG5cbnZhciBfYmFzZUx0ID0gYmFzZUx0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy45LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBzZWUgXy5ndFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmx0KDEsIDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8ubHQoMywgMyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8ubHQoMywgMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgbHQgPSBfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihfYmFzZUx0KTtcblxudmFyIGx0XzEgPSBsdDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuOS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gKiBAc2VlIF8uZ3RlXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubHRlKDEsIDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8ubHRlKDMsIDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8ubHRlKDMsIDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGx0ZSA9IF9jcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG59KTtcblxudmFyIGx0ZV8xID0gbHRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0XzEob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IF9jYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IF90b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3RfMShvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoX2lzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBfYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgX2Jhc2VTZXQgPSBiYXNlU2V0O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBfYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIF9iYXNlU2V0KHJlc3VsdCwgX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlUGlja0J5ID0gYmFzZVBpY2tCeTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbnZhciBfYmFzZUhhc0luID0gYmFzZUhhc0luO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IF90b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoXzEobGVuZ3RoKSAmJiBfaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheV8xKG9iamVjdCkgfHwgaXNBcmd1bWVudHNfMShvYmplY3QpKTtcbn1cblxudmFyIF9oYXNQYXRoID0gaGFzUGF0aDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIF9oYXNQYXRoKG9iamVjdCwgcGF0aCwgX2Jhc2VIYXNJbik7XG59XG5cbnZhciBoYXNJbl8xID0gaGFzSW47XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gX2Jhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW5fMShvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxudmFyIF9iYXNlUGljayA9IGJhc2VQaWNrO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBfYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbnZhciBmbGF0dGVuXzEgPSBmbGF0dGVuO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIF9zZXRUb1N0cmluZyhfb3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuXzEpLCBmdW5jICsgJycpO1xufVxuXG52YXIgX2ZsYXRSZXN0ID0gZmxhdFJlc3Q7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBfZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IF9iYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG52YXIgcGlja18xID0gcGljaztcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBfYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbn1cblxudmFyIHNldF8xID0gc2V0O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG52YXIgX2Jhc2VQcm9wZXJ0eSA9IGJhc2VQcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG52YXIgYXNjaWlTaXplID0gX2Jhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbnZhciBfYXNjaWlTaXplID0gYXNjaWlTaXplO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSQxID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UkMSA9IHJzQ29tYm9NYXJrc1JhbmdlJDEgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSQxICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBfaGFzVW5pY29kZSA9IGhhc1VuaWNvZGU7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlJDEgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UkMiA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMiA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlJDIgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlJDIgPSByc0NvbWJvTWFya3NSYW5nZSQyICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDIgKyByc0NvbWJvU3ltYm9sc1JhbmdlJDIsXG4gICAgcnNWYXJSYW5nZSQxID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJyxcbiAgICByc0NvbWJvJDEgPSAnWycgKyByc0NvbWJvUmFuZ2UkMiArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvJDEgKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSQxICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKJDEgPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSQxICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKJDEgKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvJDEgKyAnPycsIHJzQ29tYm8kMSwgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICArK3Jlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX3VuaWNvZGVTaXplID0gdW5pY29kZVNpemU7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gIHJldHVybiBfaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyBfdW5pY29kZVNpemUoc3RyaW5nKVxuICAgIDogX2FzY2lpU2l6ZShzdHJpbmcpO1xufVxuXG52YXIgX3N0cmluZ1NpemUgPSBzdHJpbmdTaXplO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnJDQgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWckNCA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZV8xKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEoY29sbGVjdGlvbikgPyBfc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBfZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyQ0IHx8IHRhZyA9PSBzZXRUYWckNCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gIH1cbiAgcmV0dXJuIF9iYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG59XG5cbnZhciBzaXplXzEgPSBzaXplO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVNsaWNlID0gYmFzZVNsaWNlO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBfYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbn1cblxudmFyIF9jYXN0U2xpY2UgPSBjYXN0U2xpY2U7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciByZWdleHBUYWckMiA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnJDI7XG59XG5cbnZhciBfYmFzZUlzUmVnRXhwID0gYmFzZUlzUmVnRXhwO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1JlZ0V4cCA9IF9ub2RlVXRpbCAmJiBfbm9kZVV0aWwuaXNSZWdFeHA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gX2Jhc2VVbmFyeShub2RlSXNSZWdFeHApIDogX2Jhc2VJc1JlZ0V4cDtcblxudmFyIGlzUmVnRXhwXzEgPSBpc1JlZ0V4cDtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxudmFyIF9hc2NpaVRvQXJyYXkgPSBhc2NpaVRvQXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlJDIgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UkMyA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlJDMgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlJDMgPSByc0NvbWJvTWFya3NSYW5nZSQzICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDMgKyByc0NvbWJvU3ltYm9sc1JhbmdlJDMsXG4gICAgcnNWYXJSYW5nZSQyID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCQxID0gJ1snICsgcnNBc3RyYWxSYW5nZSQyICsgJ10nLFxuICAgIHJzQ29tYm8kMiA9ICdbJyArIHJzQ29tYm9SYW5nZSQzICsgJ10nLFxuICAgIHJzRml0eiQxID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciQxID0gJyg/OicgKyByc0NvbWJvJDIgKyAnfCcgKyByc0ZpdHokMSArICcpJyxcbiAgICByc05vbkFzdHJhbCQxID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMiArICddJyxcbiAgICByc1JlZ2lvbmFsJDEgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciQxID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0okMiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCQxID0gcnNNb2RpZmllciQxICsgJz8nLFxuICAgIHJzT3B0VmFyJDEgPSAnWycgKyByc1ZhclJhbmdlJDIgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiQxID0gJyg/OicgKyByc1pXSiQyICsgJyg/OicgKyBbcnNOb25Bc3RyYWwkMSwgcnNSZWdpb25hbCQxLCByc1N1cnJQYWlyJDFdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyJDEgKyByZU9wdE1vZCQxICsgJykqJyxcbiAgICByc1NlcSQxID0gcnNPcHRWYXIkMSArIHJlT3B0TW9kJDEgKyByc09wdEpvaW4kMSxcbiAgICByc1N5bWJvbCQxID0gJyg/OicgKyBbcnNOb25Bc3RyYWwkMSArIHJzQ29tYm8kMiArICc/JywgcnNDb21ibyQyLCByc1JlZ2lvbmFsJDEsIHJzU3VyclBhaXIkMSwgcnNBc3RyYWwkMV0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSQxID0gUmVnRXhwKHJzRml0eiQxICsgJyg/PScgKyByc0ZpdHokMSArICcpfCcgKyByc1N5bWJvbCQxICsgcnNTZXEkMSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSQxKSB8fCBbXTtcbn1cblxudmFyIF91bmljb2RlVG9BcnJheSA9IHVuaWNvZGVUb0FycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gX2hhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gX3VuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IF9hc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxudmFyIF9zdHJpbmdUb0FycmF5ID0gc3RyaW5nVG9BcnJheTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NTtcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICovXG5mdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBfaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgaWYgKCFsaW1pdCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZ18xKHN0cmluZyk7XG4gIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHBfMShzZXBhcmF0b3IpKVxuICAgICAgKSkge1xuICAgIHNlcGFyYXRvciA9IF9iYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICBpZiAoIXNlcGFyYXRvciAmJiBfaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gX2Nhc3RTbGljZShfc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG59XG5cbnZhciBzcGxpdF8xID0gc3BsaXQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAqL1xuZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgc3R1YlRydWVfMSA9IHN0dWJUcnVlO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9uYXRpdmVLZXlzSW4gPSBuYXRpdmVLZXlzSW47XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRmID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYyA9IG9iamVjdFByb3RvJGYuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgcmV0dXJuIF9uYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IF9pc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eSRjLmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZUtleXNJbiA9IGJhc2VLZXlzSW47XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZV8xKG9iamVjdCkgPyBfYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogX2Jhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxudmFyIGtleXNJbl8xID0ga2V5c0luO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IF9jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgX2NvcHlPYmplY3Qoc291cmNlLCBrZXlzSW5fMShzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbnZhciBhc3NpZ25JbldpdGhfMSA9IGFzc2lnbkluV2l0aDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gX292ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG52YXIgX2dldFByb3RvdHlwZSA9IGdldFByb3RvdHlwZTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyQzID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8kMiA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byRnID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyQyID0gZnVuY1Byb3RvJDIudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JGQgPSBvYmplY3RQcm90byRnLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZyQyLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZV8xKHZhbHVlKSB8fCBfYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnJDMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gX2dldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkkZC5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmckMi5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbnZhciBpc1BsYWluT2JqZWN0XzEgPSBpc1BsYWluT2JqZWN0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWckMiA9ICdbb2JqZWN0IEVycm9yXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Vycm9yKEVycm9yKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2VfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IF9iYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyQyIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3RfMSh2YWx1ZSkpO1xufVxuXG52YXIgaXNFcnJvcl8xID0gaXNFcnJvcjtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IF9iYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9hcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3JfMShlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gIH1cbn0pO1xuXG52YXIgYXR0ZW1wdF8xID0gYXR0ZW1wdDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGggPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRlID0gb2JqZWN0UHJvdG8kaC5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcV8xKG9ialZhbHVlLCBvYmplY3RQcm90byRoW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eSRlLmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbnZhciBfY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiA9IGN1c3RvbURlZmF1bHRzQXNzaWduSW47XG5cbi8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICdcXFxcJzogJ1xcXFwnLFxuICBcIidcIjogXCInXCIsXG4gICdcXG4nOiAnbicsXG4gICdcXHInOiAncicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbn1cblxudmFyIF9lc2NhcGVTdHJpbmdDaGFyID0gZXNjYXBlU3RyaW5nQ2hhcjtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbnZhciBfcmVJbnRlcnBvbGF0ZSA9IHJlSW50ZXJwb2xhdGU7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIGVzY2FwZUh0bWxDaGFyID0gX2Jhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxudmFyIF9lc2NhcGVIdG1sQ2hhciA9IGVzY2FwZUh0bWxDaGFyO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nXzEoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgX2VzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG52YXIgX2VzY2FwZSA9IGVzY2FwZTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nO1xuXG52YXIgX3JlRXNjYXBlID0gcmVFc2NhcGU7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2c7XG5cbnZhciBfcmVFdmFsdWF0ZSA9IHJlRXZhbHVhdGU7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiBfcmVFc2NhcGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXZhbHVhdGUnOiBfcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IF9yZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogX2VzY2FwZSB9XG4gIH1cbn07XG5cbnZhciB0ZW1wbGF0ZVNldHRpbmdzXzEgPSB0ZW1wbGF0ZVNldHRpbmdzO1xuXG4vKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xudmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGkgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRmID0gb2JqZWN0UHJvdG8kaS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICpcbiAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSd0ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAqXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAqXG4gKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICpcbiAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICpcbiAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gKlxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gKiBjb21waWxlZChkYXRhKTtcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gKlxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gKiBjb21waWxlZC5zb3VyY2U7XG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gKiAvLyAgIHJldHVybiBfX3A7XG4gKiAvLyB9XG4gKlxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gKiAgIHZhciBKU1QgPSB7XFxcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICogICB9O1xcXG4gKiAnKTtcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3NfMS5pbXBvcnRzLl8udGVtcGxhdGVTZXR0aW5ncyB8fCB0ZW1wbGF0ZVNldHRpbmdzXzE7XG5cbiAgaWYgKGd1YXJkICYmIF9pc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmdfMShzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoXzEoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBfY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGhfMSh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBfY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXNfMShpbXBvcnRzKSxcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBfYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSBfcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgLCAnZycpO1xuXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAvLyB3aXRoIGxvb2t1cCAoaW4gY2FzZSBvZiBlLmcuIHByb3RvdHlwZSBwb2xsdXRpb24pLCBhbmQgc3RyaXAgbmV3bGluZXMgaWYgYW55LlxuICAvLyBBIG5ld2xpbmUgd291bGRuJ3QgYmUgYSB2YWxpZCBzb3VyY2VVUkwgYW55d2F5LCBhbmQgaXQnZCBlbmFibGUgY29kZSBpbmplY3Rpb24uXG4gIHZhciBzb3VyY2VVUkwgPSBoYXNPd25Qcm9wZXJ0eSRmLmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIF9lc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAvLyBMaWtlIHdpdGggc291cmNlVVJMLCB3ZSB0YWtlIGNhcmUgdG8gbm90IGNoZWNrIHRoZSBvcHRpb24ncyBwcm90b3R5cGUsXG4gIC8vIGFzIHRoaXMgY29uZmlndXJhdGlvbiBpcyBhIGNvZGUgaW5qZWN0aW9uIHZlY3Rvci5cbiAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkkZi5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdF8xKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gIH0pO1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICBpZiAoaXNFcnJvcl8xKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHRlbXBsYXRlXzEgPSB0ZW1wbGF0ZTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gKlxuICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAqIC8vID0+ICdmb29iYXInXG4gKlxuICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICovXG5mdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ18xKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xufVxuXG52YXIgdG9Mb3dlcl8xID0gdG9Mb3dlcjtcblxuLyoqXG4gKiBAbmFtZSB0b0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ2xvbmUgdGhlIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUobmV3IERhdGUoMjAxNCwgMSwgMTEsIDExLCAzMCwgMzApKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCB0aGUgdGltZXN0YW1wIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUoMTM5MjA5ODQzMDAwMClcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKi9cbmZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGFyZ1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCk7IC8vIENsb25lIHRoZSBkYXRlXG5cbiAgaWYgKGFyZ3VtZW50IGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgYXJndW1lbnQgPT09ICdvYmplY3QnICYmIGFyZ1N0ciA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgLy8gUHJldmVudCB0aGUgZGF0ZSB0byBsb3NlIHRoZSBtaWxsaXNlY29uZHMgd2hlbiBwYXNzZWQgdG8gbmV3IERhdGUoKSBpbiBJRTEwXG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50LmdldFRpbWUoKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnbnVtYmVyJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgYXJnU3RyID09PSAnW29iamVjdCBTdHJpbmddJykgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiU3RhcnRpbmcgd2l0aCB2Mi4wLjAtYmV0YS4xIGRhdGUtZm5zIGRvZXNuJ3QgYWNjZXB0IHN0cmluZ3MgYXMgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdC5pby9manVsZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b0ludGVnZXIkMShkaXJ0eU51bWJlcikge1xuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcik7XG59XG5cbi8qKlxuICogQG5hbWUgYWRkTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbGxpc2Vjb25kcyBhZGRlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNzUwIG1pbGxpc2Vjb25kcyB0byAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxuICogdmFyIHJlc3VsdCA9IGFkZE1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjMwLjc1MFxuICovXG5cbmZ1bmN0aW9uIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGRpcnR5QW1vdW50KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIHRpbWVzdGFtcCA9IHRvRGF0ZShkaXJ0eURhdGUpLmdldFRpbWUoKTtcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlciQxKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIGFtb3VudCk7XG59XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDA7XG4vKipcbiAqIEdvb2dsZSBDaHJvbWUgYXMgb2YgNjcuMC4zMzk2Ljg3IGludHJvZHVjZWQgdGltZXpvbmVzIHdpdGggb2Zmc2V0IHRoYXQgaW5jbHVkZXMgc2Vjb25kcy5cbiAqIFRoZXkgdXN1YWxseSBhcHBlYXIgZm9yIGRhdGVzIHRoYXQgZGVub3RlIHRpbWUgYmVmb3JlIHRoZSB0aW1lem9uZXMgd2VyZSBpbnRyb2R1Y2VkXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxuICogYW5kIEdNVCswMTowMDowMCBhZnRlciB0aGF0IGRhdGUpXG4gKlxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcbiAqIHdoaWNoIHdvdWxkIGxlYWQgdG8gaW5jb3JyZWN0IGNhbGN1bGF0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkaXJ0eURhdGUpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZShkaXJ0eURhdGUuZ2V0VGltZSgpKTtcbiAgdmFyIGJhc2VUaW1lem9uZU9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgZGF0ZS5zZXRTZWNvbmRzKDAsIDApO1xuICB2YXIgbWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWUoKSAlIE1JTExJU0VDT05EU19JTl9NSU5VVEU7XG4gIHJldHVybiBiYXNlVGltZXpvbmVPZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFICsgbWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXQ7XG59XG5cbi8qKlxuICogQG5hbWUgaXNWYWxpZFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB2YWxpZD9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgZmFsc2UgaWYgYXJndW1lbnQgaXMgSW52YWxpZCBEYXRlIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAqIEFyZ3VtZW50IGlzIGNvbnZlcnRlZCB0byBEYXRlIHVzaW5nIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBJbnZhbGlkIERhdGUgaXMgYSBEYXRlLCB3aG9zZSB0aW1lIHZhbHVlIGlzIE5hTi5cbiAqXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gTm93IGBpc1ZhbGlkYCBkb2Vzbid0IHRocm93IGFuIGV4Y2VwdGlvblxuICogICBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKiAgIEluc3RlYWQsIGFyZ3VtZW50IGlzIGNvbnZlcnRlZCBiZWZvcmVoYW5kIHVzaW5nIGB0b0RhdGVgLlxuICpcbiAqICAgRXhhbXBsZXM6XG4gKlxuICogICB8IGBpc1ZhbGlkYCBhcmd1bWVudCAgICAgICAgfCBCZWZvcmUgdjIuMC4wIHwgdjIuMC4wIG9ud2FyZCB8XG4gKiAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXxcbiAqICAgfCBgbmV3IERhdGUoKWAgICAgICAgICAgICAgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZSgnMjAxNi0wMS0wMScpYCAgfCBgdHJ1ZWAgICAgICAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKCcnKWAgICAgICAgICAgICB8IGBmYWxzZWAgICAgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoMTQ4ODM3MDgzNTA4MSlgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZShOYU4pYCAgICAgICAgICAgfCBgZmFsc2VgICAgICAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYCcyMDE2LTAxLTAxJ2AgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgJydgICAgICAgICAgICAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGBmYWxzZWAgICAgICAgfFxuICogICB8IGAxNDg4MzcwODM1MDgxYCAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYE5hTmAgICAgICAgICAgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqXG4gKiAgIFdlIGludHJvZHVjZSB0aGlzIGNoYW5nZSB0byBtYWtlICpkYXRlLWZucyogY29uc2lzdGVudCB3aXRoIEVDTUFTY3JpcHQgYmVoYXZpb3JcbiAqICAgdGhhdCB0cnkgdG8gY29lcmNlIGFyZ3VtZW50cyB0byB0aGUgZXhwZWN0ZWQgdHlwZVxuICogICAod2hpY2ggaXMgYWxzbyB0aGUgY2FzZSB3aXRoIG90aGVyICpkYXRlLWZucyogZnVuY3Rpb25zKS5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHZhbGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWxpZCBkYXRlOlxuICogdmFyIHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoMjAxNCwgMSwgMzEpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsdWUsIGNvbnZlcnRhYmxlIGludG8gYSBkYXRlOlxuICogdmFyIHJlc3VsdCA9IGlzVmFsaWQoMTM5MzgwNDgwMDAwMClcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIGludmFsaWQgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkKGRpcnR5RGF0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgcmV0dXJuICFpc05hTihkYXRlKTtcbn1cblxudmFyIGZvcm1hdERpc3RhbmNlTG9jYWxlID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiAnbGVzcyB0aGFuIGEgc2Vjb25kJyxcbiAgICBvdGhlcjogJ2xlc3MgdGhhbiB7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgaGFsZkFNaW51dGU6ICdoYWxmIGEgbWludXRlJyxcbiAgbGVzc1RoYW5YTWludXRlczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIG1pbnV0ZScsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSBtaW51dGUnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIGFib3V0WEhvdXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSBob3VyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeEhvdXJzOiB7XG4gICAgb25lOiAnMSBob3VyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRheScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gZGF5cydcbiAgfSxcbiAgYWJvdXRYTW9udGhzOiB7XG4gICAgb25lOiAnYWJvdXQgMSBtb250aCcsXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0gbW9udGhzJ1xuICB9LFxuICB4TW9udGhzOiB7XG4gICAgb25lOiAnMSBtb250aCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gbW9udGhzJ1xuICB9LFxuICBhYm91dFhZZWFyczoge1xuICAgIG9uZTogJ2Fib3V0IDEgeWVhcicsXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG4gIHhZZWFyczoge1xuICAgIG9uZTogJzEgeWVhcicsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0geWVhcnMnXG4gIH0sXG4gIG92ZXJYWWVhcnM6IHtcbiAgICBvbmU6ICdvdmVyIDEgeWVhcicsXG4gICAgb3RoZXI6ICdvdmVyIHt7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgYWxtb3N0WFllYXJzOiB7XG4gICAgb25lOiAnYWxtb3N0IDEgeWVhcicsXG4gICAgb3RoZXI6ICdhbG1vc3Qge3tjb3VudH19IHllYXJzJ1xuICB9XG59O1xuZnVuY3Rpb24gZm9ybWF0RGlzdGFuY2UodG9rZW4sIGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmICh0eXBlb2YgZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXS5vbmU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFkZFN1ZmZpeCkge1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAnIGFnbyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtYXRMb25nRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICB2YXIgZm9ybWF0ID0gYXJncy5mb3JtYXRzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHNbYXJncy5kZWZhdWx0V2lkdGhdO1xuICAgIHJldHVybiBmb3JtYXQ7XG4gIH07XG59XG5cbnZhciBkYXRlRm9ybWF0cyA9IHtcbiAgZnVsbDogJ0VFRUUsIE1NTU0gZG8sIHknLFxuICBsb25nOiAnTU1NTSBkbywgeScsXG4gIG1lZGl1bTogJ01NTSBkLCB5JyxcbiAgc2hvcnQ6ICdNTS9kZC95eXl5J1xufTtcbnZhciB0aW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogJ2g6bW06c3MgYSB6enp6JyxcbiAgbG9uZzogJ2g6bW06c3MgYSB6JyxcbiAgbWVkaXVtOiAnaDptbTpzcyBhJyxcbiAgc2hvcnQ6ICdoOm1tIGEnXG59O1xudmFyIGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIGxvbmc6IFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVwiLFxuICBtZWRpdW06ICd7e2RhdGV9fSwge3t0aW1lfX0nLFxuICBzaG9ydDogJ3t7ZGF0ZX19LCB7e3RpbWV9fSdcbn07XG52YXIgZm9ybWF0TG9uZyA9IHtcbiAgZGF0ZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICB0aW1lOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogdGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIGRhdGVUaW1lOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZVRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pXG59O1xuXG52YXIgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gIGxhc3RXZWVrOiBcIidsYXN0JyBlZWVlICdhdCcgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ3llc3RlcmRheSBhdCcgcFwiLFxuICB0b2RheTogXCIndG9kYXkgYXQnIHBcIixcbiAgdG9tb3Jyb3c6IFwiJ3RvbW9ycm93IGF0JyBwXCIsXG4gIG5leHRXZWVrOiBcImVlZWUgJ2F0JyBwXCIsXG4gIG90aGVyOiAnUCdcbn07XG5mdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZSh0b2tlbiwgX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIGZvcm1hdFJlbGF0aXZlTG9jYWxlW3Rva2VuXTtcbn1cblxuZnVuY3Rpb24gYnVpbGRMb2NhbGl6ZUZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eUluZGV4LCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCA/IFN0cmluZyhvcHRpb25zLmNvbnRleHQpIDogJ3N0YW5kYWxvbmUnO1xuICAgIHZhciB2YWx1ZXNBcnJheTtcblxuICAgIGlmIChjb250ZXh0ID09PSAnZm9ybWF0dGluZycgJiYgYXJncy5mb3JtYXR0aW5nVmFsdWVzKSB7XG4gICAgICB2YXIgZGVmYXVsdFdpZHRoID0gYXJncy5kZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIHx8IGFyZ3MuZGVmYXVsdFdpZHRoO1xuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGRlZmF1bHRXaWR0aDtcbiAgICAgIHZhbHVlc0FycmF5ID0gYXJncy5mb3JtYXR0aW5nVmFsdWVzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHRpbmdWYWx1ZXNbZGVmYXVsdFdpZHRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRXaWR0aDtcblxuICAgICAgdmFyIF93aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcblxuICAgICAgdmFsdWVzQXJyYXkgPSBhcmdzLnZhbHVlc1tfd2lkdGhdIHx8IGFyZ3MudmFsdWVzW19kZWZhdWx0V2lkdGhdO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGFyZ3MuYXJndW1lbnRDYWxsYmFjayA/IGFyZ3MuYXJndW1lbnRDYWxsYmFjayhkaXJ0eUluZGV4KSA6IGRpcnR5SW5kZXg7XG4gICAgcmV0dXJuIHZhbHVlc0FycmF5W2luZGV4XTtcbiAgfTtcbn1cblxudmFyIGVyYVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0InLCAnQSddLFxuICBhYmJyZXZpYXRlZDogWydCQycsICdBRCddLFxuICB3aWRlOiBbJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknXVxufTtcbnZhciBxdWFydGVyVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnMScsICcyJywgJzMnLCAnNCddLFxuICBhYmJyZXZpYXRlZDogWydRMScsICdRMicsICdRMycsICdRNCddLFxuICB3aWRlOiBbJzFzdCBxdWFydGVyJywgJzJuZCBxdWFydGVyJywgJzNyZCBxdWFydGVyJywgJzR0aCBxdWFydGVyJ10gLy8gTm90ZTogaW4gRW5nbGlzaCwgdGhlIG5hbWVzIG9mIGRheXMgb2YgdGhlIHdlZWsgYW5kIG1vbnRocyBhcmUgY2FwaXRhbGl6ZWQuXG4gIC8vIElmIHlvdSBhcmUgbWFraW5nIGEgbmV3IGxvY2FsZSBiYXNlZCBvbiB0aGlzIG9uZSwgY2hlY2sgaWYgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgdGhlIGxhbmd1YWdlIHlvdSdyZSB3b3JraW5nIG9uLlxuICAvLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbiAgLy8gZS5nLiBpbiBTcGFuaXNoIGxhbmd1YWdlIHRoZSB3ZWVrZGF5cyBhbmQgbW9udGhzIHNob3VsZCBiZSBpbiB0aGUgbG93ZXJjYXNlLlxuXG59O1xudmFyIG1vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnSicsICdGJywgJ00nLCAnQScsICdNJywgJ0onLCAnSicsICdBJywgJ1MnLCAnTycsICdOJywgJ0QnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgd2lkZTogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ11cbn07XG52YXIgZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddLFxuICBzaG9ydDogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICBhYmJyZXZpYXRlZDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgd2lkZTogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddXG59O1xudmFyIGRheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06ICdhJyxcbiAgICBwbTogJ3AnLFxuICAgIG1pZG5pZ2h0OiAnbWknLFxuICAgIG5vb246ICduJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogJ0FNJyxcbiAgICBwbTogJ1BNJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ2EubS4nLFxuICAgIHBtOiAncC5tLicsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9XG59O1xudmFyIGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAnYScsXG4gICAgcG06ICdwJyxcbiAgICBtaWRuaWdodDogJ21pJyxcbiAgICBub29uOiAnbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICdBTScsXG4gICAgcG06ICdQTScsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICdhLm0uJyxcbiAgICBwbTogJ3AubS4nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfVxufTtcblxuZnVuY3Rpb24gb3JkaW5hbE51bWJlcihkaXJ0eU51bWJlciwgX2RpcnR5T3B0aW9ucykge1xuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTsgLy8gSWYgb3JkaW5hbCBudW1iZXJzIGRlcGVuZCBvbiBjb250ZXh0LCBmb3IgZXhhbXBsZSxcbiAgLy8gaWYgdGhleSBhcmUgZGlmZmVyZW50IGZvciBkaWZmZXJlbnQgZ3JhbW1hdGljYWwgZ2VuZGVycyxcbiAgLy8gdXNlIGBvcHRpb25zLnVuaXRgOlxuICAvL1xuICAvLyAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9XG4gIC8vICAgdmFyIHVuaXQgPSBTdHJpbmcob3B0aW9ucy51bml0KVxuICAvL1xuICAvLyB3aGVyZSBgdW5pdGAgY2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXRlJywgJ2RheU9mWWVhcicsXG4gIC8vICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJ1xuXG4gIHZhciByZW0xMDAgPSBudW1iZXIgJSAxMDA7XG5cbiAgaWYgKHJlbTEwMCA+IDIwIHx8IHJlbTEwMCA8IDEwKSB7XG4gICAgc3dpdGNoIChyZW0xMDAgJSAxMCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3N0JztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ25kJztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3JkJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtYmVyICsgJ3RoJztcbn1cblxudmFyIGxvY2FsaXplID0ge1xuICBvcmRpbmFsTnVtYmVyOiBvcmRpbmFsTnVtYmVyLFxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBxdWFydGVyVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGFyZ3VtZW50Q2FsbGJhY2s6IGZ1bmN0aW9uIChxdWFydGVyKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHF1YXJ0ZXIpIC0gMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IG1vbnRoVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXk6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xuICB9KVxufTtcblxuZnVuY3Rpb24gYnVpbGRNYXRjaFBhdHRlcm5GbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoZGlydHlTdHJpbmcpO1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLm1hdGNoUGF0dGVybik7XG5cbiAgICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZFN0cmluZyA9IG1hdGNoUmVzdWx0WzBdO1xuICAgIHZhciBwYXJzZVJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLnBhcnNlUGF0dGVybik7XG5cbiAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2socGFyc2VSZXN1bHRbMF0pIDogcGFyc2VSZXN1bHRbMF07XG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaGVkU3RyaW5nLmxlbmd0aClcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZE1hdGNoRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5U3RyaW5nLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGRpcnR5U3RyaW5nKTtcbiAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIHZhciBtYXRjaFBhdHRlcm4gPSB3aWR0aCAmJiBhcmdzLm1hdGNoUGF0dGVybnNbd2lkdGhdIHx8IGFyZ3MubWF0Y2hQYXR0ZXJuc1thcmdzLmRlZmF1bHRNYXRjaFdpZHRoXTtcbiAgICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gobWF0Y2hQYXR0ZXJuKTtcblxuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgdmFyIHBhcnNlUGF0dGVybnMgPSB3aWR0aCAmJiBhcmdzLnBhcnNlUGF0dGVybnNbd2lkdGhdIHx8IGFyZ3MucGFyc2VQYXR0ZXJuc1thcmdzLmRlZmF1bHRQYXJzZVdpZHRoXTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBhcnNlUGF0dGVybnMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlUGF0dGVybnMuZmluZEluZGV4KGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyaW5nKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGZpbmRLZXkocGFyc2VQYXR0ZXJucywgZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChzdHJpbmcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaGVkU3RyaW5nLmxlbmd0aClcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkgJiYgcHJlZGljYXRlKG9iamVjdFtrZXldKSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbn1cblxudmFyIG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXihcXGQrKSh0aHxzdHxuZHxyZCk/L2k7XG52YXIgcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9cXGQrL2k7XG52YXIgbWF0Y2hFcmFQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXihifGEpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihiXFwuP1xccz9jXFwuP3xiXFwuP1xccz9jXFwuP1xccz9lXFwuP3xhXFwuP1xccz9kXFwuP3xjXFwuP1xccz9lXFwuPykvaSxcbiAgd2lkZTogL14oYmVmb3JlIGNocmlzdHxiZWZvcmUgY29tbW9uIGVyYXxhbm5vIGRvbWluaXxjb21tb24gZXJhKS9pXG59O1xudmFyIHBhcnNlRXJhUGF0dGVybnMgPSB7XG4gIGFueTogWy9eYi9pLCAvXihhfGMpL2ldXG59O1xudmFyIG1hdGNoUXVhcnRlclBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eWzEyMzRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXnFbMTIzNF0vaSxcbiAgd2lkZTogL15bMTIzNF0odGh8c3R8bmR8cmQpPyBxdWFydGVyL2lcbn07XG52YXIgcGFyc2VRdWFydGVyUGF0dGVybnMgPSB7XG4gIGFueTogWy8xL2ksIC8yL2ksIC8zL2ksIC80L2ldXG59O1xudmFyIG1hdGNoTW9udGhQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXltqZm1hc29uZF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGphbnxmZWJ8bWFyfGFwcnxtYXl8anVufGp1bHxhdWd8c2VwfG9jdHxub3Z8ZGVjKS9pLFxuICB3aWRlOiAvXihqYW51YXJ5fGZlYnJ1YXJ5fG1hcmNofGFwcmlsfG1heXxqdW5lfGp1bHl8YXVndXN0fHNlcHRlbWJlcnxvY3RvYmVyfG5vdmVtYmVyfGRlY2VtYmVyKS9pXG59O1xudmFyIHBhcnNlTW9udGhQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15qL2ksIC9eZi9pLCAvXm0vaSwgL15hL2ksIC9ebS9pLCAvXmovaSwgL15qL2ksIC9eYS9pLCAvXnMvaSwgL15vL2ksIC9ebi9pLCAvXmQvaV0sXG4gIGFueTogWy9eamEvaSwgL15mL2ksIC9ebWFyL2ksIC9eYXAvaSwgL15tYXkvaSwgL15qdW4vaSwgL15qdWwvaSwgL15hdS9pLCAvXnMvaSwgL15vL2ksIC9ebi9pLCAvXmQvaV1cbn07XG52YXIgbWF0Y2hEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXltzbXR3Zl0vaSxcbiAgc2hvcnQ6IC9eKHN1fG1vfHR1fHdlfHRofGZyfHNhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oc3VufG1vbnx0dWV8d2VkfHRodXxmcml8c2F0KS9pLFxuICB3aWRlOiAvXihzdW5kYXl8bW9uZGF5fHR1ZXNkYXl8d2VkbmVzZGF5fHRodXJzZGF5fGZyaWRheXxzYXR1cmRheSkvaVxufTtcbnZhciBwYXJzZURheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXnMvaSwgL15tL2ksIC9edC9pLCAvXncvaSwgL150L2ksIC9eZi9pLCAvXnMvaV0sXG4gIGFueTogWy9ec3UvaSwgL15tL2ksIC9edHUvaSwgL153L2ksIC9edGgvaSwgL15mL2ksIC9ec2EvaV1cbn07XG52YXIgbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXihhfHB8bWl8bnwoaW4gdGhlfGF0KSAobW9ybmluZ3xhZnRlcm5vb258ZXZlbmluZ3xuaWdodCkpL2ksXG4gIGFueTogL14oW2FwXVxcLj9cXHM/bVxcLj98bWlkbmlnaHR8bm9vbnwoaW4gdGhlfGF0KSAobW9ybmluZ3xhZnRlcm5vb258ZXZlbmluZ3xuaWdodCkpL2lcbn07XG52YXIgcGFyc2VEYXlQZXJpb2RQYXR0ZXJucyA9IHtcbiAgYW55OiB7XG4gICAgYW06IC9eYS9pLFxuICAgIHBtOiAvXnAvaSxcbiAgICBtaWRuaWdodDogL15taS9pLFxuICAgIG5vb246IC9ebm8vaSxcbiAgICBtb3JuaW5nOiAvbW9ybmluZy9pLFxuICAgIGFmdGVybm9vbjogL2FmdGVybm9vbi9pLFxuICAgIGV2ZW5pbmc6IC9ldmVuaW5nL2ksXG4gICAgbmlnaHQ6IC9uaWdodC9pXG4gIH1cbn07XG52YXIgbWF0Y2ggPSB7XG4gIG9yZGluYWxOdW1iZXI6IGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oe1xuICAgIG1hdGNoUGF0dGVybjogbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICBwYXJzZVBhdHRlcm46IHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH0pLFxuICBlcmE6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBxdWFydGVyOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaE1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZU1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBkYXk6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBkYXlQZXJpb2Q6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ2FueScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSlcbn07XG5cbi8qKlxuICogQHR5cGUge0xvY2FsZX1cbiAqIEBjYXRlZ29yeSBMb2NhbGVzXG4gKiBAc3VtbWFyeSBFbmdsaXNoIGxvY2FsZSAoVW5pdGVkIFN0YXRlcykuXG4gKiBAbGFuZ3VhZ2UgRW5nbGlzaFxuICogQGlzby02MzktMiBlbmdcbiAqIEBhdXRob3IgU2FzaGEgS29zcyBbQGtvc3Nub2NvcnBde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9rb3Nzbm9jb3JwfVxuICogQGF1dGhvciBMZXNoYSBLb3NzIFtAbGVzaGFrb3NzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbGVzaGFrb3NzfVxuICovXG5cbnZhciBsb2NhbGUgPSB7XG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMFxuICAgIC8qIFN1bmRheSAqL1xuICAgICxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDFcbiAgfVxufTtcblxuLyoqXG4gKiBAbmFtZSBzdWJNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBzdWJ0cmFjdGVkXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbGxpc2Vjb25kcyBzdWJ0cmFjdGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDc1MCBtaWxsaXNlY29uZHMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxuICogdmFyIHJlc3VsdCA9IHN1Yk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjI5LjI1MFxuICovXG5cbmZ1bmN0aW9uIHN1Yk1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGRpcnR5QW1vdW50KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlciQxKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIC1hbW91bnQpO1xufVxuXG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVyb3MobnVtYmVyLCB0YXJnZXRMZW5ndGgpIHtcbiAgdmFyIHNpZ24gPSBudW1iZXIgPCAwID8gJy0nIDogJyc7XG4gIHZhciBvdXRwdXQgPSBNYXRoLmFicyhudW1iZXIpLnRvU3RyaW5nKCk7XG5cbiAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICBvdXRwdXQgPSAnMCcgKyBvdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gc2lnbiArIG91dHB1dDtcbn1cblxuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSB7XG4gIC8vIFllYXJcbiAgeTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgLy8gRnJvbSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTMxL3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF90b2tlbnNcbiAgICAvLyB8IFllYXIgICAgIHwgICAgIHkgfCB5eSB8ICAgeXl5IHwgIHl5eXkgfCB5eXl5eSB8XG4gICAgLy8gfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxuICAgIC8vIHwgQUQgMSAgICAgfCAgICAgMSB8IDAxIHwgICAwMDEgfCAgMDAwMSB8IDAwMDAxIHxcbiAgICAvLyB8IEFEIDEyICAgIHwgICAgMTIgfCAxMiB8ICAgMDEyIHwgIDAwMTIgfCAwMDAxMiB8XG4gICAgLy8gfCBBRCAxMjMgICB8ICAgMTIzIHwgMjMgfCAgIDEyMyB8ICAwMTIzIHwgMDAxMjMgfFxuICAgIC8vIHwgQUQgMTIzNCAgfCAgMTIzNCB8IDM0IHwgIDEyMzQgfCAgMTIzNCB8IDAxMjM0IHxcbiAgICAvLyB8IEFEIDEyMzQ1IHwgMTIzNDUgfCA0NSB8IDEyMzQ1IHwgMTIzNDUgfCAxMjM0NSB8XG4gICAgdmFyIHNpZ25lZFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7IC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG5cbiAgICB2YXIgeWVhciA9IHNpZ25lZFllYXIgPiAwID8gc2lnbmVkWWVhciA6IDEgLSBzaWduZWRZZWFyO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModG9rZW4gPT09ICd5eScgPyB5ZWFyICUgMTAwIDogeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTW9udGhcbiAgTTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgIHJldHVybiB0b2tlbiA9PT0gJ00nID8gU3RyaW5nKG1vbnRoICsgMSkgOiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDRGF0ZSgpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBBTSBvciBQTVxuICBhOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF0ZS5nZXRVVENIb3VycygpIC8gMTIgPj0gMSA/ICdwbScgOiAnYW0nO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnYSc6XG4gICAgICBjYXNlICdhYSc6XG4gICAgICBjYXNlICdhYWEnOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIGNhc2UgJ2FhYWFhJzpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZVswXTtcblxuICAgICAgY2FzZSAnYWFhYSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlID09PSAnYW0nID8gJ2EubS4nIDogJ3AubS4nO1xuICAgIH1cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSG91ciBbMC0yM11cbiAgSDogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbnV0ZVxuICBtOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDTWludXRlcygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBTZWNvbmRcbiAgczogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ1NlY29uZHMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBudW1iZXJPZkRpZ2l0cyA9IHRva2VuLmxlbmd0aDtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB2YXIgZnJhY3Rpb25hbFNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAqIE1hdGgucG93KDEwLCBudW1iZXJPZkRpZ2l0cyAtIDMpKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGZyYWN0aW9uYWxTZWNvbmRzLCB0b2tlbi5sZW5ndGgpO1xuICB9XG59O1xuXG52YXIgTUlMTElTRUNPTkRTX0lOX0RBWSA9IDg2NDAwMDAwOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gZ2V0VVRDRGF5T2ZZZWFyKGRpcnR5RGF0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZlllYXJUaW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIGRpZmZlcmVuY2UgPSB0aW1lc3RhbXAgLSBzdGFydE9mWWVhclRpbWVzdGFtcDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIE1JTExJU0VDT05EU19JTl9EQVkpICsgMTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzdGFydE9mVVRDSVNPV2VlayhkaXJ0eURhdGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gZ2V0VVRDSVNPV2Vla1llYXIoZGlydHlEYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRVVENGdWxsWWVhcih5ZWFyICsgMSwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyKTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIpO1xuXG4gIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxO1xuICB9IGVsc2UgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGlydHlEYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgeWVhciA9IGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5KTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fV0VFSyA9IDYwNDgwMDAwMDsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIGdldFVUQ0lTT1dlZWsoZGlydHlEYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGlmZiA9IHN0YXJ0T2ZVVENJU09XZWVrKGRhdGUpLmdldFRpbWUoKSAtIHN0YXJ0T2ZVVENJU09XZWVrWWVhcihkYXRlKS5nZXRUaW1lKCk7IC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG4gIC8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudFxuICAvLyAoZS5nLiBpdCdzIGRpZmZlcmVudCBpbiB0aGUgd2VlayBvZiB0aGUgZGF5bGlnaHQgc2F2aW5nIHRpbWUgY2xvY2sgc2hpZnQpXG5cbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLKSArIDE7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc3RhcnRPZlVUQ1dlZWsoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlciQxKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlciQxKG9wdGlvbnMud2Vla1N0YXJ0c09uKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gZ2V0VVRDV2Vla1llYXIoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlciQxKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA6IHRvSW50ZWdlciQxKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAxIGFuZCA3IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoIShmaXJzdFdlZWtDb250YWluc0RhdGUgPj0gMSAmJiBmaXJzdFdlZWtDb250YWluc0RhdGUgPD0gNykpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZmlyc3RXZWVrQ29udGFpbnNEYXRlIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgZmlyc3RXZWVrT2ZOZXh0WWVhciA9IG5ldyBEYXRlKDApO1xuICBmaXJzdFdlZWtPZk5leHRZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIgKyAxLCAwLCBmaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICBmaXJzdFdlZWtPZk5leHRZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZk5leHRZZWFyID0gc3RhcnRPZlVUQ1dlZWsoZmlyc3RXZWVrT2ZOZXh0WWVhciwgZGlydHlPcHRpb25zKTtcbiAgdmFyIGZpcnN0V2Vla09mVGhpc1llYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZmlyc3RXZWVrT2ZUaGlzWWVhci5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBmaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZlRoaXNZZWFyID0gc3RhcnRPZlVUQ1dlZWsoZmlyc3RXZWVrT2ZUaGlzWWVhciwgZGlydHlPcHRpb25zKTtcblxuICBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHllYXIgLSAxO1xuICB9XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc3RhcnRPZlVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIkMShsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIkMShvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciB5ZWFyID0gZ2V0VVRDV2Vla1llYXIoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZmlyc3RXZWVrID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vlay5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBmaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICBmaXJzdFdlZWsuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ1dlZWsoZmlyc3RXZWVrLCBkaXJ0eU9wdGlvbnMpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9XRUVLJDEgPSA2MDQ4MDAwMDA7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBnZXRVVENXZWVrKGRpcnR5RGF0ZSwgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRpZmYgPSBzdGFydE9mVVRDV2VlayhkYXRlLCBvcHRpb25zKS5nZXRUaW1lKCkgLSBzdGFydE9mVVRDV2Vla1llYXIoZGF0ZSwgb3B0aW9ucykuZ2V0VGltZSgpOyAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuICAvLyBiZWNhdXNlIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnRcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBNSUxMSVNFQ09ORFNfSU5fV0VFSyQxKSArIDE7XG59XG5cbnZhciBkYXlQZXJpb2RFbnVtID0ge1xuICBhbTogJ2FtJyxcbiAgcG06ICdwbScsXG4gIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICBub29uOiAnbm9vbicsXG4gIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICBuaWdodDogJ25pZ2h0J1xuICAvKlxuICAgKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCBNaWxsaXNlY29uZHMgaW4gZGF5ICAgICAgICAgICAgfFxuICAgKiB8ICBiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICB8ICBCICB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICB8XG4gICAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcbiAgICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBlICB8IExvY2FsIGRheSBvZiB3ZWVrICAgICAgICAgICAgICB8ICBFICB8IERheSBvZiB3ZWVrICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcbiAgICogfCAgZyogfCBNb2RpZmllZCBKdWxpYW4gZGF5ICAgICAgICAgICAgfCAgRyAgfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcbiAgICogfCAgaiogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfCAgSiogfCBMb2NhbGl6ZWQgaG91ciB3L28gZGF5IHBlcmlvZCAgfFxuICAgKiB8ICBrICB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICB8ICBLICB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcbiAgICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBuICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBOICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8gIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgcCEgfCBMb25nIGxvY2FsaXplZCB0aW1lICAgICAgICAgICAgfCAgUCEgfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgfFxuICAgKiB8ICBxICB8IFN0YW5kLWFsb25lIHF1YXJ0ZXIgICAgICAgICAgICB8ICBRICB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcbiAgICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICAgKiB8ICB0ISB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICB8ICBUISB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICB8XG4gICAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgdiogfCBUaW1lem9uZSAoZ2VuZXJpYyBub24tbG9jYXQuKSAgfCAgViogfCBUaW1lem9uZSAobG9jYXRpb24pICAgICAgICAgICAgfFxuICAgKiB8ICB3ICB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICB8ICBXKiB8IFdlZWsgb2YgbW9udGggICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcbiAgICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgfFxuICAgKiB8ICB6ICB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSB8ICBaKiB8IFRpbWV6b25lIChhbGlhc2VzKSAgICAgICAgICAgICB8XG4gICAqXG4gICAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAgICpcbiAgICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XG4gICAqIC0gYG9gIG1vZGlmaWVzIHRoZSBwcmV2aW91cyB0b2tlbiB0byB0dXJuIGl0IGludG8gYW4gb3JkaW5hbCAoc2VlIGBmb3JtYXRgIGRvY3MpXG4gICAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcbiAgICogICBpLmUuIDcgZm9yIFN1bmRheSwgMSBmb3IgTW9uZGF5LCBldGMuXG4gICAqIC0gYElgIGlzIElTTyB3ZWVrIG9mIHllYXIsIGFzIG9wcG9zZWQgdG8gYHdgIHdoaWNoIGlzIGxvY2FsIHdlZWsgb2YgeWVhci5cbiAgICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXG4gICAqICAgYFJgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgSWAgYW5kIGBpYFxuICAgKiAgIGZvciB1bml2ZXJzYWwgSVNPIHdlZWstbnVtYmVyaW5nIGRhdGUsIHdoZXJlYXNcbiAgICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXG4gICAqICAgZm9yIHdlZWstbnVtYmVyaW5nIGRhdGUgc3BlY2lmaWMgdG8gdGhlIGxvY2FsZS5cbiAgICogLSBgUGAgaXMgbG9uZyBsb2NhbGl6ZWQgZGF0ZSBmb3JtYXRcbiAgICogLSBgcGAgaXMgbG9uZyBsb2NhbGl6ZWQgdGltZSBmb3JtYXRcbiAgICovXG5cbn07XG52YXIgZm9ybWF0dGVycyQxID0ge1xuICAvLyBFcmFcbiAgRzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBlcmEgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPiAwID8gMSA6IDA7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBBRCwgQkNcbiAgICAgIGNhc2UgJ0cnOlxuICAgICAgY2FzZSAnR0cnOlxuICAgICAgY2FzZSAnR0dHJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEEsIEJcblxuICAgICAgY2FzZSAnR0dHR0cnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93J1xuICAgICAgICB9KTtcbiAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XG5cbiAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gWWVhclxuICB5OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgLy8gT3JkaW5hbCBudW1iZXJcbiAgICBpZiAodG9rZW4gPT09ICd5bycpIHtcbiAgICAgIHZhciBzaWduZWRZZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpOyAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuXG4gICAgICB2YXIgeWVhciA9IHNpZ25lZFllYXIgPiAwID8gc2lnbmVkWWVhciA6IDEgLSBzaWduZWRZZWFyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoeWVhciwge1xuICAgICAgICB1bml0OiAneWVhcidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLnkoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2lnbmVkV2Vla1llYXIgPSBnZXRVVENXZWVrWWVhcihkYXRlLCBvcHRpb25zKTsgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcblxuICAgIHZhciB3ZWVrWWVhciA9IHNpZ25lZFdlZWtZZWFyID4gMCA/IHNpZ25lZFdlZWtZZWFyIDogMSAtIHNpZ25lZFdlZWtZZWFyOyAvLyBUd28gZGlnaXQgeWVhclxuXG4gICAgaWYgKHRva2VuID09PSAnWVknKSB7XG4gICAgICB2YXIgdHdvRGlnaXRZZWFyID0gd2Vla1llYXIgJSAxMDA7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHR3b0RpZ2l0WWVhciwgMik7XG4gICAgfSAvLyBPcmRpbmFsIG51bWJlclxuXG5cbiAgICBpZiAodG9rZW4gPT09ICdZbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHdlZWtZZWFyLCB7XG4gICAgICAgIHVuaXQ6ICd5ZWFyJ1xuICAgICAgfSk7XG4gICAgfSAvLyBQYWRkaW5nXG5cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3Mod2Vla1llYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBpc29XZWVrWWVhciA9IGdldFVUQ0lTT1dlZWtZZWFyKGRhdGUpOyAvLyBQYWRkaW5nXG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb1dlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBFeHRlbmRlZCB5ZWFyLiBUaGlzIGlzIGEgc2luZ2xlIG51bWJlciBkZXNpZ25hdGluZyB0aGUgeWVhciBvZiB0aGlzIGNhbGVuZGFyIHN5c3RlbS5cbiAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIGxvY2FsaXplcnMgYXJlIEIuQy4geWVhcnM6XG4gIC8vIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gIC8vIHwtLS0tLS18LS0tLS18LS0tLS18XG4gIC8vIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gIC8vIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gIC8vIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gIC8vIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAgLy8gd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkLlxuICB1OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIFF1YXJ0ZXJcbiAgUTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSAvIDMpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuXG4gICAgICBjYXNlICdRUSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MocXVhcnRlciwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgY2FzZSAnUW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7XG4gICAgICAgICAgdW5pdDogJ3F1YXJ0ZXInXG4gICAgICAgIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgY2FzZSAnUVFRJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICBjYXNlICdRUVFRUSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cblxuICAgICAgY2FzZSAnUVFRUSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXG4gIHE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgcXVhcnRlciA9IE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHF1YXJ0ZXIpO1xuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcblxuICAgICAgY2FzZSAncXEnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHF1YXJ0ZXIsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG5cbiAgICAgIGNhc2UgJ3FvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwge1xuICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG5cbiAgICAgIGNhc2UgJ3FxcSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcblxuICAgICAgY2FzZSAncXFxcXEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgIGNhc2UgJ3FxcXEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gTW9udGhcbiAgTTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgY2FzZSAnTU0nOlxuICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5NKGRhdGUsIHRva2VuKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgY2FzZSAnTW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHtcbiAgICAgICAgICB1bml0OiAnbW9udGgnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgIGNhc2UgJ01NTSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICBjYXNlICdNTU1NTSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICBjYXNlICdNTU1NJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcbiAgTDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKG1vbnRoICsgMSk7XG4gICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcblxuICAgICAgY2FzZSAnTEwnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKG1vbnRoICsgMSwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgIGNhc2UgJ0xvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobW9udGggKyAxLCB7XG4gICAgICAgICAgdW5pdDogJ21vbnRoJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuXG4gICAgICBjYXNlICdMTEwnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKLCBGLCAuLi4sIERcblxuICAgICAgY2FzZSAnTExMTEwnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgY2FzZSAnTExMTCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIExvY2FsIHdlZWsgb2YgeWVhclxuICB3OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIHdlZWsgPSBnZXRVVENXZWVrKGRhdGUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRva2VuID09PSAnd28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrLCB7XG4gICAgICAgIHVuaXQ6ICd3ZWVrJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh3ZWVrLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBJU08gd2VlayBvZiB5ZWFyXG4gIEk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaXNvV2VlayA9IGdldFVUQ0lTT1dlZWsoZGF0ZSk7XG5cbiAgICBpZiAodG9rZW4gPT09ICdJbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb1dlZWssIHtcbiAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb1dlZWssIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ2RvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENEYXRlKCksIHtcbiAgICAgICAgdW5pdDogJ2RhdGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycy5kKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHllYXJcbiAgRDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBkYXlPZlllYXIgPSBnZXRVVENEYXlPZlllYXIoZGF0ZSk7XG5cbiAgICBpZiAodG9rZW4gPT09ICdEbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRheU9mWWVhciwge1xuICAgICAgICB1bml0OiAnZGF5T2ZZZWFyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXlPZlllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSAnRSc6XG4gICAgICBjYXNlICdFRSc6XG4gICAgICBjYXNlICdFRUUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnRUVFRUUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdFRUVFRUUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnRUVFRSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gTG9jYWwgZGF5IG9mIHdlZWtcbiAgZTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBsb2NhbERheU9mV2VlayA9IChkYXlPZldlZWsgLSBvcHRpb25zLndlZWtTdGFydHNPbiArIDgpICUgNyB8fCA3O1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChOdGggZGF5IG9mIHdlZWsgd2l0aCBjdXJyZW50IGxvY2FsZSBvciB3ZWVrU3RhcnRzT24pXG4gICAgICBjYXNlICdlJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2Vlayk7XG4gICAgICAvLyBQYWRkZWQgbnVtZXJpY2FsIHZhbHVlXG5cbiAgICAgIGNhc2UgJ2VlJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhsb2NhbERheU9mV2VlaywgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcblxuICAgICAgY2FzZSAnZW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihsb2NhbERheU9mV2Vlaywge1xuICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdlZWUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnZWVlZWUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdlZWVlZWUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnZWVlZSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcbiAgYzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBsb2NhbERheU9mV2VlayA9IChkYXlPZldlZWsgLSBvcHRpb25zLndlZWtTdGFydHNPbiArIDgpICUgNyB8fCA3O1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChzYW1lIGFzIGluIGBlYClcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcblxuICAgICAgY2FzZSAnY2MnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgN3RoXG5cbiAgICAgIGNhc2UgJ2NvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobG9jYWxEYXlPZldlZWssIHtcbiAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnY2NjJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ2NjY2NjJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnY2NjY2NjJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ2NjY2MnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIElTTyBkYXkgb2Ygd2Vla1xuICBpOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgdmFyIGlzb0RheU9mV2VlayA9IGRheU9mV2VlayA9PT0gMCA/IDcgOiBkYXlPZldlZWs7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAyXG4gICAgICBjYXNlICdpJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpc29EYXlPZldlZWspO1xuICAgICAgLy8gMDJcblxuICAgICAgY2FzZSAnaWknOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb0RheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDJuZFxuXG4gICAgICBjYXNlICdpbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb0RheU9mV2Vlaywge1xuICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlXG5cbiAgICAgIGNhc2UgJ2lpaSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdpaWlpaSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ2lpaWlpaSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdpaWlpJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBBTSBvciBQTVxuICBhOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWUgPSBob3VycyAvIDEyID49IDEgPyAncG0nIDogJ2FtJztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnYWEnOlxuICAgICAgY2FzZSAnYWFhJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2FhYWFhJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdhYWFhJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBBTSwgUE0sIG1pZG5pZ2h0LCBub29uXG4gIGI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZTtcblxuICAgIGlmIChob3VycyA9PT0gMTIpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID09PSAwKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm1pZG5pZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBob3VycyAvIDEyID49IDEgPyAncG0nIDogJ2FtJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdiJzpcbiAgICAgIGNhc2UgJ2JiJzpcbiAgICAgIGNhc2UgJ2JiYic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdiYmJiYic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYmJiYic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuICBCOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWU7XG5cbiAgICBpZiAoaG91cnMgPj0gMTcpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uZXZlbmluZztcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmFmdGVybm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubW9ybmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5uaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdCJzpcbiAgICAgIGNhc2UgJ0JCJzpcbiAgICAgIGNhc2UgJ0JCQic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdCQkJCQic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnQkJCQic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ2hvJykge1xuICAgICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpICUgMTI7XG4gICAgICBpZiAoaG91cnMgPT09IDApIGhvdXJzID0gMTI7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLmgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnSG8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ0hvdXJzKCksIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycy5IKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gSG91ciBbMC0xMV1cbiAgSzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyO1xuXG4gICAgaWYgKHRva2VuID09PSAnS28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEhvdXIgWzEtMjRdXG4gIGs6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDI0O1xuXG4gICAgaWYgKHRva2VuID09PSAna28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbnV0ZVxuICBtOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnbW8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ01pbnV0ZXMoKSwge1xuICAgICAgICB1bml0OiAnbWludXRlJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMubShkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIFNlY29uZFxuICBzOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnc28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ1NlY29uZHMoKSwge1xuICAgICAgICB1bml0OiAnc2Vjb25kJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMucyhkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gZm9ybWF0dGVycy5TKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxLiBJZiBvZmZzZXQgaXMgMCwgb3V0cHV0IGlzIGFsd2F5cyBgJ1onYClcbiAgWDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBpZiAodGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiAnWic7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYYFxuXG4gICAgICBjYXNlICdYWFhYJzpcbiAgICAgIGNhc2UgJ1hYJzpcbiAgICAgICAgLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRoIGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGBYWFhgXG5cbiAgICAgIGNhc2UgJ1hYWFhYJzpcbiAgICAgIGNhc2UgJ1hYWCc6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEuIElmIG9mZnNldCBpcyAwLCBvdXRwdXQgaXMgYCcrMDA6MDAnYCBvciBlcXVpdmFsZW50KVxuICB4OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEhvdXJzIGFuZCBvcHRpb25hbCBtaW51dGVzXG4gICAgICBjYXNlICd4JzpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGB4eGBcblxuICAgICAgY2FzZSAneHh4eCc6XG4gICAgICBjYXNlICd4eCc6XG4gICAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHh4YFxuXG4gICAgICBjYXNlICd4eHh4eCc6XG4gICAgICBjYXNlICd4eHgnOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRoIGA6YCBkZWxpbWl0ZXJcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGltZXpvbmUgKEdNVClcbiAgTzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSAnTyc6XG4gICAgICBjYXNlICdPTyc6XG4gICAgICBjYXNlICdPT08nOlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZVNob3J0KHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgICAgLy8gTG9uZ1xuXG4gICAgICBjYXNlICdPT09PJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdGlvbilcbiAgejogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICd6eic6XG4gICAgICBjYXNlICd6enonOlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZVNob3J0KHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgICAgLy8gTG9uZ1xuXG4gICAgICBjYXNlICd6enp6JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXBcbiAgdDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3Iob3JpZ2luYWxEYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gIFQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lc3RhbXAgPSBvcmlnaW5hbERhdGUuZ2V0VGltZSgpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZVNob3J0KG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpIHtcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xuICB2YXIgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCk7XG4gIHZhciBtaW51dGVzID0gYWJzT2Zmc2V0ICUgNjA7XG5cbiAgaWYgKG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gc2lnbiArIFN0cmluZyhob3Vycyk7XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZGlydHlEZWxpbWl0ZXIgfHwgJyc7XG4gIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKSArIGRlbGltaXRlciArIGFkZExlYWRpbmdaZXJvcyhtaW51dGVzLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzKG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpIHtcbiAgaWYgKG9mZnNldCAlIDYwID09PSAwKSB7XG4gICAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xuICAgIHJldHVybiBzaWduICsgYWRkTGVhZGluZ1plcm9zKE1hdGguYWJzKG9mZnNldCkgLyA2MCwgMik7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkaXJ0eURlbGltaXRlcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lKG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpIHtcbiAgdmFyIGRlbGltaXRlciA9IGRpcnR5RGVsaW1pdGVyIHx8ICcnO1xuICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICB2YXIgaG91cnMgPSBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCksIDIpO1xuICB2YXIgbWludXRlcyA9IGFkZExlYWRpbmdaZXJvcyhhYnNPZmZzZXQgJSA2MCwgMik7XG4gIHJldHVybiBzaWduICsgaG91cnMgKyBkZWxpbWl0ZXIgKyBtaW51dGVzO1xufVxuXG5mdW5jdGlvbiBkYXRlTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKSB7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgJ1AnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnc2hvcnQnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1BQJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ21lZGl1bSdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUFBQJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ2xvbmcnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1BQUFAnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdmdWxsJ1xuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGltZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZykge1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlICdwJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ3Nob3J0J1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdwcCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdtZWRpdW0nXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ3BwcCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdsb25nJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdwcHBwJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnZnVsbCdcbiAgICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGVUaW1lTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKSB7XG4gIHZhciBtYXRjaFJlc3VsdCA9IHBhdHRlcm4ubWF0Y2goLyhQKykocCspPy8pO1xuICB2YXIgZGF0ZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsxXTtcbiAgdmFyIHRpbWVQYXR0ZXJuID0gbWF0Y2hSZXN1bHRbMl07XG5cbiAgaWYgKCF0aW1lUGF0dGVybikge1xuICAgIHJldHVybiBkYXRlTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKTtcbiAgfVxuXG4gIHZhciBkYXRlVGltZUZvcm1hdDtcblxuICBzd2l0Y2ggKGRhdGVQYXR0ZXJuKSB7XG4gICAgY2FzZSAnUCc6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ3Nob3J0J1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BQJzpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnbWVkaXVtJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BQUCc6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ2xvbmcnXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUFBQUCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnZnVsbCdcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZGF0ZVRpbWVGb3JtYXQucmVwbGFjZSgne3tkYXRlfX0nLCBkYXRlTG9uZ0Zvcm1hdHRlcihkYXRlUGF0dGVybiwgZm9ybWF0TG9uZykpLnJlcGxhY2UoJ3t7dGltZX19JywgdGltZUxvbmdGb3JtYXR0ZXIodGltZVBhdHRlcm4sIGZvcm1hdExvbmcpKTtcbn1cblxudmFyIGxvbmdGb3JtYXR0ZXJzID0ge1xuICBwOiB0aW1lTG9uZ0Zvcm1hdHRlcixcbiAgUDogZGF0ZVRpbWVMb25nRm9ybWF0dGVyXG59O1xuXG52YXIgcHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW5zID0gWydEJywgJ0REJ107XG52YXIgcHJvdGVjdGVkV2Vla1llYXJUb2tlbnMgPSBbJ1lZJywgJ1lZWVknXTtcbmZ1bmN0aW9uIGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4odG9rZW4pIHtcbiAgcmV0dXJuIHByb3RlY3RlZERheU9mWWVhclRva2Vucy5pbmRleE9mKHRva2VuKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4odG9rZW4pIHtcbiAgcmV0dXJuIHByb3RlY3RlZFdlZWtZZWFyVG9rZW5zLmluZGV4T2YodG9rZW4pICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHRocm93UHJvdGVjdGVkRXJyb3IodG9rZW4pIHtcbiAgaWYgKHRva2VuID09PSAnWVlZWScpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCBmb3IgZm9ybWF0dGluZyB5ZWFyczsgc2VlOiBodHRwczovL2dpdC5pby9meEN5cicpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnWVknKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VzZSBgeXlgIGluc3RlYWQgb2YgYFlZYCBmb3IgZm9ybWF0dGluZyB5ZWFyczsgc2VlOiBodHRwczovL2dpdC5pby9meEN5cicpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnRCcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5cicpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnREQnKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VzZSBgZGRgIGluc3RlYWQgb2YgYEREYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5cicpO1xuICB9XG59XG5cbi8vIC0gW3lZUXFNTHdJZERlY2loSEtrbXNdbyBtYXRjaGVzIGFueSBhdmFpbGFibGUgb3JkaW5hbCBudW1iZXIgdG9rZW5cbi8vICAgKG9uZSBvZiB0aGUgY2VydGFpbiBsZXR0ZXJzIGZvbGxvd2VkIGJ5IGBvYClcbi8vIC0gKFxcdylcXDEqIG1hdGNoZXMgYW55IHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBsZXR0ZXJcbi8vIC0gJycgbWF0Y2hlcyB0d28gcXVvdGUgY2hhcmFjdGVycyBpbiBhIHJvd1xuLy8gLSAnKCcnfFteJ10pKygnfCQpIG1hdGNoZXMgYW55dGhpbmcgc3Vycm91bmRlZCBieSB0d28gcXVvdGUgY2hhcmFjdGVycyAoJyksXG4vLyAgIGV4Y2VwdCBhIHNpbmdsZSBxdW90ZSBzeW1ib2wsIHdoaWNoIGVuZHMgdGhlIHNlcXVlbmNlLlxuLy8gICBUd28gcXVvdGUgY2hhcmFjdGVycyBkbyBub3QgZW5kIHRoZSBzZXF1ZW5jZS5cbi8vICAgSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc2luZ2xlIHF1b3RlXG4vLyAgIHRoZW4gdGhlIHNlcXVlbmNlIHdpbGwgY29udGludWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuLy8gLSAuIG1hdGNoZXMgYW55IHNpbmdsZSBjaGFyYWN0ZXIgdW5tYXRjaGVkIGJ5IHByZXZpb3VzIHBhcnRzIG9mIHRoZSBSZWdFeHBzXG5cbnZhciBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gL1t5WVFxTUx3SWREZWNpaEhLa21zXW98KFxcdylcXDEqfCcnfCcoJyd8W14nXSkrKCd8JCl8Li9nOyAvLyBUaGlzIFJlZ0V4cCBjYXRjaGVzIHN5bWJvbHMgZXNjYXBlZCBieSBxdW90ZXMsIGFuZCBhbHNvXG4vLyBzZXF1ZW5jZXMgb2Ygc3ltYm9scyBQLCBwLCBhbmQgdGhlIGNvbWJpbmF0aW9ucyBsaWtlIGBQUFBQUFBQcHBwcHBgXG5cbnZhciBsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC9QK3ArfFArfHArfCcnfCcoJyd8W14nXSkrKCd8JCl8Li9nO1xudmFyIGVzY2FwZWRTdHJpbmdSZWdFeHAgPSAvXicoLio/KSc/JC87XG52YXIgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcbnZhciB1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCA9IC9bYS16QS1aXS87XG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZm9ybWF0LiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXG4gKiA+IFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqIChzZWUgdGhlIGxhc3QgZXhhbXBsZSlcbiAqXG4gKiBGb3JtYXQgb2YgdGhlIHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNyBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIEFjY2VwdGVkIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMHRoLCAxN3RoICAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCAyMDE3dGggICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCBSICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlIgICAgICB8IC00MywgMDAsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDAsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDAsIDAwMDEsIDE5MDAsIDIwMTcgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSw3IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IHUgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgOSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8IDcgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWFhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYWEgICAgfCBhLm0uLCBwLm0uICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhYSAgIHwgYSwgcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgIHwgYi4uYmJiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmIgICAgfCBhLm0uLCBwLm0uLCBub29uLCBtaWRuaWdodCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmJiYiAgIHwgYSwgcCwgbiwgbWkgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgIHwgQi4uQkJCICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkIgICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBCQkJCQiAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgIHwgaCAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAxMnRoICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBoaCAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgIHwgSCAgICAgICB8IDAsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhvICAgICAgfCAwdGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICAgIHwgMDAsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgIHwgSyAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAwdGggICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBLSyAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgIHwgayAgICAgICB8IDI0LCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtvICAgICAgfCAyNHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBrayAgICAgIHwgMjQsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1vICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcyAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNvICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgIHwgUyAgICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1MgICAgIHwgMDAwLCAwMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1NTUyAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvIFopICAgICAgICB8IFggICAgICAgfCAtMDgsICswNTMwLCBaICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWCAgICAgIHwgLTA4MDAsICswNTMwLCBaICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYICAgICB8IC0wODowMCwgKzA1OjMwLCBaICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFggICAgfCAtMDgwMCwgKzA1MzAsIFosICsxMjM0NTYgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFhYWCAgIHwgLTA4OjAwLCArMDU6MzAsIFosICsxMjozNDo1NiAgICAgIHwgICAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgIHwgeCAgICAgICB8IC0wOCwgKzA1MzAsICswMCAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4ICAgICAgfCAtMDgwMCwgKzA1MzAsICswMDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHggICAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eCAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAsICsxMjM0NTYgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eHh4ICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwLCArMTI6MzQ6NTYgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICAgfCBPLi4uT09PIHwgR01ULTgsIEdNVCs1OjMwLCBHTVQrMCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgT09PTyAgICB8IEdNVC0wODowMCwgR01UKzA1OjMwLCBHTVQrMDA6MDAgICB8IDIgICAgIHxcbiAqIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pICB8IHouLi56enogfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCA2ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB6enp6ICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiw2ICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHR0ICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDcgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgfCBUICAgICAgIHwgNTEyOTY5NTIwOTAwICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgICB8IFAgICAgICAgfCAwNS8yOS8xNDUzICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUCAgICAgIHwgTWF5IDI5LCAxNDUzICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQICAgICB8IE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUFAgICAgfCBTdW5kYXksIE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICAgfCBwICAgICAgIHwgMTI6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHAgICAgICB8IDEyOjAwOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcCAgICAgfCAxMjowMDowMCBBTSBHTVQrMiAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcHBwICAgIHwgMTI6MDA6MDAgQU0gR01UKzAyOjAwICAgICAgICAgICAgIHwgMiw3ICAgfFxuICogfCBDb21iaW5hdGlvbiBvZiBkYXRlIGFuZCB0aW1lICAgIHwgUHAgICAgICB8IDA1LzI5LzE0NTMsIDEyOjAwIEFNICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQcHAgICAgfCBNYXkgMjksIDE0NTMsIDEyOjAwOjAwIEFNICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBwcHAgIHwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUHBwcHB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICB8IDIsNyAgIHxcbiAqIE5vdGVzOlxuICogMS4gXCJGb3JtYXR0aW5nXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcbiAqICAgIGFyZSB0aGUgc2FtZSBhcyBcInN0YW5kLWFsb25lXCIgdW5pdHMsIGJ1dCBhcmUgZGlmZmVyZW50IGluIHNvbWUgbGFuZ3VhZ2VzLlxuICogICAgXCJGb3JtYXR0aW5nXCIgdW5pdHMgYXJlIGRlY2xpbmVkIGFjY29yZGluZyB0byB0aGUgcnVsZXMgb2YgdGhlIGxhbmd1YWdlXG4gKiAgICBpbiB0aGUgY29udGV4dCBvZiBhIGRhdGUuIFwiU3RhbmQtYWxvbmVcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXI6XG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBMTExMJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZCdgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBNTU1NJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZHUnYFxuICpcbiAqIDIuIEFueSBzZXF1ZW5jZSBvZiB0aGUgaWRlbnRpY2FsIGxldHRlcnMgaXMgYSBwYXR0ZXJuLCB1bmxlc3MgaXQgaXMgZXNjYXBlZCBieVxuICogICAgdGhlIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIChzZWUgYmVsb3cpLlxuICogICAgSWYgdGhlIHNlcXVlbmNlIGlzIGxvbmdlciB0aGFuIGxpc3RlZCBpbiB0YWJsZSAoZS5nLiBgRUVFRUVFRUVFRUVgKVxuICogICAgdGhlIG91dHB1dCB3aWxsIGJlIHRoZSBzYW1lIGFzIGRlZmF1bHQgcGF0dGVybiBmb3IgdGhpcyB1bml0LCB1c3VhbGx5XG4gKiAgICB0aGUgbG9uZ2VzdCBvbmUgKGluIGNhc2Ugb2YgSVNPIHdlZWtkYXlzLCBgRUVFRWApLiBEZWZhdWx0IHBhdHRlcm5zIGZvciB1bml0c1xuICogICAgYXJlIG1hcmtlZCB3aXRoIFwiMlwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU0nKSAvLz0+ICdOb3YnYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NJykgLy89PiAnTidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqIDMuIFNvbWUgcGF0dGVybnMgY291bGQgYmUgdW5saW1pdGVkIGxlbmd0aCAoc3VjaCBhcyBgeXl5eXl5eXlgKS5cbiAqICAgIFRoZSBvdXRwdXQgd2lsbCBiZSBwYWRkZWQgd2l0aCB6ZXJvcyB0byBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBwYXR0ZXJuLlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAneXl5eXl5eXknKSAvLz0+ICcwMDAwMjAxNydgXG4gKlxuICogNC4gYFFRUVFRYCBhbmQgYHFxcXFxYCBjb3VsZCBiZSBub3Qgc3RyaWN0bHkgbnVtZXJpY2FsIGluIHNvbWUgbG9jYWxlcy5cbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXG4gKlxuICogNS4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIHBhdHRlcm5zIGFyZSBCLkMuIHllYXJzOlxuICpcbiAqICAgIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcbiAqICAgIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gKiAgICB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICpcbiAqICAgIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAqICAgIHdoaWxlIGB1dWAgcGFkcyBzaW5nbGUgZGlnaXQgeWVhcnMgdG8gMiBjaGFyYWN0ZXJzIGFuZCByZXR1cm5zIG90aGVyIHllYXJzIHVuY2hhbmdlZDpcbiAqXG4gKiAgICB8IFllYXIgfCBgeXlgIHwgYHV1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tLXwtLS0tLS18XG4gKiAgICB8IDEgICAgfCAgIDAxIHwgICAwMSB8XG4gKiAgICB8IDE0ICAgfCAgIDE0IHwgICAxNCB8XG4gKiAgICB8IDM3NiAgfCAgIDc2IHwgIDM3NiB8XG4gKiAgICB8IDE0NTMgfCAgIDUzIHwgMTQ1MyB8XG4gKlxuICogICAgVGhlIHNhbWUgZGlmZmVyZW5jZSBpcyB0cnVlIGZvciBsb2NhbCBhbmQgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIChgWWAgYW5kIGBSYCksXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXG4gKiAgICBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAoY29tcGFyZSBbZ2V0SVNPV2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0SVNPV2Vla1llYXJ9XG4gKiAgICBhbmQgW2dldFdlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL2dldFdlZWtZZWFyfSkuXG4gKlxuICogNi4gU3BlY2lmaWMgbm9uLWxvY2F0aW9uIHRpbWV6b25lcyBhcmUgY3VycmVudGx5IHVuYXZhaWxhYmxlIGluIGBkYXRlLWZuc2AsXG4gKiAgICBzbyByaWdodCBub3cgdGhlc2UgdG9rZW5zIGZhbGwgYmFjayB0byBHTVQgdGltZXpvbmVzLlxuICpcbiAqIDcuIFRoZXNlIHBhdHRlcm5zIGFyZSBub3QgaW4gdGhlIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqICAgIC0gYGlgOiBJU08gZGF5IG9mIHdlZWtcbiAqICAgIC0gYElgOiBJU08gd2VlayBvZiB5ZWFyXG4gKiAgICAtIGBSYDogSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqICAgIC0gYHRgOiBzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgVGA6IG1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAqICAgIC0gYG9gOiBvcmRpbmFsIG51bWJlciBtb2RpZmllclxuICogICAgLSBgUGA6IGxvbmcgbG9jYWxpemVkIGRhdGVcbiAqICAgIC0gYHBgOiBsb25nIGxvY2FsaXplZCB0aW1lXG4gKlxuICogOC4gYFlZYCBhbmQgYFlZWVlgIHRva2VucyByZXByZXNlbnQgd2Vlay1udW1iZXJpbmcgeWVhcnMgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggeWVhcnMuXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogOS4gYERgIGFuZCBgRERgIHRva2VucyByZXByZXNlbnQgZGF5cyBvZiB0aGUgeWVhciBidXQgdGhleSBhcmUgb2Z0aGVuIGNvbmZ1c2VkIHdpdGggZGF5cyBvZiB0aGUgbW9udGguXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogLSBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIG5vdyByZXF1aXJlZCBmb3IgdGhlIHNha2Ugb2YgZXhwbGljaXRuZXNzLlxuICpcbiAqICAgYGBgamF2YXNjcmlwdFxuICogICAvLyBCZWZvcmUgdjIuMC4wXG4gKiAgIGZvcm1hdChuZXcgRGF0ZSgyMDE2LCAwLCAxKSlcbiAqXG4gKiAgIC8vIHYyLjAuMCBvbndhcmRcbiAqICAgZm9ybWF0KG5ldyBEYXRlKDIwMTYsIDAsIDEpLCBcInl5eXktTU0tZGQnVCdISDptbTpzcy5TU1N4eHhcIilcbiAqICAgYGBgXG4gKlxuICogLSBOZXcgZm9ybWF0IHN0cmluZyBBUEkgZm9yIGBmb3JtYXRgIGZ1bmN0aW9uXG4gKiAgIHdoaWNoIGlzIGJhc2VkIG9uIFtVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzVdKGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGUpLlxuICogICBTZWUgW3RoaXMgcG9zdF0oaHR0cHM6Ly9ibG9nLmRhdGUtZm5zLm9yZy9wb3N0L3VuaWNvZGUtdG9rZW5zLWluLWRhdGUtZm5zLXYyLXNyZWF0eWtpOTFqZykgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiAtIENoYXJhY3RlcnMgYXJlIG5vdyBlc2NhcGVkIHVzaW5nIHNpbmdsZSBxdW90ZSBzeW1ib2xzIChgJ2ApIGluc3RlYWQgb2Ygc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAtIHRoZSBzdHJpbmcgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU9MV0gLSB0aGUgZGF5IG9mIEphbnVhcnksIHdoaWNoIGlzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgdGhlIHdlZWstbnVtYmVyaW5nIHllYXIgdG9rZW5zIGBZWWAgYW5kIGBZWVlZYDtcbiAqICAgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiB0aGUgZGF5IG9mIHllYXIgdG9rZW5zIGBEYCBhbmQgYEREYDtcbiAqICAgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGxvY2FsaXplYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdExvbmdgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYHl5eXlgIGluc3RlYWQgb2YgYFlZWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnM7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgZGAgaW5zdGVhZCBvZiBgRGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGg7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgZGRgIGluc3RlYWQgb2YgYEREYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gZm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxMSBGZWJydWFyeSAyMDE0IGluIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCAxLCAxMSksICdNTS9kZC95eXl5JylcbiAqIC8vPT4gJzAyLzExLzIwMTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAyIEp1bHkgMjAxNCBpbiBFc3BlcmFudG86XG4gKiBpbXBvcnQgeyBlb0xvY2FsZSB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQobmV3IERhdGUoMjAxNCwgNiwgMiksIFwiZG8gJ2RlJyBNTU1NIHl5eXlcIiwge1xuICogICBsb2NhbGU6IGVvTG9jYWxlXG4gKiB9KVxuICogLy89PiAnMi1hIGRlIGp1bGlvIDIwMTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEVzY2FwZSBzdHJpbmcgYnkgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnM6XG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIsIDE1KSwgXCJoICdvJydjbG9jaydcIilcbiAqIC8vPT4gXCIzIG8nY2xvY2tcIlxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdChkaXJ0eURhdGUsIGRpcnR5Rm9ybWF0U3RyLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZm9ybWF0U3RyID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUkMSA9IG9wdGlvbnMubG9jYWxlIHx8IGxvY2FsZTtcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZSQxLm9wdGlvbnMgJiYgbG9jYWxlJDEub3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU7XG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyAxIDogdG9JbnRlZ2VyJDEobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyJDEob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUkMS5vcHRpb25zICYmIGxvY2FsZSQxLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlciQxKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlciQxKG9wdGlvbnMud2Vla1N0YXJ0c09uKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICBpZiAoIWxvY2FsZSQxLmxvY2FsaXplKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gbG9jYWxpemUgcHJvcGVydHknKTtcbiAgfVxuXG4gIGlmICghbG9jYWxlJDEuZm9ybWF0TG9uZykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGZvcm1hdExvbmcgcHJvcGVydHknKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbERhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcblxuICBpZiAoIWlzVmFsaWQob3JpZ2luYWxEYXRlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgfSAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cblxuICB2YXIgdGltZXpvbmVPZmZzZXQgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSk7XG4gIHZhciB1dGNEYXRlID0gc3ViTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSwgdGltZXpvbmVPZmZzZXQpO1xuICB2YXIgZm9ybWF0dGVyT3B0aW9ucyA9IHtcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbixcbiAgICBsb2NhbGU6IGxvY2FsZSQxLFxuICAgIF9vcmlnaW5hbERhdGU6IG9yaWdpbmFsRGF0ZVxuICB9O1xuICB2YXIgcmVzdWx0ID0gZm9ybWF0U3RyLm1hdGNoKGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwKS5tYXAoZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgIHZhciBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcblxuICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gJ3AnIHx8IGZpcnN0Q2hhcmFjdGVyID09PSAnUCcpIHtcbiAgICAgIHZhciBsb25nRm9ybWF0dGVyID0gbG9uZ0Zvcm1hdHRlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuICAgICAgcmV0dXJuIGxvbmdGb3JtYXR0ZXIoc3Vic3RyaW5nLCBsb2NhbGUkMS5mb3JtYXRMb25nLCBmb3JtYXR0ZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic3RyaW5nO1xuICB9KS5qb2luKCcnKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zUmVnRXhwKS5tYXAoZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgIC8vIFJlcGxhY2UgdHdvIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJcbiAgICBpZiAoc3Vic3RyaW5nID09PSBcIicnXCIpIHtcbiAgICAgIHJldHVybiBcIidcIjtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICByZXR1cm4gY2xlYW5Fc2NhcGVkU3RyaW5nKHN1YnN0cmluZyk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHRlcnMkMVtmaXJzdENoYXJhY3Rlcl07XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbihzdWJzdHJpbmcpKSB7XG4gICAgICAgIHRocm93UHJvdGVjdGVkRXJyb3Ioc3Vic3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbihzdWJzdHJpbmcpKSB7XG4gICAgICAgIHRocm93UHJvdGVjdGVkRXJyb3Ioc3Vic3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdHRlcih1dGNEYXRlLCBzdWJzdHJpbmcsIGxvY2FsZSQxLmxvY2FsaXplLCBmb3JtYXR0ZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIubWF0Y2godW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHApKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyIGAnICsgZmlyc3RDaGFyYWN0ZXIgKyAnYCcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzdHJpbmc7XG4gIH0pLmpvaW4oJycpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjbGVhbkVzY2FwZWRTdHJpbmcoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0Lm1hdGNoKGVzY2FwZWRTdHJpbmdSZWdFeHApWzFdLnJlcGxhY2UoZG91YmxlUXVvdGVSZWdFeHAsIFwiJ1wiKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduJDEodGFyZ2V0LCBkaXJ0eU9iamVjdCkge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhc3NpZ24gcmVxdWlyZXMgdGhhdCBpbnB1dCBwYXJhbWV0ZXIgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICBkaXJ0eU9iamVjdCA9IGRpcnR5T2JqZWN0IHx8IHt9O1xuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGRpcnR5T2JqZWN0KSB7XG4gICAgaWYgKGRpcnR5T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGRpcnR5T2JqZWN0W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBuYW1lIGlzQWZ0ZXJcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0aGF0IHNob3VsZCBiZSBhZnRlciB0aGUgb3RoZXIgb25lIHRvIHJldHVybiB0cnVlXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEwIEp1bHkgMTk4OSBhZnRlciAxMSBGZWJydWFyeSAxOTg3P1xuICogdmFyIHJlc3VsdCA9IGlzQWZ0ZXIobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuXG5mdW5jdGlvbiBpc0FmdGVyKGRpcnR5RGF0ZSwgZGlydHlEYXRlVG9Db21wYXJlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRhdGVUb0NvbXBhcmUgPSB0b0RhdGUoZGlydHlEYXRlVG9Db21wYXJlKTtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID4gZGF0ZVRvQ29tcGFyZS5nZXRUaW1lKCk7XG59XG5cbi8qKlxuICogQG5hbWUgaXNCZWZvcmVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGJlZm9yZSB0aGUgb3RoZXIgb25lIHRvIHJldHVybiB0cnVlXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGZpcnN0IGRhdGUgaXMgYmVmb3JlIHRoZSBzZWNvbmQgZGF0ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJcyAxMCBKdWx5IDE5ODkgYmVmb3JlIDExIEZlYnJ1YXJ5IDE5ODc/XG4gKiB2YXIgcmVzdWx0ID0gaXNCZWZvcmUobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cblxuZnVuY3Rpb24gaXNCZWZvcmUoZGlydHlEYXRlLCBkaXJ0eURhdGVUb0NvbXBhcmUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUpO1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPCBkYXRlVG9Db21wYXJlLmdldFRpbWUoKTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzZXRVVENEYXkoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZVdlZWtTdGFydHNPbiA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyJDEobG9jYWxlV2Vla1N0YXJ0c09uKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyJDEob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSB0b0ludGVnZXIkMShkaXJ0eURheSk7XG4gIHZhciBjdXJyZW50RGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIHJlbWFpbmRlciA9IGRheSAlIDc7XG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XG4gIHZhciBkaWZmID0gKGRheUluZGV4IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gY3VycmVudERheTtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHNldFVUQ0lTT0RheShkaXJ0eURhdGUsIGRpcnR5RGF5KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRheSA9IHRvSW50ZWdlciQxKGRpcnR5RGF5KTtcblxuICBpZiAoZGF5ICUgNyA9PT0gMCkge1xuICAgIGRheSA9IGRheSAtIDc7XG4gIH1cblxuICB2YXIgd2Vla1N0YXJ0c09uID0gMTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGN1cnJlbnREYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcbiAgdmFyIGRheUluZGV4ID0gKHJlbWFpbmRlciArIDcpICUgNztcbiAgdmFyIGRpZmYgPSAoZGF5SW5kZXggPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSBjdXJyZW50RGF5O1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc2V0VVRDSVNPV2VlayhkaXJ0eURhdGUsIGRpcnR5SVNPV2Vlaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBpc29XZWVrID0gdG9JbnRlZ2VyJDEoZGlydHlJU09XZWVrKTtcbiAgdmFyIGRpZmYgPSBnZXRVVENJU09XZWVrKGRhdGUpIC0gaXNvV2VlaztcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZiAqIDcpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzZXRVVENXZWVrKGRpcnR5RGF0ZSwgZGlydHlXZWVrLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHdlZWsgPSB0b0ludGVnZXIkMShkaXJ0eVdlZWspO1xuICB2YXIgZGlmZiA9IGdldFVUQ1dlZWsoZGF0ZSwgb3B0aW9ucykgLSB3ZWVrO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmICogNyk7XG4gIHJldHVybiBkYXRlO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIgPSAzNjAwMDAwO1xudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMSA9IDYwMDAwO1xudmFyIE1JTExJU0VDT05EU19JTl9TRUNPTkQgPSAxMDAwO1xudmFyIG51bWVyaWNQYXR0ZXJucyA9IHtcbiAgbW9udGg6IC9eKDFbMC0yXXwwP1xcZCkvLFxuICAvLyAwIHRvIDEyXG4gIGRhdGU6IC9eKDNbMC0xXXxbMC0yXT9cXGQpLyxcbiAgLy8gMCB0byAzMVxuICBkYXlPZlllYXI6IC9eKDM2WzAtNl18M1swLTVdXFxkfFswLTJdP1xcZD9cXGQpLyxcbiAgLy8gMCB0byAzNjZcbiAgd2VlazogL14oNVswLTNdfFswLTRdP1xcZCkvLFxuICAvLyAwIHRvIDUzXG4gIGhvdXIyM2g6IC9eKDJbMC0zXXxbMC0xXT9cXGQpLyxcbiAgLy8gMCB0byAyM1xuICBob3VyMjRoOiAvXigyWzAtNF18WzAtMV0/XFxkKS8sXG4gIC8vIDAgdG8gMjRcbiAgaG91cjExaDogL14oMVswLTFdfDA/XFxkKS8sXG4gIC8vIDAgdG8gMTFcbiAgaG91cjEyaDogL14oMVswLTJdfDA/XFxkKS8sXG4gIC8vIDAgdG8gMTJcbiAgbWludXRlOiAvXlswLTVdP1xcZC8sXG4gIC8vIDAgdG8gNTlcbiAgc2Vjb25kOiAvXlswLTVdP1xcZC8sXG4gIC8vIDAgdG8gNTlcbiAgc2luZ2xlRGlnaXQ6IC9eXFxkLyxcbiAgLy8gMCB0byA5XG4gIHR3b0RpZ2l0czogL15cXGR7MSwyfS8sXG4gIC8vIDAgdG8gOTlcbiAgdGhyZWVEaWdpdHM6IC9eXFxkezEsM30vLFxuICAvLyAwIHRvIDk5OVxuICBmb3VyRGlnaXRzOiAvXlxcZHsxLDR9LyxcbiAgLy8gMCB0byA5OTk5XG4gIGFueURpZ2l0c1NpZ25lZDogL14tP1xcZCsvLFxuICBzaW5nbGVEaWdpdFNpZ25lZDogL14tP1xcZC8sXG4gIC8vIDAgdG8gOSwgLTAgdG8gLTlcbiAgdHdvRGlnaXRzU2lnbmVkOiAvXi0/XFxkezEsMn0vLFxuICAvLyAwIHRvIDk5LCAtMCB0byAtOTlcbiAgdGhyZWVEaWdpdHNTaWduZWQ6IC9eLT9cXGR7MSwzfS8sXG4gIC8vIDAgdG8gOTk5LCAtMCB0byAtOTk5XG4gIGZvdXJEaWdpdHNTaWduZWQ6IC9eLT9cXGR7MSw0fS8gLy8gMCB0byA5OTk5LCAtMCB0byAtOTk5OVxuXG59O1xudmFyIHRpbWV6b25lUGF0dGVybnMgPSB7XG4gIGJhc2ljT3B0aW9uYWxNaW51dGVzOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSk/fFovLFxuICBiYXNpYzogL14oWystXSkoXFxkezJ9KShcXGR7Mn0pfFovLFxuICBiYXNpY09wdGlvbmFsU2Vjb25kczogL14oWystXSkoXFxkezJ9KShcXGR7Mn0pKChcXGR7Mn0pKT98Wi8sXG4gIGV4dGVuZGVkOiAvXihbKy1dKShcXGR7Mn0pOihcXGR7Mn0pfFovLFxuICBleHRlbmRlZE9wdGlvbmFsU2Vjb25kczogL14oWystXSkoXFxkezJ9KTooXFxkezJ9KSg6KFxcZHsyfSkpP3xaL1xufTtcblxuZnVuY3Rpb24gcGFyc2VOdW1lcmljUGF0dGVybihwYXR0ZXJuLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcbiAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKHBhdHRlcm4pO1xuXG4gIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzBdLCAxMCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlQ2FsbGJhY2sgPyB2YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlLFxuICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaFJlc3VsdFswXS5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHBhdHRlcm4sIHN0cmluZykge1xuICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gocGF0dGVybik7XG5cbiAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIElucHV0IGlzICdaJ1xuXG5cbiAgaWYgKG1hdGNoUmVzdWx0WzBdID09PSAnWicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICByZXN0OiBzdHJpbmcuc2xpY2UoMSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHNpZ24gPSBtYXRjaFJlc3VsdFsxXSA9PT0gJysnID8gMSA6IC0xO1xuICB2YXIgaG91cnMgPSBtYXRjaFJlc3VsdFsyXSA/IHBhcnNlSW50KG1hdGNoUmVzdWx0WzJdLCAxMCkgOiAwO1xuICB2YXIgbWludXRlcyA9IG1hdGNoUmVzdWx0WzNdID8gcGFyc2VJbnQobWF0Y2hSZXN1bHRbM10sIDEwKSA6IDA7XG4gIHZhciBzZWNvbmRzID0gbWF0Y2hSZXN1bHRbNV0gPyBwYXJzZUludChtYXRjaFJlc3VsdFs1XSwgMTApIDogMDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogc2lnbiAqIChob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSICsgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMSArIHNlY29uZHMgKiBNSUxMSVNFQ09ORFNfSU5fU0VDT05EKSxcbiAgICByZXN0OiBzdHJpbmcuc2xpY2UobWF0Y2hSZXN1bHRbMF0ubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUFueURpZ2l0c1NpZ25lZChzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcbiAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmFueURpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VORGlnaXRzKG4sIHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuc2luZ2xlRGlnaXQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudHdvRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnRocmVlRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmZvdXJEaWdpdHMsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obmV3IFJlZ0V4cCgnXlxcXFxkezEsJyArIG4gKyAnfScpLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTkRpZ2l0c1NpZ25lZChuLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnNpbmdsZURpZ2l0U2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnR3b0RpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50aHJlZURpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5mb3VyRGlnaXRzU2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG5ldyBSZWdFeHAoJ14tP1xcXFxkezEsJyArIG4gKyAnfScpLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRheVBlcmlvZEVudW1Ub0hvdXJzKGVudW1WYWx1ZSkge1xuICBzd2l0Y2ggKGVudW1WYWx1ZSkge1xuICAgIGNhc2UgJ21vcm5pbmcnOlxuICAgICAgcmV0dXJuIDQ7XG5cbiAgICBjYXNlICdldmVuaW5nJzpcbiAgICAgIHJldHVybiAxNztcblxuICAgIGNhc2UgJ3BtJzpcbiAgICBjYXNlICdub29uJzpcbiAgICBjYXNlICdhZnRlcm5vb24nOlxuICAgICAgcmV0dXJuIDEyO1xuXG4gICAgY2FzZSAnYW0nOlxuICAgIGNhc2UgJ21pZG5pZ2h0JzpcbiAgICBjYXNlICduaWdodCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih0d29EaWdpdFllYXIsIGN1cnJlbnRZZWFyKSB7XG4gIHZhciBpc0NvbW1vbkVyYSA9IGN1cnJlbnRZZWFyID4gMDsgLy8gQWJzb2x1dGUgbnVtYmVyIG9mIHRoZSBjdXJyZW50IHllYXI6XG4gIC8vIDEgLT4gMSBBQ1xuICAvLyAwIC0+IDEgQkNcbiAgLy8gLTEgLT4gMiBCQ1xuXG4gIHZhciBhYnNDdXJyZW50WWVhciA9IGlzQ29tbW9uRXJhID8gY3VycmVudFllYXIgOiAxIC0gY3VycmVudFllYXI7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKGFic0N1cnJlbnRZZWFyIDw9IDUwKSB7XG4gICAgcmVzdWx0ID0gdHdvRGlnaXRZZWFyIHx8IDEwMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmFuZ2VFbmQgPSBhYnNDdXJyZW50WWVhciArIDUwO1xuICAgIHZhciByYW5nZUVuZENlbnR1cnkgPSBNYXRoLmZsb29yKHJhbmdlRW5kIC8gMTAwKSAqIDEwMDtcbiAgICB2YXIgaXNQcmV2aW91c0NlbnR1cnkgPSB0d29EaWdpdFllYXIgPj0gcmFuZ2VFbmQgJSAxMDA7XG4gICAgcmVzdWx0ID0gdHdvRGlnaXRZZWFyICsgcmFuZ2VFbmRDZW50dXJ5IC0gKGlzUHJldmlvdXNDZW50dXJ5ID8gMTAwIDogMCk7XG4gIH1cblxuICByZXR1cm4gaXNDb21tb25FcmEgPyByZXN1bHQgOiAxIC0gcmVzdWx0O1xufVxuXG52YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbnZhciBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUiA9IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTsgLy8gVXNlciBmb3IgdmFsaWRhdGlvblxuXG5mdW5jdGlvbiBpc0xlYXBZZWFySW5kZXgoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwO1xufVxuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcbiAqIHwgIGIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgIHwgIEIgIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgIHxcbiAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGUgIHwgTG9jYWwgZGF5IG9mIHdlZWsgICAgICAgICAgICAgIHwgIEUgIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcbiAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcbiAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcbiAqIHwgIGsgIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgIHwgIEsgIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8qIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHEgIHwgU3RhbmQtYWxvbmUgcXVhcnRlciAgICAgICAgICAgIHwgIFEgIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHQhIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgIHwgIFQhIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgIHxcbiAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcbiAqIHwgIHcgIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgIHwgIFcqIHwgV2VlayBvZiBtb250aCAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcbiAqIHwgIHoqIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pIHwgIFoqIHwgVGltZXpvbmUgKGFsaWFzZXMpICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XG4gKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgcGFyc2VgIGRvY3MpXG4gKiAtIGBpYCBpcyBJU08gZGF5IG9mIHdlZWsuIEZvciBgaWAgYW5kIGBpaWAgaXMgcmV0dXJucyBudW1lcmljIElTTyB3ZWVrIGRheXMsXG4gKiAgIGkuZS4gNyBmb3IgU3VuZGF5LCAxIGZvciBNb25kYXksIGV0Yy5cbiAqIC0gYElgIGlzIElTTyB3ZWVrIG9mIHllYXIsIGFzIG9wcG9zZWQgdG8gYHdgIHdoaWNoIGlzIGxvY2FsIHdlZWsgb2YgeWVhci5cbiAqIC0gYFJgIGlzIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLCBhcyBvcHBvc2VkIHRvIGBZYCB3aGljaCBpcyBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyLlxuICogICBgUmAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBJYCBhbmQgYGlgXG4gKiAgIGZvciB1bml2ZXJzYWwgSVNPIHdlZWstbnVtYmVyaW5nIGRhdGUsIHdoZXJlYXNcbiAqICAgYFlgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgd2AgYW5kIGBlYFxuICogICBmb3Igd2Vlay1udW1iZXJpbmcgZGF0ZSBzcGVjaWZpYyB0byB0aGUgbG9jYWxlLlxuICovXG5cblxudmFyIHBhcnNlcnMgPSB7XG4gIC8vIEVyYVxuICBHOiB7XG4gICAgcHJpb3JpdHk6IDE0MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyBBRCwgQkNcbiAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgIGNhc2UgJ0dHJzpcbiAgICAgICAgY2FzZSAnR0dHJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gQSwgQlxuXG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XG5cbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93J1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZmxhZ3MuZXJhID0gdmFsdWU7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydSJywgJ3UnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gWWVhclxuICB5OiB7XG4gICAgLy8gRnJvbSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTMxL3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuICAgIC8vIHwgWWVhciAgICAgfCAgICAgeSB8IHl5IHwgICB5eXkgfCAgeXl5eSB8IHl5eXl5IHxcbiAgICAvLyB8LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAgLy8gfCBBRCAxICAgICB8ICAgICAxIHwgMDEgfCAgIDAwMSB8ICAwMDAxIHwgMDAwMDEgfFxuICAgIC8vIHwgQUQgMTIgICAgfCAgICAxMiB8IDEyIHwgICAwMTIgfCAgMDAxMiB8IDAwMDEyIHxcbiAgICAvLyB8IEFEIDEyMyAgIHwgICAxMjMgfCAyMyB8ICAgMTIzIHwgIDAxMjMgfCAwMDEyMyB8XG4gICAgLy8gfCBBRCAxMjM0ICB8ICAxMjM0IHwgMzQgfCAgMTIzNCB8ICAxMjM0IHwgMDEyMzQgfFxuICAgIC8vIHwgQUQgMTIzNDUgfCAxMjM0NSB8IDQ1IHwgMTIzNDUgfCAxMjM0NSB8IDEyMzQ1IHxcbiAgICBwcmlvcml0eTogMTMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBpc1R3b0RpZ2l0WWVhcjogdG9rZW4gPT09ICd5eSdcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyg0LCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgICAgIGNhc2UgJ3lvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd5ZWFyJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaXNUd29EaWdpdFllYXIgfHwgdmFsdWUueWVhciA+IDA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICAgIGlmICh2YWx1ZS5pc1R3b0RpZ2l0WWVhcikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFR3b0RpZ2l0WWVhciA9IG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih2YWx1ZS55ZWFyLCBjdXJyZW50WWVhcik7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIobm9ybWFsaXplZFR3b0RpZ2l0WWVhciwgMCwgMSk7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgeWVhciA9ICEoJ2VyYScgaW4gZmxhZ3MpIHx8IGZsYWdzLmVyYSA9PT0gMSA/IHZhbHVlLnllYXIgOiAxIC0gdmFsdWUueWVhcjtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3UnLCAndycsICdJJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgWToge1xuICAgIHByaW9yaXR5OiAxMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIGlzVHdvRGlnaXRZZWFyOiB0b2tlbiA9PT0gJ1lZJ1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKDQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICAgICAgY2FzZSAnWW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3llYXInLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pc1R3b0RpZ2l0WWVhciB8fCB2YWx1ZS55ZWFyID4gMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIGZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gZ2V0VVRDV2Vla1llYXIoZGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YWx1ZS5pc1R3b0RpZ2l0WWVhcikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFR3b0RpZ2l0WWVhciA9IG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih2YWx1ZS55ZWFyLCBjdXJyZW50WWVhcik7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIobm9ybWFsaXplZFR3b0RpZ2l0WWVhciwgMCwgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpO1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gISgnZXJhJyBpbiBmbGFncykgfHwgZmxhZ3MuZXJhID09PSAxID8gdmFsdWUueWVhciA6IDEgLSB2YWx1ZS55ZWFyO1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZVVENXZWVrKGRhdGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnUicsICd1JywgJ1EnLCAncScsICdNJywgJ0wnLCAnSScsICdkJywgJ0QnLCAnaScsICd0JywgJ1QnXVxuICB9LFxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICBSOiB7XG4gICAgcHJpb3JpdHk6IDEzMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gJ1InKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQoNCwgc3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChfZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBmaXJzdFdlZWtPZlllYXIgPSBuZXcgRGF0ZSgwKTtcbiAgICAgIGZpcnN0V2Vla09mWWVhci5zZXRVVENGdWxsWWVhcih2YWx1ZSwgMCwgNCk7XG4gICAgICBmaXJzdFdlZWtPZlllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ0lTT1dlZWsoZmlyc3RXZWVrT2ZZZWFyKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydHJywgJ3knLCAnWScsICd1JywgJ1EnLCAncScsICdNJywgJ0wnLCAndycsICdkJywgJ0QnLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEV4dGVuZGVkIHllYXJcbiAgdToge1xuICAgIHByaW9yaXR5OiAxMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBpZiAodG9rZW4gPT09ICd1Jykge1xuICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzU2lnbmVkKDQsIHN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQodG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIodmFsdWUsIDAsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ0cnLCAneScsICdZJywgJ1InLCAndycsICdJJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFF1YXJ0ZXJcbiAgUToge1xuICAgIHByaW9yaXR5OiAxMjAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgY2FzZSAnUVEnOlxuICAgICAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICAgIGNhc2UgJ1FvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICAgIGNhc2UgJ1FRUSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgICAgY2FzZSAnUVFRUVEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgICAgY2FzZSAnUVFRUSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdNJywgJ0wnLCAndycsICdJJywgJ2QnLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXG4gIHE6IHtcbiAgICBwcmlvcml0eTogMTIwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgIGNhc2UgJ3FxJzpcbiAgICAgICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgICBjYXNlICdxbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgICBjYXNlICdxcXEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICAgIGNhc2UgJ3FxcXFxJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICAgIGNhc2UgJ3FxcXEnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKCh2YWx1ZSAtIDEpICogMywgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ1EnLCAnTScsICdMJywgJ3cnLCAnSScsICdkJywgJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTW9udGhcbiAgTToge1xuICAgIHByaW9yaXR5OiAxMTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIDE7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLm1vbnRoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcblxuICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cygyLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgICAgY2FzZSAnTW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ21vbnRoJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICAgIGNhc2UgJ01NTU1NJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgICBjYXNlICdNTU1NJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgodmFsdWUsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdxJywgJ1EnLCAnTCcsICd3JywgJ0knLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBtb250aFxuICBMOiB7XG4gICAgcHJpb3JpdHk6IDExMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gMTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMSwgMiwgLi4uLCAxMlxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMubW9udGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuXG4gICAgICAgIGNhc2UgJ0xMJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKDIsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgICBjYXNlICdMbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnbW9udGgnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgICBjYXNlICdMTEwnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgICAgY2FzZSAnTExMTEwnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICAgIGNhc2UgJ0xMTEwnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNb250aCh2YWx1ZSwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnUScsICdNJywgJ3cnLCAnSScsICdEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIExvY2FsIHdlZWsgb2YgeWVhclxuICB3OiB7XG4gICAgcHJpb3JpdHk6IDEwMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMud2Vlaywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd3byc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1MztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdGFydE9mVVRDV2VlayhzZXRVVENXZWVrKGRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdSJywgJ3UnLCAncScsICdRJywgJ00nLCAnTCcsICdJJywgJ2QnLCAnRCcsICdpJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIElTTyB3ZWVrIG9mIHllYXJcbiAgSToge1xuICAgIHByaW9yaXR5OiAxMDAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLndlZWssIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnSW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNTM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ0lTT1dlZWsoc2V0VVRDSVNPV2VlayhkYXRlLCB2YWx1ZSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnWScsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAndycsICdkJywgJ0QnLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZDoge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuZGF0ZSwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdkbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF0ZSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgoeWVhcik7XG4gICAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG5cbiAgICAgIGlmIChpc0xlYXBZZWFyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSW21vbnRoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IERBWVNfSU5fTU9OVEhbbW9udGhdO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZSh2YWx1ZSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnUScsICd3JywgJ0knLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBEYXkgb2YgeWVhclxuICBEOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBjYXNlICdERCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmRheU9mWWVhciwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdEbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF0ZSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgoeWVhcik7XG5cbiAgICAgIGlmIChpc0xlYXBZZWFyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDM2NjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDM2NTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKDAsIHZhbHVlKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdRJywgJ00nLCAnTCcsICd3JywgJ0knLCAnZCcsICdFJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gVHVlXG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICBjYXNlICdFRSc6XG4gICAgICAgIGNhc2UgJ0VFRSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVFxuXG4gICAgICAgIGNhc2UgJ0VFRUVFJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1XG5cbiAgICAgICAgY2FzZSAnRUVFRUVFJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlc2RheVxuXG4gICAgICAgIGNhc2UgJ0VFRUUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBMb2NhbCBkYXkgb2Ygd2Vla1xuICBlOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB3aG9sZVdlZWtEYXlzID0gTWF0aC5mbG9vcigodmFsdWUgLSAxKSAvIDcpICogNztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSArIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgNikgJSA3ICsgd2hvbGVXZWVrRGF5cztcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gM1xuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnZWUnOlxuICAgICAgICAgIC8vIDAzXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDNyZFxuXG4gICAgICAgIGNhc2UgJ2VvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXknLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVcblxuICAgICAgICBjYXNlICdlZWUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRcblxuICAgICAgICBjYXNlICdlZWVlZSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdVxuXG4gICAgICAgIGNhc2UgJ2VlZWVlZSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgICBjYXNlICdlZWVlJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSBzZXRVVENEYXkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnUicsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAnSScsICdkJywgJ0QnLCAnRScsICdpJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcbiAgYzoge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgd2hvbGVXZWVrRGF5cyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gMSkgLyA3KSAqIDc7XG4gICAgICAgIHJldHVybiAodmFsdWUgKyBvcHRpb25zLndlZWtTdGFydHNPbiArIDYpICUgNyArIHdob2xlV2Vla0RheXM7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDNcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgICAvLyAwM1xuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAzcmRcblxuICAgICAgICBjYXNlICdjbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF5JyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlXG5cbiAgICAgICAgY2FzZSAnY2NjJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUXG5cbiAgICAgICAgY2FzZSAnY2NjY2MnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVcblxuICAgICAgICBjYXNlICdjY2NjY2MnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVzZGF5XG5cbiAgICAgICAgY2FzZSAnY2NjYyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gc2V0VVRDRGF5KGRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1InLCAndScsICdxJywgJ1EnLCAnTScsICdMJywgJ0knLCAnZCcsICdEJywgJ0UnLCAnaScsICdlJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIElTTyBkYXkgb2Ygd2Vla1xuICBpOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMlxuICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgY2FzZSAnaWknOlxuICAgICAgICAgIC8vIDAyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICAgIC8vIDJuZFxuXG4gICAgICAgIGNhc2UgJ2lvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZVxuXG4gICAgICAgIGNhc2UgJ2lpaSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVFxuXG4gICAgICAgIGNhc2UgJ2lpaWlpJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdVxuXG4gICAgICAgIGNhc2UgJ2lpaWlpaSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlc2RheVxuXG4gICAgICAgIGNhc2UgJ2lpaWknOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSBzZXRVVENJU09EYXkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnWScsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAndycsICdkJywgJ0QnLCAnRScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gQU0gb3IgUE1cbiAgYToge1xuICAgIHByaW9yaXR5OiA4MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgY2FzZSAnYWEnOlxuICAgICAgICBjYXNlICdhYWEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ2FhYWFhJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnYWFhYSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoZGF5UGVyaW9kRW51bVRvSG91cnModmFsdWUpLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2InLCAnQicsICdIJywgJ0snLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBBTSwgUE0sIG1pZG5pZ2h0XG4gIGI6IHtcbiAgICBwcmlvcml0eTogODAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnYic6XG4gICAgICAgIGNhc2UgJ2JiJzpcbiAgICAgICAgY2FzZSAnYmJiJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdiYmJiYic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ2JiYmInOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGRheVBlcmlvZEVudW1Ub0hvdXJzKHZhbHVlKSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ0InLCAnSCcsICdLJywgJ2snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuICBCOiB7XG4gICAgcHJpb3JpdHk6IDgwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0InOlxuICAgICAgICBjYXNlICdCQic6XG4gICAgICAgIGNhc2UgJ0JCQic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnQkJCQkInOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdCQkJCJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycyhkYXlQZXJpb2RFbnVtVG9Ib3Vycyh2YWx1ZSksIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdiJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGg6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIxMmgsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnaG8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMTI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGlzUE0gPSBkYXRlLmdldFVUQ0hvdXJzKCkgPj0gMTI7XG5cbiAgICAgIGlmIChpc1BNICYmIHZhbHVlIDwgMTIpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSArIDEyLCAwLCAwLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzUE0gJiYgdmFsdWUgPT09IDEyKSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlLCAwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnSCcsICdLJywgJ2snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSG91ciBbMC0yM11cbiAgSDoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuaG91cjIzaCwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdIbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnaG91cidcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAyMztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2EnLCAnYicsICdoJywgJ0snLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBIb3VyIFswLTExXVxuICBLOiB7XG4gICAgcHJpb3JpdHk6IDcwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMTFoLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ0tvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBpc1BNID0gZGF0ZS5nZXRVVENIb3VycygpID49IDEyO1xuXG4gICAgICBpZiAoaXNQTSAmJiB2YWx1ZSA8IDEyKSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUgKyAxMiwgMCwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlLCAwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdiJywgJ2gnLCAnSCcsICdrJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEhvdXIgWzEtMjRdXG4gIGs6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIyNGgsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAna28nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMjQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGhvdXJzID0gdmFsdWUgPD0gMjQgPyB2YWx1ZSAlIDI0IDogdmFsdWU7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGhvdXJzLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2EnLCAnYicsICdoJywgJ0gnLCAnSycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBNaW51dGVcbiAgbToge1xuICAgIHByaW9yaXR5OiA2MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMubWludXRlLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ21vJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdtaW51dGUnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNTk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNaW51dGVzKHZhbHVlLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFNlY29uZFxuICBzOiB7XG4gICAgcHJpb3JpdHk6IDUwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5zZWNvbmQsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnc28nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3NlY29uZCdcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA1OTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ1NlY29uZHModmFsdWUsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsndCcsICdUJ11cbiAgfSxcbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFM6IHtcbiAgICBwcmlvcml0eTogMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAqIE1hdGgucG93KDEwLCAtdG9rZW4ubGVuZ3RoICsgMykpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHModmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsndCcsICdUJ11cbiAgfSxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxLiArMDA6MDAgaXMgYCdaJ2ApXG4gIFg6IHtcbiAgICBwcmlvcml0eTogMTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxNaW51dGVzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ1hYJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpYywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdYWFhYJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsU2Vjb25kcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdYWFhYWCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWRPcHRpb25hbFNlY29uZHMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnWFhYJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIGZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGlmIChmbGFncy50aW1lc3RhbXBJc1NldCkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gdmFsdWUpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCcsICd4J11cbiAgfSxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxKVxuICB4OiB7XG4gICAgcHJpb3JpdHk6IDEwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsTWludXRlcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd4eCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAneHh4eCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbFNlY29uZHMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAneHh4eHgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3h4eCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWQsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBpZiAoZmxhZ3MudGltZXN0YW1wSXNTZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIHZhbHVlKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnLCAnWCddXG4gIH0sXG4gIC8vIFNlY29uZHMgdGltZXN0YW1wXG4gIHQ6IHtcbiAgICBwcmlvcml0eTogNDAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIF90b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHBhcnNlQW55RGlnaXRzU2lnbmVkKHN0cmluZyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChfZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbbmV3IERhdGUodmFsdWUgKiAxMDAwKSwge1xuICAgICAgICB0aW1lc3RhbXBJc1NldDogdHJ1ZVxuICAgICAgfV07XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6ICcqJ1xuICB9LFxuICAvLyBNaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gIFQ6IHtcbiAgICBwcmlvcml0eTogMjAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIF90b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHBhcnNlQW55RGlnaXRzU2lnbmVkKHN0cmluZyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChfZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbbmV3IERhdGUodmFsdWUpLCB7XG4gICAgICAgIHRpbWVzdGFtcElzU2V0OiB0cnVlXG4gICAgICB9XTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogJyonXG4gIH1cbn07XG5cbnZhciBUSU1FWk9ORV9VTklUX1BSSU9SSVRZID0gMTA7IC8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuXG52YXIgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxID0gL1t5WVFxTUx3SWREZWNpaEhLa21zXW98KFxcdylcXDEqfCcnfCcoJyd8W14nXSkrKCd8JCl8Li9nOyAvLyBUaGlzIFJlZ0V4cCBjYXRjaGVzIHN5bWJvbHMgZXNjYXBlZCBieSBxdW90ZXMsIGFuZCBhbHNvXG4vLyBzZXF1ZW5jZXMgb2Ygc3ltYm9scyBQLCBwLCBhbmQgdGhlIGNvbWJpbmF0aW9ucyBsaWtlIGBQUFBQUFBQcHBwcHBgXG5cbnZhciBsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxID0gL1ArcCt8UCt8cCt8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XG52YXIgZXNjYXBlZFN0cmluZ1JlZ0V4cCQxID0gL14nKC4qPyknPyQvO1xudmFyIGRvdWJsZVF1b3RlUmVnRXhwJDEgPSAvJycvZztcbnZhciBub3RXaGl0ZXNwYWNlUmVnRXhwID0gL1xcUy87XG52YXIgdW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAkMSA9IC9bYS16QS1aXS87XG4vKipcbiAqIEBuYW1lIHBhcnNlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFBhcnNlIHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBkYXRlIHBhcnNlZCBmcm9tIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZy5cbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXG4gKiA+IFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyBpbiB0aGUgZm9ybWF0IHN0cmluZyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqXG4gKiBGb3JtYXQgb2YgdGhlIGZvcm1hdCBzdHJpbmcgaXMgYmFzZWQgb24gVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0ZpZWxkX1N5bWJvbF9UYWJsZVxuICogd2l0aCBhIGZldyBhZGRpdGlvbnMgKHNlZSBub3RlIDUgYmVsb3cgdGhlIHRhYmxlKS5cbiAqXG4gKiBOb3QgYWxsIHRva2VucyBhcmUgY29tcGF0aWJsZS4gQ29tYmluYXRpb25zIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBvciBjb3VsZCBsZWFkIHRvIGJ1Z3MgYXJlIHByb2hpYml0ZWRcbiAqIGFuZCB3aWxsIHRocm93IGBSYW5nZUVycm9yYC4gRm9yIGV4YW1wbGUgdXNhZ2Ugb2YgMjQtaG91ciBmb3JtYXQgdG9rZW4gd2l0aCBBTS9QTSB0b2tlbiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwYXJzZSgnMjMgQU0nLCAnSEggYScsIG5ldyBEYXRlKCkpXG4gKiAvLz0+IFJhbmdlRXJyb3I6IFRoZSBmb3JtYXQgc3RyaW5nIG11c3RuJ3QgY29udGFpbiBgSEhgIGFuZCBgYWAgYXQgdGhlIHNhbWUgdGltZVxuICogYGBgXG4gKlxuICogU2VlIHRoZSBjb21wYXRpYmlsaXR5IHRhYmxlOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC9lLzJQQUNYLTF2UU9QVTN4VWhwbGxsNmR5b01tVlVYSEtsXzhDUkRzNl91ZUxtZXgzU29xd2h1b2xrdU4zTzA1bDRycXg1aDFkS1g4ZWI0NlVsLUNDU3JxL3B1Ymh0bWw/Z2lkPTAmc2luZ2xlPXRydWVcbiAqXG4gKiBBY2NlcHRlZCBmb3JtYXQgc3RyaW5nIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxQcmlvcnwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAxNDAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCAxMzAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcsIDk5OTkgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCA5OTk5OTk5dGggICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDEyMywgOTk5ICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCAxMzAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcsIDkwMDAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCA5OTk5OTk5dGggICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA0LDYgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDEyMywgOTk5ICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDQsNiAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCAxMzAgfCBSICAgICAgIHwgLTQzLCAxLCAxOTAwLCAyMDE3LCA5OTk5LCAtOTk5OSAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlIgICAgICB8IC00MywgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDEsIDEyMywgOTk5LCAtOTk5ICAgICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDEsIDIwMTcsIDk5OTksIC05OTk5ICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCw1IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IDEzMCB8IHUgICAgICAgfCAtNDMsIDEsIDE5MDAsIDIwMTcsIDk5OTksIC05OTkgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgOTksIC05OSAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTIzLCA5OTksIC05OTkgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMjAxNywgOTk5OSwgLTk5OTkgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgMTIwIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgMTIwIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgMTEwIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgMTEwIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgMTAwIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgMTAwIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgIDkwIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgIDkwIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCAgOTAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgIDkwIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8IDUgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8ICA5MCB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCAgOTAgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgIDgwIHwgYS4uYWFhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGFhYWEgICAgfCBhLm0uLCBwLm0uICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBhYWFhYSAgIHwgYSwgcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgIHwgIDgwIHwgYi4uYmJiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGJiYmIgICAgfCBhLm0uLCBwLm0uLCBub29uLCBtaWRuaWdodCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBiYmJiYiAgIHwgYSwgcCwgbiwgbWkgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgIHwgIDgwIHwgQi4uQkJCICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEJCQkIgICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBCQkJCQiAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgaCAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGhvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAxMnRoICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBoaCAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgSCAgICAgICB8IDAsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEhvICAgICAgfCAwdGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBISCAgICAgIHwgMDAsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgSyAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEtvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAwdGggICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBLSyAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgayAgICAgICB8IDI0LCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGtvICAgICAgfCAyNHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBrayAgICAgIHwgMjQsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIDYwIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IG1vICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBtbSAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIDUwIHwgcyAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHNvICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBzcyAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgIDQwIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHR0ICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCAgMzAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgIHwgIDIwIHwgVCAgICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFRUICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3LyBaKSAgICAgICAgfCAgMTAgfCBYICAgICAgIHwgLTA4LCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFggICAgICB8IC0wODAwLCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWCAgICAgfCAtMDg6MDAsICswNTozMCwgWiAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFhYICAgIHwgLTA4MDAsICswNTMwLCBaLCArMTIzNDU2ICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYWFggICB8IC0wODowMCwgKzA1OjMwLCBaLCArMTI6MzQ6NTYgICAgICB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgICB8ICAxMCB8IHggICAgICAgfCAtMDgsICswNTMwLCArMDAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eCAgICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4ICAgICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eHggICAgfCAtMDgwMCwgKzA1MzAsICswMDAwLCArMTIzNDU2ICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHh4eCAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCwgKzEyOjM0OjU2IHwgICAgICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgIE5BIHwgUCAgICAgICB8IDA1LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQICAgICAgfCBNYXkgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFAgICAgIHwgTWF5IDI5dGgsIDE0NTMgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQUCAgICB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgICAgICAgICAgICB8IDIsNSw4IHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8ICBOQSB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDb21iaW5hdGlvbiBvZiBkYXRlIGFuZCB0aW1lICAgIHwgIE5BIHwgUHAgICAgICB8IDA1LzI5LzE0NTMsIDEyOjAwIEFNICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQcHAgICAgfCBNYXkgMjksIDE0NTMsIDEyOjAwOjAwIEFNICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFBwcCAgIHwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQUHBwICB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICB8IDIsNSw4IHxcbiAqIE5vdGVzOlxuICogMS4gXCJGb3JtYXR0aW5nXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcbiAqICAgIGFyZSB0aGUgc2FtZSBhcyBcInN0YW5kLWFsb25lXCIgdW5pdHMsIGJ1dCBhcmUgZGlmZmVyZW50IGluIHNvbWUgbGFuZ3VhZ2VzLlxuICogICAgXCJGb3JtYXR0aW5nXCIgdW5pdHMgYXJlIGRlY2xpbmVkIGFjY29yZGluZyB0byB0aGUgcnVsZXMgb2YgdGhlIGxhbmd1YWdlXG4gKiAgICBpbiB0aGUgY29udGV4dCBvZiBhIGRhdGUuIFwiU3RhbmQtYWxvbmVcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXIuXG4gKiAgICBJbiBgZm9ybWF0YCBmdW5jdGlvbiwgdGhleSB3aWxsIHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdDpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogICAgYHBhcnNlYCB3aWxsIHRyeSB0byBtYXRjaCBib3RoIGZvcm1hdHRpbmcgYW5kIHN0YW5kLWFsb25lIHVuaXRzIGludGVyY2hhbmdhYmx5LlxuICpcbiAqIDIuIEFueSBzZXF1ZW5jZSBvZiB0aGUgaWRlbnRpY2FsIGxldHRlcnMgaXMgYSBwYXR0ZXJuLCB1bmxlc3MgaXQgaXMgZXNjYXBlZCBieVxuICogICAgdGhlIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIChzZWUgYmVsb3cpLlxuICogICAgSWYgdGhlIHNlcXVlbmNlIGlzIGxvbmdlciB0aGFuIGxpc3RlZCBpbiB0YWJsZTpcbiAqICAgIC0gZm9yIG51bWVyaWNhbCB1bml0cyAoYHl5eXl5eXl5YCkgYHBhcnNlYCB3aWxsIHRyeSB0byBtYXRjaCBhIG51bWJlclxuICogICAgICBhcyB3aWRlIGFzIHRoZSBzZXF1ZW5jZVxuICogICAgLSBmb3IgdGV4dCB1bml0cyAoYE1NTU1NTU1NYCkgYHBhcnNlYCB3aWxsIHRyeSB0byBtYXRjaCB0aGUgd2lkZXN0IHZhcmlhdGlvbiBvZiB0aGUgdW5pdC5cbiAqICAgICAgVGhlc2UgdmFyaWF0aW9ucyBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAzLiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA0LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIHdpbGwgdHJ5IHRvIGd1ZXNzIHRoZSBjZW50dXJ5IG9mIHR3byBkaWdpdCB5ZWFyIGJ5IHByb3hpbWl0eSB3aXRoIGBiYWNrdXBEYXRlYDpcbiAqXG4gKiAgICBgcGFyc2UoJzUwJywgJ3l5JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gU2F0IEphbiAwMSAyMDUwIDAwOjAwOjAwYFxuICpcbiAqICAgIGBwYXJzZSgnNzUnLCAneXknLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBXZWQgSmFuIDAxIDE5NzUgMDA6MDA6MDBgXG4gKlxuICogICAgd2hpbGUgYHV1YCB3aWxsIGp1c3QgYXNzaWduIHRoZSB5ZWFyIGFzIGlzOlxuICpcbiAqICAgIGBwYXJzZSgnNTAnLCAndXUnLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBTYXQgSmFuIDAxIDAwNTAgMDA6MDA6MDBgXG4gKlxuICogICAgYHBhcnNlKCc3NScsICd1dScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFR1ZSBKYW4gMDEgMDA3NSAwMDowMDowMGBcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtzZXRJU09XZWVrWWVhcl17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9zZXRJU09XZWVrWWVhcn1cbiAqICAgIGFuZCBbc2V0V2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3Mvc2V0V2Vla1llYXJ9KS5cbiAqXG4gKiA1LiBUaGVzZSBwYXR0ZXJucyBhcmUgbm90IGluIHRoZSBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiAgICAtIGBpYDogSVNPIGRheSBvZiB3ZWVrXG4gKiAgICAtIGBJYDogSVNPIHdlZWsgb2YgeWVhclxuICogICAgLSBgUmA6IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKiAgICAtIGBvYDogb3JkaW5hbCBudW1iZXIgbW9kaWZpZXJcbiAqICAgIC0gYFBgOiBsb25nIGxvY2FsaXplZCBkYXRlXG4gKiAgICAtIGBwYDogbG9uZyBsb2NhbGl6ZWQgdGltZVxuICpcbiAqIDYuIGBZWWAgYW5kIGBZWVlZYCB0b2tlbnMgcmVwcmVzZW50IHdlZWstbnVtYmVyaW5nIHllYXJzIGJ1dCB0aGV5IGFyZSBvZnRlbiBjb25mdXNlZCB3aXRoIHllYXJzLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICpcbiAqIDcuIGBEYCBhbmQgYEREYCB0b2tlbnMgcmVwcmVzZW50IGRheXMgb2YgdGhlIHllYXIgYnV0IHRoZXkgYXJlIG9mdGhlbiBjb25mdXNlZCB3aXRoIGRheXMgb2YgdGhlIG1vbnRoLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiA4LiBgUCtgIHRva2VucyBkbyBub3QgaGF2ZSBhIGRlZmluZWQgcHJpb3JpdHkgc2luY2UgdGhleSBhcmUgbWVyZWx5IGFsaWFzZXMgdG8gb3RoZXIgdG9rZW5zIGJhc2VkXG4gKiAgICBvbiB0aGUgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqICAgIHVzaW5nIGBlbi1VU2AgbG9jYWxlOiBgUGAgPT4gYE1NL2RkL3l5eXlgXG4gKiAgICB1c2luZyBgZW4tVVNgIGxvY2FsZTogYHBgID0+IGBoaDptbSBhYFxuICogICAgdXNpbmcgYHB0LUJSYCBsb2NhbGU6IGBQYCA9PiBgZGQvTU0veXl5eWBcbiAqICAgIHVzaW5nIGBwdC1CUmAgbG9jYWxlOiBgcGAgPT4gYEhIOm1tYFxuICpcbiAqIFZhbHVlcyB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBkYXRlIGluIHRoZSBkZXNjZW5kaW5nIG9yZGVyIG9mIGl0cyB1bml0J3MgcHJpb3JpdHkuXG4gKiBVbml0cyBvZiBhbiBlcXVhbCBwcmlvcml0eSBvdmVyd3JpdGUgZWFjaCBvdGhlciBpbiB0aGUgb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAqXG4gKiBJZiBubyB2YWx1ZXMgb2YgaGlnaGVyIHByaW9yaXR5IGFyZSBwYXJzZWQgKGUuZy4gd2hlbiBwYXJzaW5nIHN0cmluZyAnSmFudWFyeSAxc3QnIHdpdGhvdXQgYSB5ZWFyKSxcbiAqIHRoZSB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIDNyZCBhcmd1bWVudCBgYmFja3VwRGF0ZWAgd2hpY2ggd29ya3MgYXMgYSBjb250ZXh0IG9mIHBhcnNpbmcuXG4gKlxuICogYGJhY2t1cERhdGVgIG11c3QgYmUgcGFzc2VkIGZvciBjb3JyZWN0IHdvcmsgb2YgdGhlIGZ1bmN0aW9uLlxuICogSWYgeW91J3JlIG5vdCBzdXJlIHdoaWNoIGBiYWNrdXBEYXRlYCB0byBzdXBwbHksIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBEYXRlOlxuICogYHBhcnNlKCcwMi8xMS8yMDE0JywgJ01NL2RkL3l5eXknLCBuZXcgRGF0ZSgpKWBcbiAqIEluIHRoaXMgY2FzZSBwYXJzaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBkYXRlLlxuICogSWYgYGJhY2t1cERhdGVgIGlzIGBJbnZhbGlkIERhdGVgIG9yIGEgdmFsdWUgbm90IGNvbnZlcnRpYmxlIHRvIHZhbGlkIGBEYXRlYCxcbiAqIHRoZW4gYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBJZiBgZm9ybWF0U3RyaW5nYCBtYXRjaGVzIHdpdGggYGRhdGVTdHJpbmdgIGJ1dCBkb2VzIG5vdCBwcm92aWRlcyB0b2tlbnMsIGBiYWNrdXBEYXRlYCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIElmIHBhcnNpbmcgZmFpbGVkLCBgSW52YWxpZCBEYXRlYCB3aWxsIGJlIHJldHVybmVkLlxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gT2xkIGBwYXJzZWAgd2FzIHJlbmFtZWQgdG8gYHRvRGF0ZWAuXG4gKiAgIE5vdyBgcGFyc2VgIGlzIGEgbmV3IGZ1bmN0aW9uIHdoaWNoIHBhcnNlcyBhIHN0cmluZyB1c2luZyBhIHByb3ZpZGVkIGZvcm1hdC5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICogICBwYXJzZSgnMjAxNi0wMS0wMScpXG4gKlxuICogICAvLyB2Mi4wLjAgb253YXJkXG4gKiAgIHRvRGF0ZSgnMjAxNi0wMS0wMScpXG4gKiAgIHBhcnNlKCcyMDE2LTAxLTAxJywgJ3l5eXktTU0tZGQnLCBuZXcgRGF0ZSgpKVxuICogICBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0ZVN0cmluZyAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRTdHJpbmcgLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYmFja3VwRGF0ZSAtIGRlZmluZXMgdmFsdWVzIG1pc3NpbmcgZnJvbSB0aGUgcGFyc2VkIGRhdGVTdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gKiBAcGFyYW0gezB8MXwyfDN8NHw1fDZ9IFtvcHRpb25zLndlZWtTdGFydHNPbj0wXSAtIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwIC0gU3VuZGF5KVxuICogQHBhcmFtIHsxfDJ8M3w0fDV8Nnw3fSBbb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU9MV0gLSB0aGUgZGF5IG9mIEphbnVhcnksIHdoaWNoIGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyIHRva2VucyBgWVlgIGFuZCBgWVlZWWA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgdGhlIGRheSBvZiB5ZWFyIHRva2VucyBgRGAgYW5kIGBERGA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMyBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLndlZWtTdGFydHNPbmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDZcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDdcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBtYXRjaGAgcHJvcGVydHlcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnM7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgeXlgIGluc3RlYWQgb2YgYFlZYCBmb3IgZm9ybWF0dGluZyB5ZWFyczsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGBkZGAgaW5zdGVhZCBvZiBgRERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBmb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMTEgRmVicnVhcnkgMjAxNCBmcm9tIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IHBhcnNlKCcwMi8xMS8yMDE0JywgJ01NL2RkL3l5eXknLCBuZXcgRGF0ZSgpKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMjh0aCBvZiBGZWJydWFyeSBpbiBFc3BlcmFudG8gbG9jYWxlIGluIHRoZSBjb250ZXh0IG9mIDIwMTAgeWVhcjpcbiAqIGltcG9ydCBlbyBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gKiB2YXIgcmVzdWx0ID0gcGFyc2UoJzI4LWEgZGUgZmVicnVhcm8nLCBcImRvICdkZScgTU1NTVwiLCBuZXcgRGF0ZSgyMDEwLCAwLCAxKSwge1xuICogICBsb2NhbGU6IGVvXG4gKiB9KVxuICogLy89PiBTdW4gRmViIDI4IDIwMTAgMDA6MDA6MDBcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShkaXJ0eURhdGVTdHJpbmcsIGRpcnR5Rm9ybWF0U3RyaW5nLCBkaXJ0eUJhY2t1cERhdGUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCczIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlU3RyaW5nID0gU3RyaW5nKGRpcnR5RGF0ZVN0cmluZyk7XG4gIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcoZGlydHlGb3JtYXRTdHJpbmcpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSQxID0gb3B0aW9ucy5sb2NhbGUgfHwgbG9jYWxlO1xuXG4gIGlmICghbG9jYWxlJDEubWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBtYXRjaCBwcm9wZXJ0eScpO1xuICB9XG5cbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZSQxLm9wdGlvbnMgJiYgbG9jYWxlJDEub3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU7XG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyAxIDogdG9JbnRlZ2VyJDEobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyJDEob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUkMS5vcHRpb25zICYmIGxvY2FsZSQxLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlciQxKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlciQxKG9wdGlvbnMud2Vla1N0YXJ0c09uKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICBpZiAoZm9ybWF0U3RyaW5nID09PSAnJykge1xuICAgIGlmIChkYXRlU3RyaW5nID09PSAnJykge1xuICAgICAgcmV0dXJuIHRvRGF0ZShkaXJ0eUJhY2t1cERhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3ViRm5PcHRpb25zID0ge1xuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogZmlyc3RXZWVrQ29udGFpbnNEYXRlLFxuICAgIHdlZWtTdGFydHNPbjogd2Vla1N0YXJ0c09uLFxuICAgIGxvY2FsZTogbG9jYWxlJDEgLy8gSWYgdGltZXpvbmUgaXNuJ3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgc3lzdGVtIHRpbWV6b25lXG5cbiAgfTtcbiAgdmFyIHNldHRlcnMgPSBbe1xuICAgIHByaW9yaXR5OiBUSU1FWk9ORV9VTklUX1BSSU9SSVRZLFxuICAgIHNldDogZGF0ZVRvU3lzdGVtVGltZXpvbmUsXG4gICAgaW5kZXg6IDBcbiAgfV07XG4gIHZhciBpO1xuICB2YXIgdG9rZW5zID0gZm9ybWF0U3RyaW5nLm1hdGNoKGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwJDEpLm1hcChmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gc3Vic3RyaW5nWzBdO1xuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSAncCcgfHwgZmlyc3RDaGFyYWN0ZXIgPT09ICdQJykge1xuICAgICAgdmFyIGxvbmdGb3JtYXR0ZXIgPSBsb25nRm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG4gICAgICByZXR1cm4gbG9uZ0Zvcm1hdHRlcihzdWJzdHJpbmcsIGxvY2FsZSQxLmZvcm1hdExvbmcsIHN1YkZuT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnN0cmluZztcbiAgfSkuam9pbignJykubWF0Y2goZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxKTtcbiAgdmFyIHVzZWRUb2tlbnMgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VucyAmJiBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4odG9rZW4pKSB7XG4gICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2VucyAmJiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSkge1xuICAgICAgdGhyb3dQcm90ZWN0ZWRFcnJvcih0b2tlbik7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gdG9rZW5bMF07XG4gICAgdmFyIHBhcnNlciA9IHBhcnNlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuXG4gICAgaWYgKHBhcnNlcikge1xuICAgICAgdmFyIGluY29tcGF0aWJsZVRva2VucyA9IHBhcnNlci5pbmNvbXBhdGlibGVUb2tlbnM7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluY29tcGF0aWJsZVRva2VucykpIHtcbiAgICAgICAgdmFyIGluY29tcGF0aWJsZVRva2VuID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1c2VkVG9rZW5zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciB1c2VkVG9rZW4gPSB1c2VkVG9rZW5zW19pXS50b2tlbjtcblxuICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb2tlbnMuaW5kZXhPZih1c2VkVG9rZW4pICE9PSAtMSB8fCB1c2VkVG9rZW4gPT09IGZpcnN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBpbmNvbXBhdGlibGVUb2tlbiA9IHVzZWRUb2tlbnNbX2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY29tcGF0aWJsZVRva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gYFwiLmNvbmNhdChpbmNvbXBhdGlibGVUb2tlbi5mdWxsVG9rZW4sIFwiYCBhbmQgYFwiKS5jb25jYXQodG9rZW4sIFwiYCBhdCB0aGUgc2FtZSB0aW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZXIuaW5jb21wYXRpYmxlVG9rZW5zID09PSAnKicgJiYgdXNlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gYFwiLmNvbmNhdCh0b2tlbiwgXCJgIGFuZCBhbnkgb3RoZXIgdG9rZW4gYXQgdGhlIHNhbWUgdGltZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHVzZWRUb2tlbnMucHVzaCh7XG4gICAgICAgIHRva2VuOiBmaXJzdENoYXJhY3RlcixcbiAgICAgICAgZnVsbFRva2VuOiB0b2tlblxuICAgICAgfSk7XG4gICAgICB2YXIgcGFyc2VSZXN1bHQgPSBwYXJzZXIucGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIGxvY2FsZSQxLm1hdGNoLCBzdWJGbk9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgICAgfVxuXG4gICAgICBzZXR0ZXJzLnB1c2goe1xuICAgICAgICBwcmlvcml0eTogcGFyc2VyLnByaW9yaXR5LFxuICAgICAgICBzZXQ6IHBhcnNlci5zZXQsXG4gICAgICAgIHZhbGlkYXRlOiBwYXJzZXIudmFsaWRhdGUsXG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgaW5kZXg6IHNldHRlcnMubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGRhdGVTdHJpbmcgPSBwYXJzZVJlc3VsdC5yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIubWF0Y2godW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAkMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Zvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlciBgJyArIGZpcnN0Q2hhcmFjdGVyICsgJ2AnKTtcbiAgICAgIH0gLy8gUmVwbGFjZSB0d28gc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlclxuXG5cbiAgICAgIGlmICh0b2tlbiA9PT0gXCInJ1wiKSB7XG4gICAgICAgIHRva2VuID0gXCInXCI7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSBcIidcIikge1xuICAgICAgICB0b2tlbiA9IGNsZWFuRXNjYXBlZFN0cmluZyQxKHRva2VuKTtcbiAgICAgIH0gLy8gQ3V0IHRva2VuIGZyb20gc3RyaW5nLCBvciwgaWYgc3RyaW5nIGRvZXNuJ3QgbWF0Y2ggdGhlIHRva2VuLCByZXR1cm4gSW52YWxpZCBEYXRlXG5cblxuICAgICAgaWYgKGRhdGVTdHJpbmcuaW5kZXhPZih0b2tlbikgPT09IDApIHtcbiAgICAgICAgZGF0ZVN0cmluZyA9IGRhdGVTdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGUgcmVtYWluaW5nIGlucHV0IGNvbnRhaW5zIHNvbWV0aGluZyBvdGhlciB0aGFuIHdoaXRlc3BhY2VcblxuXG4gIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA+IDAgJiYgbm90V2hpdGVzcGFjZVJlZ0V4cC50ZXN0KGRhdGVTdHJpbmcpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICB2YXIgdW5pcXVlUHJpb3JpdHlTZXR0ZXJzID0gc2V0dGVycy5tYXAoZnVuY3Rpb24gKHNldHRlcikge1xuICAgIHJldHVybiBzZXR0ZXIucHJpb3JpdHk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGE7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocHJpb3JpdHksIGluZGV4LCBhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5pbmRleE9mKHByaW9yaXR5KSA9PT0gaW5kZXg7XG4gIH0pLm1hcChmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICByZXR1cm4gc2V0dGVycy5maWx0ZXIoZnVuY3Rpb24gKHNldHRlcikge1xuICAgICAgcmV0dXJuIHNldHRlci5wcmlvcml0eSA9PT0gcHJpb3JpdHk7XG4gICAgfSkucmV2ZXJzZSgpO1xuICB9KS5tYXAoZnVuY3Rpb24gKHNldHRlckFycmF5KSB7XG4gICAgcmV0dXJuIHNldHRlckFycmF5WzBdO1xuICB9KTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlCYWNrdXBEYXRlKTtcblxuICBpZiAoaXNOYU4oZGF0ZSkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfSAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzdcblxuXG4gIHZhciB1dGNEYXRlID0gc3ViTWlsbGlzZWNvbmRzKGRhdGUsIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGF0ZSkpO1xuICB2YXIgZmxhZ3MgPSB7fTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdW5pcXVlUHJpb3JpdHlTZXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNldHRlciA9IHVuaXF1ZVByaW9yaXR5U2V0dGVyc1tpXTtcblxuICAgIGlmIChzZXR0ZXIudmFsaWRhdGUgJiYgIXNldHRlci52YWxpZGF0ZSh1dGNEYXRlLCBzZXR0ZXIudmFsdWUsIHN1YkZuT3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzZXR0ZXIuc2V0KHV0Y0RhdGUsIGZsYWdzLCBzZXR0ZXIudmFsdWUsIHN1YkZuT3B0aW9ucyk7IC8vIFJlc3VsdCBpcyB0dXBsZSAoZGF0ZSwgZmxhZ3MpXG5cbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICB1dGNEYXRlID0gcmVzdWx0WzBdO1xuICAgICAgYXNzaWduJDEoZmxhZ3MsIHJlc3VsdFsxXSk7IC8vIFJlc3VsdCBpcyBkYXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0Y0RhdGUgPSByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0Y0RhdGU7XG59XG5cbmZ1bmN0aW9uIGRhdGVUb1N5c3RlbVRpbWV6b25lKGRhdGUsIGZsYWdzKSB7XG4gIGlmIChmbGFncy50aW1lc3RhbXBJc1NldCkge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlZERhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgY29udmVydGVkRGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBjb252ZXJ0ZWREYXRlLnNldEhvdXJzKGRhdGUuZ2V0VVRDSG91cnMoKSwgZGF0ZS5nZXRVVENNaW51dGVzKCksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLCBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpKTtcbiAgcmV0dXJuIGNvbnZlcnRlZERhdGU7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyQxKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5tYXRjaChlc2NhcGVkU3RyaW5nUmVnRXhwJDEpWzFdLnJlcGxhY2UoZG91YmxlUXVvdGVSZWdFeHAkMSwgXCInXCIpO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIkMSA9IDM2MDAwMDA7XG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSQyID0gNjAwMDA7XG52YXIgREVGQVVMVF9BRERJVElPTkFMX0RJR0lUUyA9IDI7XG52YXIgcGF0dGVybnMgPSB7XG4gIGRhdGVUaW1lRGVsaW1pdGVyOiAvW1QgXS8sXG4gIHRpbWVab25lRGVsaW1pdGVyOiAvW1ogXS9pLFxuICB0aW1lem9uZTogLyhbWistXS4qKSQvXG59O1xudmFyIGRhdGVSZWdleCA9IC9eLT8oPzooXFxkezN9KXwoXFxkezJ9KSg/Oi0/KFxcZHsyfSkpP3xXKFxcZHsyfSkoPzotPyhcXGR7MX0pKT98KSQvO1xudmFyIHRpbWVSZWdleCA9IC9eKFxcZHsyfSg/OlsuLF1cXGQqKT8pKD86Oj8oXFxkezJ9KD86Wy4sXVxcZCopPykpPyg/Ojo/KFxcZHsyfSg/OlsuLF1cXGQqKT8pKT8kLztcbnZhciB0aW1lem9uZVJlZ2V4ID0gL14oWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyQvO1xuLyoqXG4gKiBAbmFtZSBwYXJzZUlTT1xuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBQYXJzZSBJU08gc3RyaW5nXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGluIElTTyA4NjAxIGZvcm1hdCBhbmQgcmV0dXJuIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogRnVuY3Rpb24gYWNjZXB0cyBjb21wbGV0ZSBJU08gODYwMSBmb3JtYXRzIGFzIHdlbGwgYXMgcGFydGlhbCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJU08gODYwMTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpc24ndCBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIGNhbm5vdCBwYXJzZSB0aGUgc3RyaW5nIG9yXG4gKiB0aGUgdmFsdWVzIGFyZSBpbnZhbGlkLCBpdCByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gVGhlIHByZXZpb3VzIGBwYXJzZWAgaW1wbGVtZW50YXRpb24gd2FzIHJlbmFtZWQgdG8gYHBhcnNlSVNPYC5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICogICBwYXJzZSgnMjAxNi0wMS0wMScpXG4gKlxuICogICAvLyB2Mi4wLjAgb253YXJkXG4gKiAgIHBhcnNlSVNPKCcyMDE2LTAxLTAxJylcbiAqICAgYGBgXG4gKlxuICogLSBgcGFyc2VJU09gIG5vdyB2YWxpZGF0ZXMgc2VwYXJhdGUgZGF0ZSBhbmQgdGltZSB2YWx1ZXMgaW4gSVNPLTg2MDEgc3RyaW5nc1xuICogICBhbmQgcmV0dXJucyBgSW52YWxpZCBEYXRlYCBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkLlxuICpcbiAqICAgYGBgamF2YXNjcmlwdFxuICogICBwYXJzZUlTTygnMjAxOC0xMy0zMicpXG4gKiAgIC8vPT4gSW52YWxpZCBEYXRlXG4gKiAgIGBgYFxuICpcbiAqIC0gYHBhcnNlSVNPYCBub3cgZG9lc24ndCBmYWxsIGJhY2sgdG8gYG5ldyBEYXRlYCBjb25zdHJ1Y3RvclxuICogICBpZiBpdCBmYWlscyB0byBwYXJzZSBhIHN0cmluZyBhcmd1bWVudC4gSW5zdGVhZCwgaXQgcmV0dXJucyBgSW52YWxpZCBEYXRlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBwYXJzZUlTTygnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxuICogLy8gaWYgdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXQgaXMgMTpcbiAqIHZhciByZXN1bHQgPSBwYXJzZUlTTygnKzAyMDE0MTAxJywgeyBhZGRpdGlvbmFsRGlnaXRzOiAxIH0pXG4gKiAvLz0+IEZyaSBBcHIgMTEgMjAxNCAwMDowMDowMFxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSVNPKGFyZ3VtZW50LCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgYWRkaXRpb25hbERpZ2l0cyA9IG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyA9PSBudWxsID8gREVGQVVMVF9BRERJVElPTkFMX0RJR0lUUyA6IHRvSW50ZWdlciQxKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XG5cbiAgaWYgKGFkZGl0aW9uYWxEaWdpdHMgIT09IDIgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMSAmJiBhZGRpdGlvbmFsRGlnaXRzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2FkZGl0aW9uYWxEaWdpdHMgbXVzdCBiZSAwLCAxIG9yIDInKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICB2YXIgZGF0ZVN0cmluZ3MgPSBzcGxpdERhdGVTdHJpbmcoYXJndW1lbnQpO1xuICB2YXIgZGF0ZTtcblxuICBpZiAoZGF0ZVN0cmluZ3MuZGF0ZSkge1xuICAgIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XG4gICAgZGF0ZSA9IHBhcnNlRGF0ZShwYXJzZVllYXJSZXN1bHQucmVzdERhdGVTdHJpbmcsIHBhcnNlWWVhclJlc3VsdC55ZWFyKTtcbiAgfVxuXG4gIGlmIChpc05hTihkYXRlKSB8fCAhZGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG5cbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICB2YXIgdGltZSA9IDA7XG4gIHZhciBvZmZzZXQ7XG5cbiAgaWYgKGRhdGVTdHJpbmdzLnRpbWUpIHtcbiAgICB0aW1lID0gcGFyc2VUaW1lKGRhdGVTdHJpbmdzLnRpbWUpO1xuXG4gICAgaWYgKGlzTmFOKHRpbWUpIHx8IHRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lem9uZSkge1xuICAgIG9mZnNldCA9IHBhcnNlVGltZXpvbmUoZGF0ZVN0cmluZ3MudGltZXpvbmUpO1xuXG4gICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZnVsbFRpbWUgPSB0aW1lc3RhbXAgKyB0aW1lO1xuICAgIHZhciBmdWxsVGltZURhdGUgPSBuZXcgRGF0ZShmdWxsVGltZSk7XG4gICAgb2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhmdWxsVGltZURhdGUpOyAvLyBBZGp1c3QgdGltZSB3aGVuIGl0J3MgY29taW5nIGZyb20gRFNUXG5cbiAgICB2YXIgZnVsbFRpbWVEYXRlTmV4dERheSA9IG5ldyBEYXRlKGZ1bGxUaW1lKTtcbiAgICBmdWxsVGltZURhdGVOZXh0RGF5LnNldERhdGUoZnVsbFRpbWVEYXRlLmdldERhdGUoKSArIDEpO1xuICAgIHZhciBvZmZzZXREaWZmID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhmdWxsVGltZURhdGVOZXh0RGF5KSAtIG9mZnNldDtcblxuICAgIGlmIChvZmZzZXREaWZmID4gMCkge1xuICAgICAgb2Zmc2V0ICs9IG9mZnNldERpZmY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcoZGF0ZVN0cmluZykge1xuICB2YXIgZGF0ZVN0cmluZ3MgPSB7fTtcbiAgdmFyIGFycmF5ID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy5kYXRlVGltZURlbGltaXRlcik7XG4gIHZhciB0aW1lU3RyaW5nO1xuXG4gIGlmICgvOi8udGVzdChhcnJheVswXSkpIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gbnVsbDtcbiAgICB0aW1lU3RyaW5nID0gYXJyYXlbMF07XG4gIH0gZWxzZSB7XG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGFycmF5WzBdO1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVsxXTtcblxuICAgIGlmIChwYXR0ZXJucy50aW1lWm9uZURlbGltaXRlci50ZXN0KGRhdGVTdHJpbmdzLmRhdGUpKSB7XG4gICAgICBkYXRlU3RyaW5ncy5kYXRlID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy50aW1lWm9uZURlbGltaXRlcilbMF07XG4gICAgICB0aW1lU3RyaW5nID0gZGF0ZVN0cmluZy5zdWJzdHIoZGF0ZVN0cmluZ3MuZGF0ZS5sZW5ndGgsIGRhdGVTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGltZVN0cmluZykge1xuICAgIHZhciB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lLmV4ZWModGltZVN0cmluZyk7XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nLnJlcGxhY2UodG9rZW5bMV0sICcnKTtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gdG9rZW5bMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlU3RyaW5ncztcbn1cblxuZnVuY3Rpb24gcGFyc2VZZWFyKGRhdGVTdHJpbmcsIGFkZGl0aW9uYWxEaWdpdHMpIHtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OihcXFxcZHs0fXxbKy1dXFxcXGR7JyArICg0ICsgYWRkaXRpb25hbERpZ2l0cykgKyAnfSl8KFxcXFxkezJ9fFsrLV1cXFxcZHsnICsgKDIgKyBhZGRpdGlvbmFsRGlnaXRzKSArICd9KSQpJyk7XG4gIHZhciBjYXB0dXJlcyA9IGRhdGVTdHJpbmcubWF0Y2gocmVnZXgpOyAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuXG4gIGlmICghY2FwdHVyZXMpIHJldHVybiB7XG4gICAgeWVhcjogbnVsbFxuICB9O1xuICB2YXIgeWVhciA9IGNhcHR1cmVzWzFdICYmIHBhcnNlSW50KGNhcHR1cmVzWzFdKTtcbiAgdmFyIGNlbnR1cnkgPSBjYXB0dXJlc1syXSAmJiBwYXJzZUludChjYXB0dXJlc1syXSk7XG4gIHJldHVybiB7XG4gICAgeWVhcjogY2VudHVyeSA9PSBudWxsID8geWVhciA6IGNlbnR1cnkgKiAxMDAsXG4gICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoKGNhcHR1cmVzWzFdIHx8IGNhcHR1cmVzWzJdKS5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyaW5nLCB5ZWFyKSB7XG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIGlmICh5ZWFyID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNhcHR1cmVzID0gZGF0ZVN0cmluZy5tYXRjaChkYXRlUmVnZXgpOyAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgc3RyaW5nXG5cbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIG51bGw7XG4gIHZhciBpc1dlZWtEYXRlID0gISFjYXB0dXJlc1s0XTtcbiAgdmFyIGRheU9mWWVhciA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbMV0pO1xuICB2YXIgbW9udGggPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzJdKSAtIDE7XG4gIHZhciBkYXkgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzNdKTtcbiAgdmFyIHdlZWsgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzRdKTtcbiAgdmFyIGRheU9mV2VlayA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbNV0pIC0gMTtcblxuICBpZiAoaXNXZWVrRGF0ZSkge1xuICAgIGlmICghdmFsaWRhdGVXZWVrRGF0ZSh5ZWFyLCB3ZWVrLCBkYXlPZldlZWspKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5T2ZJU09XZWVrWWVhcih5ZWFyLCB3ZWVrLCBkYXlPZldlZWspO1xuICB9IGVsc2Uge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoMCk7XG5cbiAgICBpZiAoIXZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSB8fCAhdmFsaWRhdGVEYXlPZlllYXJEYXRlKHllYXIsIGRheU9mWWVhcikpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cblxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIE1hdGgubWF4KGRheU9mWWVhciwgZGF5KSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlVW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyBwYXJzZUludCh2YWx1ZSkgOiAxO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWUodGltZVN0cmluZykge1xuICB2YXIgY2FwdHVyZXMgPSB0aW1lU3RyaW5nLm1hdGNoKHRpbWVSZWdleCk7XG4gIGlmICghY2FwdHVyZXMpIHJldHVybiBudWxsOyAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgdGltZVxuXG4gIHZhciBob3VycyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMV0pO1xuICB2YXIgbWludXRlcyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMl0pO1xuICB2YXIgc2Vjb25kcyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbM10pO1xuXG4gIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gaG91cnMgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiQxICsgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMiArIHNlY29uZHMgKiAxMDAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWVVbml0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiBwYXJzZUZsb2F0KHZhbHVlLnJlcGxhY2UoJywnLCAnLicpKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWV6b25lKHRpbWV6b25lU3RyaW5nKSB7XG4gIGlmICh0aW1lem9uZVN0cmluZyA9PT0gJ1onKSByZXR1cm4gMDtcbiAgdmFyIGNhcHR1cmVzID0gdGltZXpvbmVTdHJpbmcubWF0Y2godGltZXpvbmVSZWdleCk7XG4gIGlmICghY2FwdHVyZXMpIHJldHVybiAwO1xuICB2YXIgc2lnbiA9IGNhcHR1cmVzWzFdID09PSAnKycgPyAtMSA6IDE7XG4gIHZhciBob3VycyA9IHBhcnNlSW50KGNhcHR1cmVzWzJdKTtcbiAgdmFyIG1pbnV0ZXMgPSBjYXB0dXJlc1szXSAmJiBwYXJzZUludChjYXB0dXJlc1szXSkgfHwgMDtcblxuICBpZiAoIXZhbGlkYXRlVGltZXpvbmUoaG91cnMsIG1pbnV0ZXMpKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHJldHVybiBzaWduICogKGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIkMSArIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDIpO1xufVxuXG5mdW5jdGlvbiBkYXlPZklTT1dlZWtZZWFyKGlzb1dlZWtZZWFyLCB3ZWVrLCBkYXkpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29XZWVrWWVhciwgMCwgNCk7XG4gIHZhciBmb3VydGhPZkphbnVhcnlEYXkgPSBkYXRlLmdldFVUQ0RheSgpIHx8IDc7XG4gIHZhciBkaWZmID0gKHdlZWsgLSAxKSAqIDcgKyBkYXkgKyAxIC0gZm91cnRoT2ZKYW51YXJ5RGF5O1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIGRhdGU7XG59IC8vIFZhbGlkYXRpb24gZnVuY3Rpb25zXG4vLyBGZWJydWFyeSBpcyBudWxsIHRvIGhhbmRsZSB0aGUgbGVhcCB5ZWFyICh1c2luZyB8fClcblxuXG52YXIgZGF5c0luTW9udGhzID0gWzMxLCBudWxsLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXJJbmRleCQxKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gIHJldHVybiBtb250aCA+PSAwICYmIG1vbnRoIDw9IDExICYmIGRhdGUgPj0gMSAmJiBkYXRlIDw9IChkYXlzSW5Nb250aHNbbW9udGhdIHx8IChpc0xlYXBZZWFySW5kZXgkMSh5ZWFyKSA/IDI5IDogMjgpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXlPZlllYXJEYXRlKHllYXIsIGRheU9mWWVhcikge1xuICByZXR1cm4gZGF5T2ZZZWFyID49IDEgJiYgZGF5T2ZZZWFyIDw9IChpc0xlYXBZZWFySW5kZXgkMSh5ZWFyKSA/IDM2NiA6IDM2NSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2Vla0RhdGUoX3llYXIsIHdlZWssIGRheSkge1xuICByZXR1cm4gd2VlayA+PSAxICYmIHdlZWsgPD0gNTMgJiYgZGF5ID49IDAgJiYgZGF5IDw9IDY7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICBpZiAoaG91cnMgPT09IDI0KSB7XG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgJiYgc2Vjb25kcyA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiBzZWNvbmRzID49IDAgJiYgc2Vjb25kcyA8IDYwICYmIG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDwgNjAgJiYgaG91cnMgPj0gMCAmJiBob3VycyA8IDI1O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWV6b25lKF9ob3VycywgbWludXRlcykge1xuICByZXR1cm4gbWludXRlcyA+PSAwICYmIG1pbnV0ZXMgPD0gNTk7XG59XG5cbnZhciBwYXJzZURhdGUkMSA9IGZ1bmN0aW9uIHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0KSB7XG4gIGlmIChpc1N0cmluZ18xKHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXQgPyBwYXJzZSh2YWx1ZSwgZm9ybWF0LCBuZXcgRGF0ZSgpKSA6IHBhcnNlSVNPKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9EYXRlKHZhbHVlKTtcbiAgfVxufTsgLy8gV2Ugd2FudCB0byBzZXQgdGhlIG1lc3NhZ2VzIGEgc3VwZXJnbG9iYWwgc28gdGhhdCBpbXBvcnRzIGFjcm9zcyBmaWxlc1xuLy8gcmVmZXJlbmNlIHRoZSBzYW1lIG1lc3NhZ2VzIG9iamVjdC5cblxuXG52YXIgX2dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsIHx8IHt9O1xuLyoqXG4gKiBHbG9iYWwgdmFsaWRhdGlvbiBtZXNzYWdlIHJlZ2lzdHJ5LlxuICovXG5cblxudmFyIG1lc3NhZ2VzID0gX2dsb2JhbC5fX3Z1ZW1jX3ZhbGlkYXRpb25fbWVzc2FnZXMgPSBfZ2xvYmFsLl9fdnVlbWNfdmFsaWRhdGlvbl9tZXNzYWdlcyB8fCBuZXcgKFxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyBldmVyeXRoaW5nIHRvIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLiRsb2NhbGUgPSAnZW4tdXMnO1xuICAgICAgdGhpcy4kZmFsbGJhY2sgPSAnZW4tdXMnO1xuICAgICAgdGhpcy4kbG9jYWxlcyA9IHt9O1xuICAgICAgdGhpcy5yZWdpc3Rlcihlbl91cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxlKF9sb2NhbGUpIHtcbiAgICAgIHRoaXMuJGxvY2FsZSA9IHRvTG93ZXJfMShfbG9jYWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbGFuZ3VhZ2UgcGFjay5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKGJ1bmRsZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGxvY2FsZSA9IHRvTG93ZXJfMShidW5kbGUubG9jYWxlKTtcbiAgICAgIGVhY2goZ2V0XzEoYnVuZGxlLCAnbWVzc2FnZXMnLCB7fSksIGZ1bmN0aW9uIChtZXNzYWdlLCBuYW1lKSB7XG4gICAgICAgIHNldF8xKF90aGlzLiRsb2NhbGVzLCBbbG9jYWxlLCBuYW1lXSwgdGVtcGxhdGVfMShtZXNzYWdlKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgb3IgYWRkcyBhIG5ldyBtZXNzYWdlIGZvciBhIGdpdmVuIG5hbWUgYW5kIG9wdGlvbmFsIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lLCBmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgdmFyICR0ZW1wbGF0ZSA9IGlzU3RyaW5nXzEoZm9ybWF0KSA/IHRlbXBsYXRlXzEoZm9ybWF0KSA6IGZvcm1hdDsgLy8gVXNlIHRoZSBnaXZlbiBsb2NhbGUuXG5cbiAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgc2V0XzEodGhpcy4kbG9jYWxlcywgW2xvY2FsZSwgbmFtZV0sICR0ZW1wbGF0ZSk7IC8vIE90aGVyd2lzZSB1c2UgdGhlIGFjdGl2ZSBsb2NhbGUuXG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy4kbG9jYWxlKSB7XG4gICAgICAgIHNldF8xKHRoaXMuJGxvY2FsZXMsIFt0aGlzLiRsb2NhbGUsIG5hbWVdLCAkdGVtcGxhdGUpOyAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGxvY2FsZS5cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0XzEodGhpcy4kbG9jYWxlcywgW3RoaXMuJGZhbGxiYWNrLCBuYW1lXSwgJHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgZm9yIGEgZ2l2ZW4gbWVzc2FnZSBuYW1lIGFuZCBjb250ZXh0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgLy8gQXR0ZW1wdCB0byBmaW5kIHRoZSBuYW1lIHVzaW5nIHRoZSBhY3RpdmUgbG9jYWxlLCBmYWxsaW5nIGJhY2sgdG8gdGhlXG4gICAgICAvLyBhY3RpdmUgbG9jYWxlJ3MgbGFuZ3VhZ2UsIGFuZCBmaW5hbGx5IGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdC5cbiAgICAgIHZhciB0ZW1wbGF0ZSA9IGdldF8xKHRoaXMuJGxvY2FsZXMsIFt0aGlzLiRsb2NhbGUsIG5hbWVdLCBnZXRfMSh0aGlzLiRsb2NhbGVzLCBbc3BsaXRfMSh0aGlzLiRsb2NhbGUsICctJylbMF0sIG5hbWVdLCBnZXRfMSh0aGlzLiRsb2NhbGVzLCBbdGhpcy4kZmFsbGJhY2ssIG5hbWVdKSkpOyAvLyBGYWxsIGJhY2sgdG8gYSBibGFuayBzdHJpbmcgc28gdGhhdCB3ZSBkb24ndCBwb3RlbnRpYWxseVxuICAgICAgLy8gbGVhayBtZXNzYWdlIG5hbWVzIG9yIGNvbnRleHQgZGF0YSBpbnRvIHRoZSB0ZW1wbGF0ZS5cblxuXG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfY2xhc3M7XG59KCkpKCk7XG4vKipcbiAqIFJ1bGUgaGVscGVycyBmb3IgZWFzeSB2YWxpZGF0aW9uLlxuICogVGhlc2UgY2FuIGFsbCBiZSB1c2VkIGRpcmVjdGx5IGluIGEgbW9kZWwncyB2YWxpZGF0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQge2FzY2lpLCBsZW5ndGh9IGZyb20gJ3Z1ZS1tYy92YWxpZGF0aW9uJ1xuICpcbiAqIGNsYXNzIFVzZXIgZXh0ZW5kcyBNb2RlbCB7XG4gKiAgICAgdmFsaWRhdGlvbigpIHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICAgIHBhc3N3b3JkOiBhc2NpaS5hbmQobGVuZ3RoKDYpKSxcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqIH1cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmFsaWRhdGlvbiBydWxlLlxuICpcbiAqIFJ1bGVzIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gY2FuIGJlIGNoYWluZWQgd2l0aCBgb3JgIGFuZCBgYW5kYC5cbiAqIEZvciBleGFtcGxlOiBgcnVsZUEub3IocnVsZUIuYW5kKFJ1bGVDKSkuYW5kKFJ1bGVEKWBcbiAqXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBjYW4gYmUgc2V0IG9yIHJlcGxhY2VkIHVzaW5nIGBmb3JtYXQobWVzc2FnZXx0ZW1wbGF0ZSlgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWc6XG4gKiAgICAgLSBuYW1lOiBOYW1lIG9mIHRoZSBlcnJvciBtZXNzYWdlLlxuICogICAgIC0gZGF0YTogQ29udGV4dCBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gKiAgICAgLSB0ZXN0OiBGdW5jdGlvbiBhY2NlcHRpbmcgKHZhbHVlLCBtb2RlbCksIHdoaWNoIHNob3VsZFxuICogICAgICAgICAgICAgcmV0dXJuIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdmFsaWQuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBWYWxpZGF0aW9uIHJ1bGUuXG4gKi9cblxudmFyIHJ1bGUgPSBmdW5jdGlvbiBydWxlKGNvbmZpZykge1xuICB2YXIgbmFtZSA9IGdldF8xKGNvbmZpZywgJ25hbWUnKTtcblxuICB2YXIgZGF0YSA9IGdldF8xKGNvbmZpZywgJ2RhdGEnLCB7fSk7XG5cbiAgdmFyIHRlc3QgPSBnZXRfMShjb25maWcsICd0ZXN0Jywgc3R1YlRydWVfMSk7XG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHVzaW5nIHRoaXMgcnVsZS5cbiAgICogSXQgaGFzIHNvbWUgZXh0cmEgbWV0YWRhdGEgdG8gYWxsb3cgcnVsZSBjaGFpbmluZyBhbmQgY3VzdG9tIGZvcm1hdHMuXG4gICAqL1xuXG5cbiAgdmFyICRydWxlID0gZnVuY3Rpb24gJHJ1bGUodmFsdWUsIGF0dHJpYnV0ZSwgbW9kZWwpIHtcbiAgICAvLyBgdHJ1ZWAgaWYgdGhpcyBydWxlJ3MgY29yZSBhY2NlcHRhbmNlIGNyaXRlcmlhIHdhcyBtZXQuXG4gICAgdmFyIHZhbGlkID0gdGVzdCh2YWx1ZSwgYXR0cmlidXRlLCBtb2RlbCk7IC8vIElmIHZhbGlkLCBjaGVjayB0aGF0IGFsbCBydWxlcyBpbiB0aGUgXCJhbmRcIiBjaGFpbiBhbHNvIHBhc3MuXG5cbiAgICBpZiAodmFsaWQpIHtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSAkcnVsZS5fYW5kW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfYW5kID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gX2FuZCh2YWx1ZSwgYXR0cmlidXRlLCBtb2RlbCk7IC8vIElmIGFueSBvZiB0aGUgY2hhaW5lZCBydWxlcyByZXR1cm4gYSBzdHJpbmcsIHdlIGtub3cgdGhhdFxuICAgICAgICAgIC8vIHRoYXQgcnVsZSBoYXMgZmFpbGVkLCBhbmQgdGhlcmVmb3JlIHRoaXMgY2hhaW4gaXMgaW52YWxpZC5cblxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nXzEocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRWl0aGVyIHRoZXJlIHdlcmVuJ3QgYW55IFwiYW5kXCIgcnVsZXMgb3IgdGhleSBhbGwgcGFzc2VkLlxuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvcltcInJldHVyblwiXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3JbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7IC8vIFRoaXMgcnVsZSdzIGFjY2VwdGFuY2UgY3JpdGVyaWEgd2FzIG5vdCBtZXQsIGJ1dCB0aGVyZSBpcyBhIGNoYW5jZVxuICAgICAgLy8gdGhhdCBhIHJ1bGUgaW4gdGhlIFwib3JcIiBjaGFpbidzIG1pZ2h0IHBhc3MuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gJHJ1bGUuX29yW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9vciA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVzdWx0ID0gX29yKHZhbHVlLCBhdHRyaWJ1dGUsIG1vZGVsKTsgLy8gQSBydWxlIHNob3VsZCBlaXRoZXIgcmV0dXJuIHRydWUgaW4gdGhlIGV2ZW50IG9mIGEgZ2VuZXJhbFxuICAgICAgICAgIC8vIFwicGFzc1wiLCBvciBub3RoaW5nIGF0IGFsbC4gQSBmYWlsdXJlIHdvdWxkIGhhdmUgdG8gYmUgYVxuICAgICAgICAgIC8vIHN0cmluZyBtZXNzYWdlICh1c3VhbGx5IGZyb20gYW5vdGhlciBydWxlKS5cblxuXG4gICAgICAgICAgaWYgKF9yZXN1bHQgPT09IHRydWUgfHwgaXNVbmRlZmluZWRfMShfcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjJbXCJyZXR1cm5cIl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMltcInJldHVyblwiXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBdCB0aGlzIHBvaW50IHdlIHdhbnQgdG8gcmVwb3J0IHRoYXQgdGhpcyBydWxlIGhhcyBmYWlsZWQsIGJlY2F1c2VcbiAgICAvLyBub25lIG9mIHRoZSBcImFuZFwiIG9yIFwib3JcIiBjaGFpbnMgcGFzc2VkIGVpdGhlci5cbiAgICAvLyBBZGQgdGhlIGludmFsaWQgdmFsdWUgdG8gdGhlIG1lc3NhZ2UgY29udGV4dCwgd2hpY2ggaXMgbWFkZSBhdmFpbGFibGVcbiAgICAvLyB0byBhbGwgcnVsZXMgYnkgZGVmYXVsdC4gVGhpcyBhbGxvd3MgZm9yICR7dmFsdWV9IGludGVycG9sYXRpb24uXG5cblxuICAgIGFzc2lnbl8xKGRhdGEsIHtcbiAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7IC8vIFRoaXMgd291bGQgYmUgYSBjdXN0b20gZm9ybWF0IGV4cGxpY2l0bHkgc2V0IG9uIHRoaXMgcnVsZS5cblxuICAgIHZhciBmb3JtYXQgPSBnZXRfMSgkcnVsZSwgJ19mb3JtYXQnKTsgLy8gVXNlIHRoZSBkZWZhdWx0IG1lc3NhZ2UgaWYgYW4gZXhwbGljaXQgZm9ybWF0IGlzbid0IHNldC5cblxuXG4gICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlcy5nZXQobmFtZSwgZGF0YSk7XG4gICAgfSAvLyBSZXBsYWNlIHRoZSBjdXN0b20gZm9ybWF0IHdpdGggYSB0ZW1wbGF0ZSBpZiBpdCdzIHN0aWxsIGEgc3RyaW5nLlxuXG5cbiAgICBpZiAoaXNTdHJpbmdfMShmb3JtYXQpKSB7XG4gICAgICAkcnVsZS5fZm9ybWF0ID0gZm9ybWF0ID0gdGVtcGxhdGVfMShmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQoZGF0YSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgY29weSBvZiB0aGlzIHJ1bGUsIHNvIHRoYXQgYXBwZW5kaW5nIHRvIGEgY2hhaW4gb3JcbiAgICogICAgICAgICAgICAgICAgICAgICBzZXR0aW5nIGEgY3VzdG9tIGZvcm1hdCBkb2Vzbid0IG1vZGlmeSB0aGUgYmFzZSBydWxlLlxuICAgKi9cblxuXG4gICRydWxlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbl8xKHJ1bGUoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSksIHBpY2tfMSgkcnVsZSwgWydfZm9ybWF0JywgJ19hbmQnLCAnX29yJ10pKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZSBmb3JtYXQgb24gdGhpcyBydWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gZm9ybWF0XG4gICAqL1xuXG5cbiAgJHJ1bGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiBhc3NpZ25fMSgkcnVsZS5jb3B5KCksIHtcbiAgICAgIF9mb3JtYXQ6IGZvcm1hdFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQWRkcyBhbm90aGVyIHJ1bGUgb3IgZnVuY3Rpb24gdG8gdGhpcyBydWxlJ3MgT1IgY2hhaW4uIElmIHRoZSBnaXZlbiBydWxlXG4gICAqIHBhc3NlcyB3aGVuIHRoaXMgb25lIGZhaWxzLCB0aGlzIHJ1bGUgd2lsbCByZXR1cm4gYHRydWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119IHJ1bGVzIE9uZSBvciBtb3JlIGZ1bmN0aW9ucyB0byBhZGQgdG8gdGhlIGNoYWluLlxuICAgKi9cblxuXG4gICRydWxlLm9yID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgcmV0dXJuIGFzc2lnbl8xKCRydWxlLmNvcHkoKSwge1xuICAgICAgX29yOiBjb25jYXRfMSgkcnVsZS5fb3IsIHJ1bGVzKVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQWRkcyBhbm90aGVyIHJ1bGUgb3IgZnVuY3Rpb24gdG8gdGhpcyBydWxlJ3MgQU5EIGNoYWluLiBJZiB0aGUgZ2l2ZW4gcnVsZVxuICAgKiBmYWlscyB3aGVuIHRoaXMgb25lIHBhc3NlcywgdGhpcyBydWxlIHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gcnVsZXMgT25lIG9yIG1vcmUgZnVuY3Rpb25zIHRvIGFkZCB0byB0aGUgY2hhaW4uXG4gICAqL1xuXG5cbiAgJHJ1bGUuYW5kID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgcmV0dXJuIGFzc2lnbl8xKCRydWxlLmNvcHkoKSwge1xuICAgICAgX2FuZDogY29uY2F0XzEoJHJ1bGUuX2FuZCwgcnVsZXMpXG4gICAgfSk7XG4gIH07XG5cbiAgJHJ1bGUuX2FuZCA9IFtdOyAvLyBcImFuZFwiIGNoYWluXG5cbiAgJHJ1bGUuX29yID0gW107IC8vIFwib3JcIiBjaGFpblxuXG4gICRydWxlLl9mb3JtYXQgPSBudWxsOyAvLyBDdXN0b20gZm9ybWF0XG5cbiAgcmV0dXJuICRydWxlO1xufTtcbi8qKlxuICogQVZBSUxBQkxFIFJVTEVTXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFmdGVyIGEgZ2l2ZW4gZGF0ZSBzdHJpbmcgb3IgYERhdGVgIG9iamVjdC5cbiAqL1xuXG52YXIgYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihkYXRlKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnYWZ0ZXInLFxuICAgIGRhdGE6IHtcbiAgICAgIGRhdGU6IGRhdGVcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FmdGVyKHBhcnNlRGF0ZSQxKHZhbHVlKSwgcGFyc2VEYXRlJDEoZGF0ZSkpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBvbmx5IGhhcyBsZXR0ZXJzLlxuICovXG5cbnZhciBhbHBoYSA9IHJ1bGUoe1xuICBuYW1lOiAnYWxwaGEnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzQWxwaGEoZGVidXJyXzEodmFsdWUpKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIG9ubHkgaGFzIGxldHRlcnMgb3IgbnVtYmVycy5cbiAqL1xuXG52YXIgYWxwaGFudW1lcmljID0gcnVsZSh7XG4gIG5hbWU6ICdhbHBoYW51bWVyaWMnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzQWxwaGFudW1lcmljKGRlYnVycl8xKHZhbHVlKSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheS5cbiAqL1xuXG52YXIgYXJyYXkgPSBydWxlKHtcbiAgbmFtZTogJ2FycmF5JyxcbiAgdGVzdDogaXNBcnJheV8xXG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgY29uc2lzdGluZyBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMuXG4gKi9cblxudmFyIGFzY2lpID0gcnVsZSh7XG4gIG5hbWU6ICdhc2NpaScsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgL15bXFx4MDAtXFx4N0ZdKyQvLnRlc3QodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBCYXNlNjQgc3RyaW5nLlxuICovXG5cbnZhciBiYXNlNjQgPSBydWxlKHtcbiAgbmFtZTogJ2Jhc2U2NCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNCYXNlNjQodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYmVmb3JlIGEgZ2l2ZW4gZGF0ZSBzdHJpbmcgb3IgYERhdGVgIG9iamVjdC5cbiAqL1xuXG52YXIgYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGRhdGUpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdiZWZvcmUnLFxuICAgIGRhdGE6IHtcbiAgICAgIGRhdGU6IGRhdGVcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0JlZm9yZShwYXJzZURhdGUkMSh2YWx1ZSksIHBhcnNlRGF0ZSQxKGRhdGUpKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYmV0d2VlbiBhIGdpdmVuIG1pbmltdW0gb3IgbWF4aW11bSwgaW5jbHVzaXZlIGJ5IGRlZmF1bHQuXG4gKi9cblxudmFyIGJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKG1pbiwgbWF4KSB7XG4gIHZhciBpbmNsdXNpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgdmFyIF9taW4gPSArKGlzU3RyaW5nXzEobWluKSA/IHBhcnNlRGF0ZSQxKG1pbikgOiBtaW4pO1xuXG4gIHZhciBfbWF4ID0gKyhpc1N0cmluZ18xKG1heCkgPyBwYXJzZURhdGUkMShtYXgpIDogbWF4KTtcblxuICByZXR1cm4gcnVsZSh7XG4gICAgZGF0YToge1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH0sXG4gICAgbmFtZTogaW5jbHVzaXZlID8gJ2JldHdlZW5faW5jbHVzaXZlJyA6ICdiZXR3ZWVuJyxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICB2YXIgX3ZhbHVlID0gKyhpc1N0cmluZ18xKHZhbHVlKSA/IHBhcnNlRGF0ZSQxKHZhbHVlKSA6IHZhbHVlKTtcblxuICAgICAgcmV0dXJuIGluY2x1c2l2ZSA/IGd0ZV8xKF92YWx1ZSwgX21pbikgJiYgbHRlXzEoX3ZhbHVlLCBfbWF4KSA6IGd0XzEoX3ZhbHVlLCBfbWluKSAmJiBsdF8xKF92YWx1ZSwgX21heCk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgYm9vbGVhbiAoc3RyaWN0bHkgdHJ1ZSBvciBmYWxzZSkuXG4gKi9cblxudmFyIF9ib29sZWFuID0gcnVsZSh7XG4gIG5hbWU6ICdib29sZWFuJyxcbiAgdGVzdDogaXNCb29sZWFuXzFcbn0pO1xudmFyIGNyZWRpdGNhcmQgPSBydWxlKHtcbiAgbmFtZTogJ2NyZWRpdGNhcmQnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzQ3JlZGl0Q2FyZCh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBwYXJzZWFibGUgYXMgYSBkYXRlLlxuICovXG5cbnZhciBkYXRlID0gcnVsZSh7XG4gIG5hbWU6ICdkYXRlJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1ZhbGlkKHBhcnNlRGF0ZSQxKHZhbHVlKSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBtYXRjaGVzIHRoZSBnaXZlbiBkYXRlIGZvcm1hdC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGF0ZS1mbnMub3JnL3YyLjAuMC1hbHBoYS45L2RvY3MvZm9ybWF0XG4gKi9cblxudmFyIGRhdGVmb3JtYXQgPSBmdW5jdGlvbiBkYXRlZm9ybWF0KGZvcm1hdCQxKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnZGF0ZWZvcm1hdCcsXG4gICAgZGF0YToge1xuICAgICAgZm9ybWF0OiBmb3JtYXQkMVxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQocGFyc2VEYXRlJDEodmFsdWUudG9TdHJpbmcoKSwgZm9ybWF0JDEpKSAmJiBmb3JtYXQocGFyc2VEYXRlJDEodmFsdWUudG9TdHJpbmcoKSwgZm9ybWF0JDEpLCBmb3JtYXQkMSkgPT09IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYFxuICovXG5cbnZhciBkZWZpbmVkID0gcnVsZSh7XG4gIG5hbWU6ICdkZWZpbmVkJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiAhaXNVbmRlZmluZWRfMSh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gKi9cblxudmFyIGVtYWlsID0gcnVsZSh7XG4gIG5hbWU6ICdlbWFpbCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNFbWFpbCh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgdmFsdWUgaXMgY29uc2lkZXJlZCBlbXB0eS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzLyNpc0VtcHR5XG4gKi9cblxudmFyIGVtcHR5ID0gcnVsZSh7XG4gIG5hbWU6ICdlbXB0eScsXG4gIHRlc3Q6IGlzRW1wdHlfMVxufSk7XG4vKipcbiAqIEFsaWFzIGZvciBgZXF1YWxzYFxuICovXG5cbnZhciBlcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKG90aGVyKSB7XG4gIHJldHVybiBlcXVhbHMob3RoZXIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgZXF1YWxzIHRoZSBnaXZlbiB2YWx1ZS5cbiAqL1xuXG52YXIgZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnZXF1YWxzJyxcbiAgICBkYXRhOiB7XG4gICAgICBvdGhlcjogb3RoZXJcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0VxdWFsXzEodmFsdWUsIG90aGVyKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIGEgZ2l2ZW4gbWluaW11bS5cbiAqL1xuXG52YXIgZ3QkMSA9IGZ1bmN0aW9uIGd0KG1pbikge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2d0JyxcbiAgICBkYXRhOiB7XG4gICAgICBtaW46IG1pblxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGd0XzEodmFsdWUsIG1pbik7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBhIGdpdmVuIG1pbmltdW0uXG4gKi9cblxudmFyIGd0ZSQxID0gZnVuY3Rpb24gZ3RlKG1pbikge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2d0ZScsXG4gICAgZGF0YToge1xuICAgICAgbWluOiBtaW5cbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBndGVfMSh2YWx1ZSwgbWluKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuXG52YXIgaW50ZWdlciA9IHJ1bGUoe1xuICBuYW1lOiAnaW50ZWdlcicsXG4gIHRlc3Q6IGlzSW50ZWdlcl8xXG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBJUCBhZGRyZXNzLlxuICovXG5cbnZhciBpcCA9IHJ1bGUoe1xuICBuYW1lOiAnaXAnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzSVAodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB6ZXJvLWxlbmd0aCBzdHJpbmcuXG4gKi9cblxudmFyIGlzYmxhbmsgPSBydWxlKHtcbiAgbmFtZTogJ2lzYmxhbmsnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJztcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqL1xuXG52YXIgaXNuaWwgPSBydWxlKHtcbiAgbmFtZTogJ2lzbmlsJyxcbiAgdGVzdDogaXNOaWxfMVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGBudWxsYC5cbiAqL1xuXG52YXIgaXNudWxsID0gcnVsZSh7XG4gIG5hbWU6ICdpc251bGwnLFxuICB0ZXN0OiBpc051bGxfMVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgSVNPODYwMSBkYXRlIHN0cmluZy5cbiAqL1xuXG52YXIgaXNvODYwMSA9IHJ1bGUoe1xuICBuYW1lOiAnaXNvODYwMScsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNJU084NjAxKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIHZhbGlkIEpTT04uXG4gKi9cblxudmFyIGpzb24gPSBydWxlKHtcbiAgbmFtZTogJ2pzb24nLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzSlNPTih2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSdzIGxlbmd0aCBpcyBhdCBsZWFzdCBhIGdpdmVuIG1pbmltdW0sIGFuZCBubyBtb3JlIHRoYW4gYW5cbiAqIG9wdGlvbmFsIG1heGltdW0uXG4gKlxuICogQHNlZSBodHRwczovL2xvZGFzaC5jb20vZG9jcy8jdG9MZW5ndGhcbiAqL1xuXG52YXIgbGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKG1pbiwgbWF4KSB7XG4gIC8vIE5vIG1heGltdW0gbWVhbnMgdGhlIHZhbHVlIG11c3QgYmUgKmF0IGxlYXN0KiB0aGUgbWluaW11bS5cbiAgaWYgKGlzVW5kZWZpbmVkXzEobWF4KSkge1xuICAgIHJldHVybiBydWxlKHtcbiAgICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgICAgZGF0YToge1xuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXhcbiAgICAgIH0sXG4gICAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzaXplXzEodmFsdWUpID49IG1pbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBNaW5pbXVtIGFuZCBtYXhpbXVtIGdpdmVuLCBzbyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyB3aXRoaW4gdGhlIHJhbmdlLlxuXG5cbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdsZW5ndGhfYmV0d2VlbicsXG4gICAgZGF0YToge1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHNpemVfMSh2YWx1ZSk7XG4gICAgICByZXR1cm4gbGVuZ3RoID49IG1pbiAmJiBsZW5ndGggPD0gbWF4O1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBsZXNzIHRoYW4gYSBnaXZlbiBtYXhpbXVtLlxuICovXG5cbnZhciBsdCQxID0gZnVuY3Rpb24gbHQobWF4KSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnbHQnLFxuICAgIGRhdGE6IHtcbiAgICAgIG1heDogbWF4XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gbHRfMSh2YWx1ZSwgbWF4KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGEgZ2l2ZW4gbWF4aW11bS5cbiAqL1xuXG52YXIgbHRlJDEgPSBmdW5jdGlvbiBsdGUobWF4KSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnbHRlJyxcbiAgICBkYXRhOiB7XG4gICAgICBtYXg6IG1heFxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGx0ZV8xKHZhbHVlLCBtYXgpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIHN0cmluZyBvciBSZWdFeHAuXG4gKi9cblxudmFyIG1hdGNoJDEgPSBmdW5jdGlvbiBtYXRjaChwYXR0ZXJuKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnbWF0Y2gnLFxuICAgIGRhdGE6IHtcbiAgICAgIHBhdHRlcm46IHBhdHRlcm5cbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4pLnRlc3QodmFsdWUpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBBbGlhcyBmb3IgYGx0ZWAuXG4gKi9cblxudmFyIG1heCA9IGZ1bmN0aW9uIG1heChfbWF4Mikge1xuICByZXR1cm4gbHRlJDEoX21heDIpO1xufTtcbi8qKlxuICogQWxpYXMgZm9yIGBndGVgLlxuICovXG5cbnZhciBtaW4gPSBmdW5jdGlvbiBtaW4oX21pbjIpIHtcbiAgcmV0dXJuIGd0ZSQxKF9taW4yKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICovXG5cbnZhciBuZWdhdGl2ZSA9IHJ1bGUoe1xuICBuYW1lOiAnbmVnYXRpdmUnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyXzEodmFsdWUpIDwgMDtcbiAgfVxufSk7XG4vKipcbiAqXG4gKi9cblxudmFyIG5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ25vdCcsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICFpbmNsdWRlc18xKHZhbHVlcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciAoaW50ZWdlciBvciBmbG9hdCksIGV4Y2x1ZGluZyBgTmFOYC5cbiAqL1xuXG52YXIgbnVtYmVyID0gcnVsZSh7XG4gIG5hbWU6ICdudW1iZXInLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9pc0Zpbml0ZSh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBvciBudW1lcmljIHN0cmluZywgZXhjbHVkaW5nIGBOYU5gLlxuICovXG5cbnZhciBudW1lcmljID0gcnVsZSh7XG4gIG5hbWU6ICdudW1lcmljJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc051bWJlcl8xKHZhbHVlKSAmJiAhX2lzTmFOKHZhbHVlKSB8fCB2YWx1ZSAmJiBpc1N0cmluZ18xKHZhbHVlKSAmJiAhX2lzTmFOKHRvTnVtYmVyXzEodmFsdWUpKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGFuIG9iamVjdCwgZXhjbHVkaW5nIGFycmF5cyBhbmQgZnVuY3Rpb25zLlxuICovXG5cbnZhciBvYmplY3QgPSBydWxlKHtcbiAgbmFtZTogJ29iamVjdCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3RfMSh2YWx1ZSkgJiYgIWlzQXJyYXlfMSh2YWx1ZSkgJiYgIWlzRnVuY3Rpb25fMSh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBwb3NpdGl2ZS5cbiAqL1xuXG52YXIgcG9zaXRpdmUgPSBydWxlKHtcbiAgbmFtZTogJ3Bvc2l0aXZlJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiB0b051bWJlcl8xKHZhbHVlKSA+IDA7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBwcmVzZW50LCBpZS4gbm90IGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yIGEgYmxhbmsgc3RyaW5nLlxuICovXG5cbnZhciByZXF1aXJlZCA9IHJ1bGUoe1xuICBuYW1lOiAncmVxdWlyZWQnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICEoaXNOaWxfMSh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGVxdWFscyBhbm90aGVyIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG5cbnZhciBzYW1lID0gZnVuY3Rpb24gc2FtZShvdGhlcikge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ3NhbWUnLFxuICAgIGRhdGE6IHtcbiAgICAgIG90aGVyOiBvdGhlclxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSwgYXR0cmlidXRlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIGlzRXF1YWxfMSh2YWx1ZSwgbW9kZWwuZ2V0KG90aGVyKSk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5cbnZhciBzdHJpbmcgPSBydWxlKHtcbiAgbmFtZTogJ3N0cmluZycsXG4gIHRlc3Q6IGlzU3RyaW5nXzFcbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIFVSTCBzdHJpbmcuXG4gKi9cblxudmFyIHVybCA9IHJ1bGUoe1xuICBuYW1lOiAndXJsJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc1VSTCh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIFVVSUQuXG4gKi9cblxudmFyIHV1aWQgPSBydWxlKHtcbiAgbmFtZTogJ3V1aWQnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzVVVJRCh2YWx1ZSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmFmdGVyID0gYWZ0ZXI7XG5leHBvcnRzLmFscGhhID0gYWxwaGE7XG5leHBvcnRzLmFscGhhbnVtZXJpYyA9IGFscGhhbnVtZXJpYztcbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmV4cG9ydHMuYXNjaWkgPSBhc2NpaTtcbmV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuZXhwb3J0cy5iZWZvcmUgPSBiZWZvcmU7XG5leHBvcnRzLmJldHdlZW4gPSBiZXR3ZWVuO1xuZXhwb3J0cy5ib29sZWFuID0gX2Jvb2xlYW47XG5leHBvcnRzLmNyZWRpdGNhcmQgPSBjcmVkaXRjYXJkO1xuZXhwb3J0cy5kYXRlID0gZGF0ZTtcbmV4cG9ydHMuZGF0ZWZvcm1hdCA9IGRhdGVmb3JtYXQ7XG5leHBvcnRzLmRlZmluZWQgPSBkZWZpbmVkO1xuZXhwb3J0cy5lbWFpbCA9IGVtYWlsO1xuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLmd0ID0gZ3QkMTtcbmV4cG9ydHMuZ3RlID0gZ3RlJDE7XG5leHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyO1xuZXhwb3J0cy5pcCA9IGlwO1xuZXhwb3J0cy5pc2JsYW5rID0gaXNibGFuaztcbmV4cG9ydHMuaXNuaWwgPSBpc25pbDtcbmV4cG9ydHMuaXNudWxsID0gaXNudWxsO1xuZXhwb3J0cy5pc284NjAxID0gaXNvODYwMTtcbmV4cG9ydHMuanNvbiA9IGpzb247XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubHQgPSBsdCQxO1xuZXhwb3J0cy5sdGUgPSBsdGUkMTtcbmV4cG9ydHMubWF0Y2ggPSBtYXRjaCQxO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubmVnYXRpdmUgPSBuZWdhdGl2ZTtcbmV4cG9ydHMubm90ID0gbm90O1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5leHBvcnRzLm51bWVyaWMgPSBudW1lcmljO1xuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG5leHBvcnRzLnBvc2l0aXZlID0gcG9zaXRpdmU7XG5leHBvcnRzLnJlcXVpcmVkID0gcmVxdWlyZWQ7XG5leHBvcnRzLnJ1bGUgPSBydWxlO1xuZXhwb3J0cy5zYW1lID0gc2FtZTtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZXhwb3J0cy51cmwgPSB1cmw7XG5leHBvcnRzLnV1aWQgPSB1dWlkO1xuIixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsXSwibmFtZXMiOlsiTW9kZWwiLCJ0b051bWJlciIsIkNvbGxlY3Rpb24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImVuX3VzIiwibG9jYWxlIiwibWVzc2FnZXMiLCJhZnRlciIsImFscGhhIiwiYWxwaGFudW1lcmljIiwiYXJyYXkiLCJhc2NpaSIsImJhc2U2NCIsImJlZm9yZSIsImJldHdlZW4iLCJiZXR3ZWVuX2luY2x1c2l2ZSIsImNyZWRpdGNhcmQiLCJkYXRlIiwiZGF0ZWZvcm1hdCIsImRlZmluZWQiLCJlbWFpbCIsImVtcHR5IiwiZXF1YWxzIiwiZ3QiLCJndGUiLCJpbnRlZ2VyIiwiaXAiLCJpc2JsYW5rIiwiaXNuaWwiLCJpc251bGwiLCJpc284NjAxIiwianNvbiIsImxlbmd0aF9iZXR3ZWVuIiwibHQiLCJsdGUiLCJtYXRjaCIsIm5lZ2F0aXZlIiwibm90IiwibnVtYmVyIiwibnVtZXJpYyIsIm9iamVjdCIsInBvc2l0aXZlIiwicmVxdWlyZWQiLCJzYW1lIiwic3RyaW5nIiwidXJsIiwidXVpZCIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJ1bndyYXBFeHBvcnRzIiwieCIsIl9fZXNNb2R1bGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsImZuIiwibW9kdWxlIiwiZXhwb3J0cyIsImFzc2VydFN0cmluZ18xIiwiYXNzZXJ0U3RyaW5nIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIl90eXBlb2YyIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsImlucHV0IiwiaXNTdHJpbmciLCJTdHJpbmciLCJpbnZhbGlkVHlwZSIsIm5hbWUiLCJjb25jYXQiLCJhbHBoYV8xIiwiY29tbWFEZWNpbWFsIiwiZG90RGVjaW1hbCIsImFyYWJpY0xvY2FsZXMiLCJlbmdsaXNoTG9jYWxlcyIsImRlY2ltYWwiLCJhciIsIl9sb2NhbGUiLCJfaSIsIl9pMiIsIl9pMyIsImlzQWxwaGFfMSIsImlzQWxwaGEiLCJsb2NhbGVzIiwiX2Fzc2VydFN0cmluZyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJzdHIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ0ZXN0IiwiRXJyb3IiLCJrZXlzIiwiaXNBbHBoYW51bWVyaWNfMSIsImlzQWxwaGFudW1lcmljIiwiaXNCYXNlNjRfMSIsImlzQmFzZTY0Iiwibm90QmFzZTY0IiwibGVuIiwiZmlyc3RQYWRkaW5nQ2hhciIsImluZGV4T2YiLCJpc0NyZWRpdENhcmRfMSIsImlzQ3JlZGl0Q2FyZCIsImNyZWRpdENhcmQiLCJzYW5pdGl6ZWQiLCJyZXBsYWNlIiwic3VtIiwiZGlnaXQiLCJ0bXBOdW0iLCJzaG91bGREb3VibGUiLCJzdWJzdHJpbmciLCJwYXJzZUludCIsIm1lcmdlXzEiLCJtZXJnZSIsImRlZmF1bHRzIiwiaXNCeXRlTGVuZ3RoXzEiLCJpc0J5dGVMZW5ndGgiLCJvcHRpb25zIiwibWluIiwibWF4IiwiZW5jb2RlVVJJIiwic3BsaXQiLCJpc0ZRRE5fMSIsImlzRlFETiIsIl9tZXJnZSIsImRlZmF1bHRfZnFkbl9vcHRpb25zIiwicmVxdWlyZV90bGQiLCJhbGxvd191bmRlcnNjb3JlcyIsImFsbG93X3RyYWlsaW5nX2RvdCIsInBhcnRzIiwidGxkIiwicG9wIiwicGFydCIsImlzSVBfMSIsImlzSVAiLCJpcHY0TWF5YmUiLCJpcHY2QmxvY2siLCJ2ZXJzaW9uIiwic29ydCIsImEiLCJiIiwiYmxvY2tzIiwiZm91bmRPbWlzc2lvbkJsb2NrIiwiZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrIiwiZXhwZWN0ZWROdW1iZXJPZkJsb2NrcyIsInN1YnN0ciIsInNoaWZ0IiwiaXNFbWFpbF8xIiwiaXNFbWFpbCIsIl9pc0J5dGVMZW5ndGgiLCJfaXNGUUROIiwiX2lzSVAiLCJkZWZhdWx0X2VtYWlsX29wdGlvbnMiLCJhbGxvd19kaXNwbGF5X25hbWUiLCJyZXF1aXJlX2Rpc3BsYXlfbmFtZSIsImFsbG93X3V0ZjhfbG9jYWxfcGFydCIsImRpc3BsYXlOYW1lIiwiZW1haWxVc2VyUGFydCIsImdtYWlsVXNlclBhcnQiLCJxdW90ZWRFbWFpbFVzZXIiLCJlbWFpbFVzZXJVdGY4UGFydCIsInF1b3RlZEVtYWlsVXNlclV0ZjgiLCJkaXNwbGF5X2VtYWlsIiwiZG9tYWluIiwidXNlciIsImpvaW4iLCJsb3dlcl9kb21haW4iLCJ0b0xvd2VyQ2FzZSIsImRvbWFpbl9zcGVjaWZpY192YWxpZGF0aW9uIiwidXNlcm5hbWUiLCJfdXNlcl9wYXJ0cyIsImFsbG93X2lwX2RvbWFpbiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsIm5vQnJhY2tldGRvbWFpbiIsInNsaWNlIiwicGF0dGVybiIsInVzZXJfcGFydHMiLCJpc0lTTzg2MDFfMSIsImlzSVNPODYwMSIsImlzVmFsaWREYXRlIiwib3JkaW5hbE1hdGNoIiwib1llYXIiLCJOdW1iZXIiLCJvRGF5IiwibWFwIiwieWVhciIsIm1vbnRoIiwiZGF5IiwibW9udGhTdHJpbmciLCJkYXlTdHJpbmciLCJkIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJjaGVjayIsInN0cmljdCIsImlzSlNPTl8xIiwiaXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZSIsImlzVVJMXzEiLCJpc1VSTCIsImRlZmF1bHRfdXJsX29wdGlvbnMiLCJwcm90b2NvbHMiLCJyZXF1aXJlX3Byb3RvY29sIiwicmVxdWlyZV9ob3N0IiwicmVxdWlyZV92YWxpZF9wcm90b2NvbCIsImFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMiLCJ3cmFwcGVkX2lwdjYiLCJpc1JlZ0V4cCIsInRvU3RyaW5nIiwiY2hlY2tIb3N0IiwiaG9zdCIsIm1hdGNoZXMiLCJwcm90b2NvbCIsImF1dGgiLCJob3N0bmFtZSIsInBvcnQiLCJwb3J0X3N0ciIsImlwdjYiLCJkaXNhbGxvd19hdXRoIiwiaXB2Nl9tYXRjaCIsImhvc3Rfd2hpdGVsaXN0IiwiaG9zdF9ibGFja2xpc3QiLCJpc1VVSURfMSIsImlzVVVJRCIsImFsbCIsImZyZWVHbG9iYWwiLCJfZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiX3Jvb3QiLCJTeW1ib2wkMSIsIl9TeW1ib2wiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJfZ2V0UmF3VGFnIiwib2JqZWN0UHJvdG8kMSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nJDEiLCJvYmplY3RUb1N0cmluZyIsIl9vYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyQxIiwiYmFzZUdldFRhZyIsIl9iYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJ0eXBlIiwiaXNPYmplY3RfMSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImlzRnVuY3Rpb25fMSIsImNvcmVKc0RhdGEiLCJfY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsImZ1bmMiLCJfaXNNYXNrZWQiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsIl90b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byQxIiwib2JqZWN0UHJvdG8kMiIsImZ1bmNUb1N0cmluZyQxIiwiaGFzT3duUHJvcGVydHkkMSIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJiYXNlSXNOYXRpdmUiLCJfYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJfZ2V0VmFsdWUiLCJnZXROYXRpdmUiLCJfZ2V0TmF0aXZlIiwiX2RlZmluZVByb3BlcnR5IiwiYmFzZUFzc2lnblZhbHVlIiwiX2Jhc2VBc3NpZ25WYWx1ZSIsImVxIiwib3RoZXIiLCJlcV8xIiwib2JqZWN0UHJvdG8kMyIsImhhc093blByb3BlcnR5JDIiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiX2Fzc2lnblZhbHVlIiwiY29weU9iamVjdCIsInNvdXJjZSIsImN1c3RvbWl6ZXIiLCJpc05ldyIsImluZGV4IiwibmV3VmFsdWUiLCJfY29weU9iamVjdCIsImlkZW50aXR5IiwiaWRlbnRpdHlfMSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ3MiLCJfYXBwbHkiLCJuYXRpdmVNYXgiLCJNYXRoIiwib3ZlclJlc3QiLCJzdGFydCIsInRyYW5zZm9ybSIsIkFycmF5Iiwib3RoZXJBcmdzIiwiX292ZXJSZXN0IiwiY29uc3RhbnQiLCJjb25zdGFudF8xIiwiYmFzZVNldFRvU3RyaW5nIiwiX2Jhc2VTZXRUb1N0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93Iiwibm93Iiwic2hvcnRPdXQiLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsIl9zaG9ydE91dCIsInNldFRvU3RyaW5nIiwiX3NldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJfYmFzZVJlc3QiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNMZW5ndGgiLCJpc0xlbmd0aF8xIiwiaXNBcnJheUxpa2UiLCJpc0FycmF5TGlrZV8xIiwiTUFYX1NBRkVfSU5URUdFUiQxIiwicmVJc1VpbnQiLCJpc0luZGV4IiwiX2lzSW5kZXgiLCJpc0l0ZXJhdGVlQ2FsbCIsIl9pc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJfY3JlYXRlQXNzaWduZXIiLCJvYmplY3RQcm90byQ0IiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJfaXNQcm90b3R5cGUiLCJiYXNlVGltZXMiLCJuIiwiaXRlcmF0ZWUiLCJfYmFzZVRpbWVzIiwiaXNPYmplY3RMaWtlIiwiaXNPYmplY3RMaWtlXzEiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwiX2Jhc2VJc0FyZ3VtZW50cyIsIm9iamVjdFByb3RvJDUiLCJoYXNPd25Qcm9wZXJ0eSQzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImlzQXJndW1lbnRzXzEiLCJpc0FycmF5IiwiaXNBcnJheV8xIiwic3R1YkZhbHNlIiwic3R1YkZhbHNlXzEiLCJpc0J1ZmZlcl8xIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImFyZ3NUYWckMSIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWckMSIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiX2Jhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJfYmFzZVVuYXJ5IiwiX25vZGVVdGlsIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheV8xIiwib2JqZWN0UHJvdG8kNiIsImhhc093blByb3BlcnR5JDQiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwicHVzaCIsIl9hcnJheUxpa2VLZXlzIiwib3ZlckFyZyIsImFyZyIsIl9vdmVyQXJnIiwibmF0aXZlS2V5cyIsIl9uYXRpdmVLZXlzIiwib2JqZWN0UHJvdG8kNyIsImhhc093blByb3BlcnR5JDUiLCJiYXNlS2V5cyIsIl9iYXNlS2V5cyIsImtleXNfMSIsIm9iamVjdFByb3RvJDgiLCJoYXNPd25Qcm9wZXJ0eSQ2IiwiYXNzaWduIiwiYXNzaWduXzEiLCJhcnJheVB1c2giLCJ2YWx1ZXMiLCJvZmZzZXQiLCJfYXJyYXlQdXNoIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsImlzRmxhdHRlbmFibGUiLCJfaXNGbGF0dGVuYWJsZSIsImJhc2VGbGF0dGVuIiwiZGVwdGgiLCJwcmVkaWNhdGUiLCJpc1N0cmljdCIsIl9iYXNlRmxhdHRlbiIsImNvcHlBcnJheSIsIl9jb3B5QXJyYXkiLCJjb25jYXRfMSIsImJhc2VQcm9wZXJ0eU9mIiwiX2Jhc2VQcm9wZXJ0eU9mIiwiZGVidXJyZWRMZXR0ZXJzIiwiZGVidXJyTGV0dGVyIiwiX2RlYnVyckxldHRlciIsImFycmF5TWFwIiwiX2FycmF5TWFwIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJpc1N5bWJvbF8xIiwiSU5GSU5JVFkiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwiX2Jhc2VUb1N0cmluZyIsInRvU3RyaW5nXzEiLCJyZUxhdGluIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNDb21ibyIsInJlQ29tYm9NYXJrIiwiZGVidXJyIiwiZGVidXJyXzEiLCJhcnJheUVhY2giLCJfYXJyYXlFYWNoIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJfY3JlYXRlQmFzZUZvciIsImJhc2VGb3IiLCJfYmFzZUZvciIsImJhc2VGb3JPd24iLCJfYmFzZUZvck93biIsImNyZWF0ZUJhc2VFYWNoIiwiZWFjaEZ1bmMiLCJjb2xsZWN0aW9uIiwiX2NyZWF0ZUJhc2VFYWNoIiwiYmFzZUVhY2giLCJfYmFzZUVhY2giLCJjYXN0RnVuY3Rpb24iLCJfY2FzdEZ1bmN0aW9uIiwiZm9yRWFjaCIsImZvckVhY2hfMSIsImVhY2giLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiaXNLZXkiLCJfaXNLZXkiLCJuYXRpdmVDcmVhdGUiLCJfbmF0aXZlQ3JlYXRlIiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJzaXplIiwiX2hhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXMiLCJfaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEIiwib2JqZWN0UHJvdG8kOSIsImhhc093blByb3BlcnR5JDciLCJoYXNoR2V0IiwiZGF0YSIsIl9oYXNoR2V0Iiwib2JqZWN0UHJvdG8kYSIsImhhc093blByb3BlcnR5JDgiLCJoYXNoSGFzIiwiX2hhc2hIYXMiLCJIQVNIX1VOREVGSU5FRCQxIiwiaGFzaFNldCIsIl9oYXNoU2V0IiwiSGFzaCIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwiZ2V0IiwiX0hhc2giLCJsaXN0Q2FjaGVDbGVhciIsIl9saXN0Q2FjaGVDbGVhciIsImFzc29jSW5kZXhPZiIsIl9hc3NvY0luZGV4T2YiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGlzdENhY2hlRGVsZXRlIiwibGFzdEluZGV4IiwiX2xpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsIl9saXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJfbGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiX2xpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIl9MaXN0Q2FjaGUiLCJNYXAiLCJfTWFwIiwibWFwQ2FjaGVDbGVhciIsIl9tYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiX2lzS2V5YWJsZSIsImdldE1hcERhdGEiLCJfZ2V0TWFwRGF0YSIsIm1hcENhY2hlRGVsZXRlIiwiX21hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJfbWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIl9tYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiX21hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJfTWFwQ2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsImNhY2hlIiwiQ2FjaGUiLCJtZW1vaXplXzEiLCJNQVhfTUVNT0laRV9TSVpFIiwibWVtb2l6ZUNhcHBlZCIsIl9tZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImNoYXJDb2RlQXQiLCJxdW90ZSIsInN1YlN0cmluZyIsIl9zdHJpbmdUb1BhdGgiLCJjYXN0UGF0aCIsIl9jYXN0UGF0aCIsIklORklOSVRZJDEiLCJ0b0tleSIsIl90b0tleSIsImJhc2VHZXQiLCJwYXRoIiwiX2Jhc2VHZXQiLCJkZWZhdWx0VmFsdWUiLCJnZXRfMSIsImJhc2VHdCIsIl9iYXNlR3QiLCJOQU4iLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsInZhbHVlT2YiLCJpc0JpbmFyeSIsInRvTnVtYmVyXzEiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwib3BlcmF0b3IiLCJfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsImd0XzEiLCJndGVfMSIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJfYmFzZUZpbmRJbmRleCIsImJhc2VJc05hTiIsIl9iYXNlSXNOYU4iLCJzdHJpY3RJbmRleE9mIiwiX3N0cmljdEluZGV4T2YiLCJiYXNlSW5kZXhPZiIsIl9iYXNlSW5kZXhPZiIsInN0cmluZ1RhZyQxIiwiaXNTdHJpbmdfMSIsIklORklOSVRZJDIiLCJNQVhfSU5URUdFUiIsInRvRmluaXRlIiwic2lnbiIsInRvRmluaXRlXzEiLCJ0b0ludGVnZXIiLCJyZW1haW5kZXIiLCJ0b0ludGVnZXJfMSIsImJhc2VWYWx1ZXMiLCJfYmFzZVZhbHVlcyIsInZhbHVlc18xIiwibmF0aXZlTWF4JDEiLCJpbmNsdWRlcyIsImluY2x1ZGVzXzEiLCJib29sVGFnJDEiLCJpc0Jvb2xlYW4iLCJpc0Jvb2xlYW5fMSIsIkRhdGFWaWV3IiwiX0RhdGFWaWV3IiwiUHJvbWlzZSIsIl9Qcm9taXNlIiwiU2V0IiwiX1NldCIsIldlYWtNYXAiLCJfV2Vha01hcCIsIm1hcFRhZyQxIiwib2JqZWN0VGFnJDEiLCJwcm9taXNlVGFnIiwic2V0VGFnJDEiLCJ3ZWFrTWFwVGFnJDEiLCJkYXRhVmlld1RhZyQxIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnIiwiQXJyYXlCdWZmZXIiLCJyZXNvbHZlIiwiY3RvclN0cmluZyIsIl9nZXRUYWciLCJtYXBUYWckMiIsInNldFRhZyQyIiwib2JqZWN0UHJvdG8kYiIsImhhc093blByb3BlcnR5JDkiLCJpc0VtcHR5IiwiaXNFbXB0eV8xIiwic3RhY2tDbGVhciIsIl9zdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJfc3RhY2tEZWxldGUiLCJzdGFja0dldCIsIl9zdGFja0dldCIsInN0YWNrSGFzIiwiX3N0YWNrSGFzIiwiTEFSR0VfQVJSQVlfU0laRSIsInN0YWNrU2V0IiwicGFpcnMiLCJfc3RhY2tTZXQiLCJTdGFjayIsIl9TdGFjayIsIkhBU0hfVU5ERUZJTkVEJDIiLCJzZXRDYWNoZUFkZCIsIl9zZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiX3NldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhZGQiLCJfU2V0Q2FjaGUiLCJhcnJheVNvbWUiLCJfYXJyYXlTb21lIiwiY2FjaGVIYXMiLCJfY2FjaGVIYXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImJpdG1hc2siLCJlcXVhbEZ1bmMiLCJzdGFjayIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJfZXF1YWxBcnJheXMiLCJVaW50OEFycmF5IiwiX1VpbnQ4QXJyYXkiLCJtYXBUb0FycmF5IiwiX21hcFRvQXJyYXkiLCJzZXRUb0FycmF5IiwiX3NldFRvQXJyYXkiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyQxIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyQxIiwiYm9vbFRhZyQyIiwiZGF0ZVRhZyQxIiwiZXJyb3JUYWckMSIsIm1hcFRhZyQzIiwibnVtYmVyVGFnJDEiLCJyZWdleHBUYWckMSIsInNldFRhZyQzIiwic3RyaW5nVGFnJDIiLCJzeW1ib2xUYWckMSIsImFycmF5QnVmZmVyVGFnJDEiLCJkYXRhVmlld1RhZyQyIiwic3ltYm9sUHJvdG8kMSIsInN5bWJvbFZhbHVlT2YiLCJlcXVhbEJ5VGFnIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJtZXNzYWdlIiwiY29udmVydCIsIl9lcXVhbEJ5VGFnIiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsIl9iYXNlR2V0QWxsS2V5cyIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJfYXJyYXlGaWx0ZXIiLCJzdHViQXJyYXkiLCJzdHViQXJyYXlfMSIsIm9iamVjdFByb3RvJGMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSQxIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFN5bWJvbHMiLCJzeW1ib2wiLCJfZ2V0U3ltYm9scyIsImdldEFsbEtleXMiLCJfZ2V0QWxsS2V5cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDIiLCJvYmplY3RQcm90byRkIiwiaGFzT3duUHJvcGVydHkkYSIsImVxdWFsT2JqZWN0cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiX2VxdWFsT2JqZWN0cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDMiLCJhcmdzVGFnJDIiLCJhcnJheVRhZyQxIiwib2JqZWN0VGFnJDIiLCJvYmplY3RQcm90byRlIiwiaGFzT3duUHJvcGVydHkkYiIsImJhc2VJc0VxdWFsRGVlcCIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiX2Jhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwiX2Jhc2VJc0VxdWFsIiwiaXNFcXVhbCIsImlzRXF1YWxfMSIsIm5hdGl2ZUlzRmluaXRlIiwiaXNGaW5pdGUiLCJfaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0ludGVnZXJfMSIsIm51bWJlclRhZyQyIiwiaXNOdW1iZXIiLCJpc051bWJlcl8xIiwiaXNOYU4kMSIsIl9pc05hTiIsImlzTmlsIiwiaXNOaWxfMSIsImlzTnVsbCIsImlzTnVsbF8xIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZF8xIiwiYmFzZUx0IiwiX2Jhc2VMdCIsImx0XzEiLCJsdGVfMSIsImJhc2VTZXQiLCJuZXN0ZWQiLCJfYmFzZVNldCIsImJhc2VQaWNrQnkiLCJwYXRocyIsIl9iYXNlUGlja0J5IiwiYmFzZUhhc0luIiwiX2Jhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiX2hhc1BhdGgiLCJoYXNJbiIsImhhc0luXzEiLCJiYXNlUGljayIsIl9iYXNlUGljayIsImZsYXR0ZW4iLCJmbGF0dGVuXzEiLCJmbGF0UmVzdCIsIl9mbGF0UmVzdCIsInBpY2siLCJwaWNrXzEiLCJzZXRfMSIsImJhc2VQcm9wZXJ0eSIsIl9iYXNlUHJvcGVydHkiLCJhc2NpaVNpemUiLCJfYXNjaWlTaXplIiwicnNBc3RyYWxSYW5nZSIsInJzQ29tYm9NYXJrc1JhbmdlJDEiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMSIsInJzQ29tYm9SYW5nZSQxIiwicnNWYXJSYW5nZSIsInJzWldKIiwicmVIYXNVbmljb2RlIiwiaGFzVW5pY29kZSIsIl9oYXNVbmljb2RlIiwicnNBc3RyYWxSYW5nZSQxIiwicnNDb21ib01hcmtzUmFuZ2UkMiIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQyIiwicnNDb21ib1N5bWJvbHNSYW5nZSQyIiwicnNDb21ib1JhbmdlJDIiLCJyc1ZhclJhbmdlJDEiLCJyc0FzdHJhbCIsInJzQ29tYm8kMSIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNaV0okMSIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwidW5pY29kZVNpemUiLCJfdW5pY29kZVNpemUiLCJzdHJpbmdTaXplIiwiX3N0cmluZ1NpemUiLCJtYXBUYWckNCIsInNldFRhZyQ0Iiwic2l6ZV8xIiwiYmFzZVNsaWNlIiwiZW5kIiwiX2Jhc2VTbGljZSIsImNhc3RTbGljZSIsIl9jYXN0U2xpY2UiLCJyZWdleHBUYWckMiIsImJhc2VJc1JlZ0V4cCIsIl9iYXNlSXNSZWdFeHAiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cF8xIiwiYXNjaWlUb0FycmF5IiwiX2FzY2lpVG9BcnJheSIsInJzQXN0cmFsUmFuZ2UkMiIsInJzQ29tYm9NYXJrc1JhbmdlJDMiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMyIsInJzQ29tYm9SYW5nZSQzIiwicnNWYXJSYW5nZSQyIiwicnNBc3RyYWwkMSIsInJzQ29tYm8kMiIsInJzRml0eiQxIiwicnNNb2RpZmllciQxIiwicnNOb25Bc3RyYWwkMSIsInJzUmVnaW9uYWwkMSIsInJzU3VyclBhaXIkMSIsInJzWldKJDIiLCJyZU9wdE1vZCQxIiwicnNPcHRWYXIkMSIsInJzT3B0Sm9pbiQxIiwicnNTZXEkMSIsInJzU3ltYm9sJDEiLCJyZVVuaWNvZGUkMSIsInVuaWNvZGVUb0FycmF5IiwiX3VuaWNvZGVUb0FycmF5Iiwic3RyaW5nVG9BcnJheSIsIl9zdHJpbmdUb0FycmF5IiwiTUFYX0FSUkFZX0xFTkdUSCIsInNlcGFyYXRvciIsImxpbWl0Iiwic3BsaXRfMSIsInN0dWJUcnVlIiwic3R1YlRydWVfMSIsIm5hdGl2ZUtleXNJbiIsIl9uYXRpdmVLZXlzSW4iLCJvYmplY3RQcm90byRmIiwiaGFzT3duUHJvcGVydHkkYyIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwiX2Jhc2VLZXlzSW4iLCJrZXlzSW4iLCJrZXlzSW5fMSIsImFzc2lnbkluV2l0aCIsInNyY0luZGV4IiwiYXNzaWduSW5XaXRoXzEiLCJnZXRQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGUiLCJvYmplY3RUYWckMyIsImZ1bmNQcm90byQyIiwib2JqZWN0UHJvdG8kZyIsImZ1bmNUb1N0cmluZyQyIiwiaGFzT3duUHJvcGVydHkkZCIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNQbGFpbk9iamVjdF8xIiwiZG9tRXhjVGFnIiwiZXJyb3JUYWckMiIsImlzRXJyb3IiLCJpc0Vycm9yXzEiLCJhdHRlbXB0IiwiYXR0ZW1wdF8xIiwib2JqZWN0UHJvdG8kaCIsImhhc093blByb3BlcnR5JGUiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwic3JjVmFsdWUiLCJfY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsInN0cmluZ0VzY2FwZXMiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiX2VzY2FwZVN0cmluZ0NoYXIiLCJyZUludGVycG9sYXRlIiwiX3JlSW50ZXJwb2xhdGUiLCJodG1sRXNjYXBlcyIsImVzY2FwZUh0bWxDaGFyIiwiX2VzY2FwZUh0bWxDaGFyIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwiZXNjYXBlIiwiX2VzY2FwZSIsInJlRXNjYXBlIiwiX3JlRXNjYXBlIiwicmVFdmFsdWF0ZSIsIl9yZUV2YWx1YXRlIiwidGVtcGxhdGVTZXR0aW5ncyIsInRlbXBsYXRlU2V0dGluZ3NfMSIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNUZW1wbGF0ZSIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwib2JqZWN0UHJvdG8kaSIsImhhc093blByb3BlcnR5JGYiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsIl8iLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJ2YXJpYWJsZSIsInRlbXBsYXRlXzEiLCJ0b0xvd2VyIiwidG9Mb3dlcl8xIiwidG9EYXRlIiwiYXJndW1lbnQiLCJhcmdTdHIiLCJnZXRUaW1lIiwiY29uc29sZSIsIndhcm4iLCJOYU4iLCJ0b0ludGVnZXIkMSIsImRpcnR5TnVtYmVyIiwiY2VpbCIsImZsb29yIiwiYWRkTWlsbGlzZWNvbmRzIiwiZGlydHlEYXRlIiwiZGlydHlBbW91bnQiLCJ0aW1lc3RhbXAiLCJhbW91bnQiLCJNSUxMSVNFQ09ORFNfSU5fTUlOVVRFIiwiZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyIsImJhc2VUaW1lem9uZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0U2Vjb25kcyIsIm1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0IiwiaXNWYWxpZCIsImZvcm1hdERpc3RhbmNlTG9jYWxlIiwibGVzc1RoYW5YU2Vjb25kcyIsIm9uZSIsInhTZWNvbmRzIiwiaGFsZkFNaW51dGUiLCJsZXNzVGhhblhNaW51dGVzIiwieE1pbnV0ZXMiLCJhYm91dFhIb3VycyIsInhIb3VycyIsInhEYXlzIiwiYWJvdXRYTW9udGhzIiwieE1vbnRocyIsImFib3V0WFllYXJzIiwieFllYXJzIiwib3ZlclhZZWFycyIsImFsbW9zdFhZZWFycyIsImZvcm1hdERpc3RhbmNlIiwidG9rZW4iLCJhZGRTdWZmaXgiLCJjb21wYXJpc29uIiwiYnVpbGRGb3JtYXRMb25nRm4iLCJkaXJ0eU9wdGlvbnMiLCJ3aWR0aCIsImRlZmF1bHRXaWR0aCIsImZvcm1hdCIsImZvcm1hdHMiLCJkYXRlRm9ybWF0cyIsImZ1bGwiLCJtZWRpdW0iLCJ0aW1lRm9ybWF0cyIsImRhdGVUaW1lRm9ybWF0cyIsImZvcm1hdExvbmciLCJ0aW1lIiwiZGF0ZVRpbWUiLCJmb3JtYXRSZWxhdGl2ZUxvY2FsZSIsImxhc3RXZWVrIiwieWVzdGVyZGF5IiwidG9kYXkiLCJ0b21vcnJvdyIsIm5leHRXZWVrIiwiZm9ybWF0UmVsYXRpdmUiLCJfZGF0ZSIsIl9iYXNlRGF0ZSIsIl9vcHRpb25zIiwiYnVpbGRMb2NhbGl6ZUZuIiwiZGlydHlJbmRleCIsImNvbnRleHQiLCJ2YWx1ZXNBcnJheSIsImZvcm1hdHRpbmdWYWx1ZXMiLCJkZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIiwiX2RlZmF1bHRXaWR0aCIsIl93aWR0aCIsImFyZ3VtZW50Q2FsbGJhY2siLCJlcmFWYWx1ZXMiLCJuYXJyb3ciLCJhYmJyZXZpYXRlZCIsIndpZGUiLCJxdWFydGVyVmFsdWVzIiwibW9udGhWYWx1ZXMiLCJkYXlWYWx1ZXMiLCJkYXlQZXJpb2RWYWx1ZXMiLCJhbSIsInBtIiwibWlkbmlnaHQiLCJub29uIiwibW9ybmluZyIsImFmdGVybm9vbiIsImV2ZW5pbmciLCJuaWdodCIsImZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMiLCJvcmRpbmFsTnVtYmVyIiwiX2RpcnR5T3B0aW9ucyIsInJlbTEwMCIsImxvY2FsaXplIiwiZXJhIiwicXVhcnRlciIsImRheVBlcmlvZCIsImJ1aWxkTWF0Y2hQYXR0ZXJuRm4iLCJkaXJ0eVN0cmluZyIsIm1hdGNoUmVzdWx0IiwibWF0Y2hQYXR0ZXJuIiwibWF0Y2hlZFN0cmluZyIsInBhcnNlUmVzdWx0IiwicGFyc2VQYXR0ZXJuIiwidmFsdWVDYWxsYmFjayIsInJlc3QiLCJidWlsZE1hdGNoRm4iLCJtYXRjaFBhdHRlcm5zIiwiZGVmYXVsdE1hdGNoV2lkdGgiLCJwYXJzZVBhdHRlcm5zIiwiZGVmYXVsdFBhcnNlV2lkdGgiLCJmaW5kSW5kZXgiLCJmaW5kS2V5IiwibWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiIsInBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4iLCJtYXRjaEVyYVBhdHRlcm5zIiwicGFyc2VFcmFQYXR0ZXJucyIsImFueSIsIm1hdGNoUXVhcnRlclBhdHRlcm5zIiwicGFyc2VRdWFydGVyUGF0dGVybnMiLCJtYXRjaE1vbnRoUGF0dGVybnMiLCJwYXJzZU1vbnRoUGF0dGVybnMiLCJtYXRjaERheVBhdHRlcm5zIiwicGFyc2VEYXlQYXR0ZXJucyIsIm1hdGNoRGF5UGVyaW9kUGF0dGVybnMiLCJwYXJzZURheVBlcmlvZFBhdHRlcm5zIiwid2Vla1N0YXJ0c09uIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIiwic3ViTWlsbGlzZWNvbmRzIiwiYWRkTGVhZGluZ1plcm9zIiwidGFyZ2V0TGVuZ3RoIiwib3V0cHV0IiwiYWJzIiwiZm9ybWF0dGVycyIsInkiLCJzaWduZWRZZWFyIiwiTSIsImRheVBlcmlvZEVudW1WYWx1ZSIsImdldFVUQ0hvdXJzIiwidG9VcHBlckNhc2UiLCJoIiwiSCIsIm0iLCJnZXRVVENNaW51dGVzIiwicyIsImdldFVUQ1NlY29uZHMiLCJTIiwibnVtYmVyT2ZEaWdpdHMiLCJtaWxsaXNlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJmcmFjdGlvbmFsU2Vjb25kcyIsInBvdyIsIk1JTExJU0VDT05EU19JTl9EQVkiLCJnZXRVVENEYXlPZlllYXIiLCJzZXRVVENNb250aCIsInNldFVUQ0hvdXJzIiwic3RhcnRPZlllYXJUaW1lc3RhbXAiLCJkaWZmZXJlbmNlIiwic3RhcnRPZlVUQ0lTT1dlZWsiLCJnZXRVVENEYXkiLCJkaWZmIiwic2V0VVRDRGF0ZSIsImdldFVUQ0lTT1dlZWtZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciIsInNldFVUQ0Z1bGxZZWFyIiwic3RhcnRPZk5leHRZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciIsInN0YXJ0T2ZUaGlzWWVhciIsInN0YXJ0T2ZVVENJU09XZWVrWWVhciIsImZvdXJ0aE9mSmFudWFyeSIsIk1JTExJU0VDT05EU19JTl9XRUVLIiwiZ2V0VVRDSVNPV2VlayIsInJvdW5kIiwic3RhcnRPZlVUQ1dlZWsiLCJsb2NhbGVXZWVrU3RhcnRzT24iLCJkZWZhdWx0V2Vla1N0YXJ0c09uIiwiUmFuZ2VFcnJvciIsImdldFVUQ1dlZWtZZWFyIiwibG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlIiwiZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSIsImZpcnN0V2Vla09mTmV4dFllYXIiLCJmaXJzdFdlZWtPZlRoaXNZZWFyIiwic3RhcnRPZlVUQ1dlZWtZZWFyIiwiZmlyc3RXZWVrIiwiTUlMTElTRUNPTkRTX0lOX1dFRUskMSIsImdldFVUQ1dlZWsiLCJkYXlQZXJpb2RFbnVtIiwiZm9ybWF0dGVycyQxIiwiRyIsInVuaXQiLCJZIiwic2lnbmVkV2Vla1llYXIiLCJ3ZWVrWWVhciIsInR3b0RpZ2l0WWVhciIsIlIiLCJpc29XZWVrWWVhciIsInUiLCJRIiwicSIsIkwiLCJ3Iiwid2VlayIsIkkiLCJpc29XZWVrIiwiRCIsImRheU9mWWVhciIsIkUiLCJkYXlPZldlZWsiLCJsb2NhbERheU9mV2VlayIsImMiLCJpc29EYXlPZldlZWsiLCJob3VycyIsIkIiLCJLIiwiayIsIlgiLCJfbG9jYWxpemUiLCJvcmlnaW5hbERhdGUiLCJfb3JpZ2luYWxEYXRlIiwidGltZXpvbmVPZmZzZXQiLCJmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXMiLCJmb3JtYXRUaW1lem9uZSIsIk8iLCJmb3JtYXRUaW1lem9uZVNob3J0IiwieiIsInQiLCJUIiwiZGlydHlEZWxpbWl0ZXIiLCJhYnNPZmZzZXQiLCJtaW51dGVzIiwiZGVsaW1pdGVyIiwiZGF0ZUxvbmdGb3JtYXR0ZXIiLCJ0aW1lTG9uZ0Zvcm1hdHRlciIsImRhdGVUaW1lTG9uZ0Zvcm1hdHRlciIsImRhdGVQYXR0ZXJuIiwidGltZVBhdHRlcm4iLCJkYXRlVGltZUZvcm1hdCIsImxvbmdGb3JtYXR0ZXJzIiwicCIsIlAiLCJwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMiLCJwcm90ZWN0ZWRXZWVrWWVhclRva2VucyIsImlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4iLCJpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4iLCJ0aHJvd1Byb3RlY3RlZEVycm9yIiwiZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCIsImxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwIiwiZXNjYXBlZFN0cmluZ1JlZ0V4cCIsImRvdWJsZVF1b3RlUmVnRXhwIiwidW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAiLCJkaXJ0eUZvcm1hdFN0ciIsImZvcm1hdFN0ciIsImxvY2FsZSQxIiwidXRjRGF0ZSIsImZvcm1hdHRlck9wdGlvbnMiLCJmaXJzdENoYXJhY3RlciIsImxvbmdGb3JtYXR0ZXIiLCJjbGVhbkVzY2FwZWRTdHJpbmciLCJmb3JtYXR0ZXIiLCJ1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMiLCJ1c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zIiwiYXNzaWduJDEiLCJkaXJ0eU9iamVjdCIsInByb3BlcnR5IiwiaXNBZnRlciIsImRpcnR5RGF0ZVRvQ29tcGFyZSIsImRhdGVUb0NvbXBhcmUiLCJpc0JlZm9yZSIsInNldFVUQ0RheSIsImRpcnR5RGF5IiwiY3VycmVudERheSIsImRheUluZGV4Iiwic2V0VVRDSVNPRGF5Iiwic2V0VVRDSVNPV2VlayIsImRpcnR5SVNPV2VlayIsInNldFVUQ1dlZWsiLCJkaXJ0eVdlZWsiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiIsIk1JTExJU0VDT05EU19JTl9NSU5VVEUkMSIsIk1JTExJU0VDT05EU19JTl9TRUNPTkQiLCJudW1lcmljUGF0dGVybnMiLCJob3VyMjNoIiwiaG91cjI0aCIsImhvdXIxMWgiLCJob3VyMTJoIiwibWludXRlIiwic2Vjb25kIiwic2luZ2xlRGlnaXQiLCJ0d29EaWdpdHMiLCJ0aHJlZURpZ2l0cyIsImZvdXJEaWdpdHMiLCJhbnlEaWdpdHNTaWduZWQiLCJzaW5nbGVEaWdpdFNpZ25lZCIsInR3b0RpZ2l0c1NpZ25lZCIsInRocmVlRGlnaXRzU2lnbmVkIiwiZm91ckRpZ2l0c1NpZ25lZCIsInRpbWV6b25lUGF0dGVybnMiLCJiYXNpY09wdGlvbmFsTWludXRlcyIsImJhc2ljIiwiYmFzaWNPcHRpb25hbFNlY29uZHMiLCJleHRlbmRlZCIsImV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzIiwicGFyc2VOdW1lcmljUGF0dGVybiIsInBhcnNlVGltZXpvbmVQYXR0ZXJuIiwic2Vjb25kcyIsInBhcnNlQW55RGlnaXRzU2lnbmVkIiwicGFyc2VORGlnaXRzIiwicGFyc2VORGlnaXRzU2lnbmVkIiwiZGF5UGVyaW9kRW51bVRvSG91cnMiLCJlbnVtVmFsdWUiLCJub3JtYWxpemVUd29EaWdpdFllYXIiLCJjdXJyZW50WWVhciIsImlzQ29tbW9uRXJhIiwiYWJzQ3VycmVudFllYXIiLCJyYW5nZUVuZCIsInJhbmdlRW5kQ2VudHVyeSIsImlzUHJldmlvdXNDZW50dXJ5IiwiREFZU19JTl9NT05USCIsIkRBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSIiwiaXNMZWFwWWVhckluZGV4IiwicGFyc2VycyIsInByaW9yaXR5IiwiZmxhZ3MiLCJpbmNvbXBhdGlibGVUb2tlbnMiLCJpc1R3b0RpZ2l0WWVhciIsInZhbGlkYXRlIiwibm9ybWFsaXplZFR3b0RpZ2l0WWVhciIsIl9tYXRjaCIsIl9mbGFncyIsImZpcnN0V2Vla09mWWVhciIsImlzTGVhcFllYXIiLCJ3aG9sZVdlZWtEYXlzIiwiaXNQTSIsInNldFVUQ01pbnV0ZXMiLCJzZXRVVENTZWNvbmRzIiwic2V0VVRDTWlsbGlzZWNvbmRzIiwidGltZXN0YW1wSXNTZXQiLCJfdG9rZW4iLCJUSU1FWk9ORV9VTklUX1BSSU9SSVRZIiwiZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxIiwibG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSIsImVzY2FwZWRTdHJpbmdSZWdFeHAkMSIsImRvdWJsZVF1b3RlUmVnRXhwJDEiLCJub3RXaGl0ZXNwYWNlUmVnRXhwIiwidW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAkMSIsImRpcnR5RGF0ZVN0cmluZyIsImRpcnR5Rm9ybWF0U3RyaW5nIiwiZGlydHlCYWNrdXBEYXRlIiwiZGF0ZVN0cmluZyIsImZvcm1hdFN0cmluZyIsInN1YkZuT3B0aW9ucyIsInNldHRlcnMiLCJkYXRlVG9TeXN0ZW1UaW1lem9uZSIsInRva2VucyIsInVzZWRUb2tlbnMiLCJwYXJzZXIiLCJpbmNvbXBhdGlibGVUb2tlbiIsInVzZWRUb2tlbiIsImZ1bGxUb2tlbiIsImNsZWFuRXNjYXBlZFN0cmluZyQxIiwidW5pcXVlUHJpb3JpdHlTZXR0ZXJzIiwic2V0dGVyIiwiZmlsdGVyIiwicmV2ZXJzZSIsInNldHRlckFycmF5IiwiY29udmVydGVkRGF0ZSIsInNldEZ1bGxZZWFyIiwic2V0SG91cnMiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiQxIiwiTUlMTElTRUNPTkRTX0lOX01JTlVURSQyIiwiREVGQVVMVF9BRERJVElPTkFMX0RJR0lUUyIsInBhdHRlcm5zIiwiZGF0ZVRpbWVEZWxpbWl0ZXIiLCJ0aW1lWm9uZURlbGltaXRlciIsInRpbWV6b25lIiwiZGF0ZVJlZ2V4IiwidGltZVJlZ2V4IiwidGltZXpvbmVSZWdleCIsInBhcnNlSVNPIiwiYWRkaXRpb25hbERpZ2l0cyIsImRhdGVTdHJpbmdzIiwic3BsaXREYXRlU3RyaW5nIiwicGFyc2VZZWFyUmVzdWx0IiwicGFyc2VZZWFyIiwicGFyc2VEYXRlIiwicmVzdERhdGVTdHJpbmciLCJwYXJzZVRpbWUiLCJwYXJzZVRpbWV6b25lIiwiZnVsbFRpbWUiLCJmdWxsVGltZURhdGUiLCJmdWxsVGltZURhdGVOZXh0RGF5Iiwic2V0RGF0ZSIsImdldERhdGUiLCJvZmZzZXREaWZmIiwidGltZVN0cmluZyIsInJlZ2V4IiwiY2FwdHVyZXMiLCJjZW50dXJ5IiwiaXNXZWVrRGF0ZSIsInBhcnNlRGF0ZVVuaXQiLCJ2YWxpZGF0ZVdlZWtEYXRlIiwiZGF5T2ZJU09XZWVrWWVhciIsInZhbGlkYXRlRGF0ZSIsInZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSIsInBhcnNlVGltZVVuaXQiLCJ2YWxpZGF0ZVRpbWUiLCJwYXJzZUZsb2F0IiwidGltZXpvbmVTdHJpbmciLCJ2YWxpZGF0ZVRpbWV6b25lIiwiZm91cnRoT2ZKYW51YXJ5RGF5IiwiZGF5c0luTW9udGhzIiwiaXNMZWFwWWVhckluZGV4JDEiLCJfeWVhciIsIl9ob3VycyIsInBhcnNlRGF0ZSQxIiwiX2dsb2JhbCIsIl9fdnVlbWNfdmFsaWRhdGlvbl9tZXNzYWdlcyIsIl9jbGFzcyIsInJlc2V0IiwiJGxvY2FsZSIsIiRmYWxsYmFjayIsIiRsb2NhbGVzIiwicmVnaXN0ZXIiLCJidW5kbGUiLCJfdGhpcyIsIiR0ZW1wbGF0ZSIsInJ1bGUiLCJjb25maWciLCIkcnVsZSIsImF0dHJpYnV0ZSIsIm1vZGVsIiwidmFsaWQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9hbmQiLCJfc3RlcCIsIm5leHQiLCJkb25lIiwiZXJyIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIiLCJfZGlkSXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3IyIiwiX29yIiwiX3N0ZXAyIiwiX3Jlc3VsdCIsIl9mb3JtYXQiLCJjb3B5Iiwib3IiLCJydWxlcyIsImFuZCIsImluY2x1c2l2ZSIsIl9taW4iLCJfbWF4IiwiX3ZhbHVlIiwiX2Jvb2xlYW4iLCJmb3JtYXQkMSIsImVycm9yIiwiZXF1YWwiLCJndCQxIiwiZ3RlJDEiLCJsdCQxIiwibHRlJDEiLCJtYXRjaCQxIiwiX21heDIiLCJfbWluMiIsIl9sZW4iLCJfa2V5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7TUFHcUIsT0FBUSxTQUFRQSxXQUFLO0lBQ3hD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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
