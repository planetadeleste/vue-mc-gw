
  /**
   * @license
   * author: Alvaro Canepa
   * vue-mc-gw.js v1.0.49
   * Released under the MIT license.
   */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueMc = require('@planetadeleste/vue-mc');
var lodash = require('lodash');

class Account extends vueMc.Model {
    defaults() {
        return {
            id: null,
            paymentmethod_id: null,
            currency_id: null,
            company_id: null,
            active: true,
            name: null,
            code: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            paymentmethod_id: (id) => lodash.toNumber(id) || null,
            currency_id: (id) => lodash.toNumber(id) || null,
            company_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "accounts.show",
            create: "accounts.store",
            update: "accounts.update",
            delete: "accounts.destroy",
        };
    }
}

class AccountCollection extends vueMc.Collection {
    model() {
        return Account;
    }
    routes() {
        return {
            fetch: "accounts.index",
            list: "accounts.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class AccountConfig extends vueMc.Model {
    defaults() {
        return {
            id: null,
            any_currency: false,
            company_id: null,
            account_id: null,
            accounttype_id: null,
            paymentmethod_id: null,
            currency_id: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            company_id: (id) => lodash.toNumber(id) || null,
            account_id: (id) => lodash.toNumber(id) || null,
            accounttype_id: (id) => lodash.toNumber(id) || null,
            paymentmethod_id: (id) => lodash.toNumber(id) || null,
            currency_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "accountconfigs.show",
            create: "accountconfigs.store",
            update: "accountconfigs.update",
            delete: "accountconfigs.destroy",
        };
    }
}

class AccountConfigCollection extends vueMc.Collection {
    model() {
        return AccountConfig;
    }
    routes() {
        return {
            fetch: "accountconfigs.index",
            list: "accountconfigs.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class AccountType extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: true,
            name: null,
            code: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "accounttypes.show",
            create: "accounttypes.store",
            update: "accounttypes.update",
            delete: "accounttypes.destroy",
        };
    }
}

class AccountTypeCollection extends vueMc.Collection {
    model() {
        return AccountType;
    }
    routes() {
        return {
            fetch: "accounttypes.index",
            list: "accounttypes.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var validation = {};

(function (exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /**
   * Afrikaans
   */


  var en_us = {
    locale: 'en-US',
    messages: {
      after: 'Must be after ${date}',
      alpha: 'Can only use letters',
      alphanumeric: 'Must be alphanumeric',
      array: 'Must be an array',
      ascii: 'Must be ASCII',
      base64: 'Must be valid Base64',
      before: 'Must be before ${date}',
      between: 'Must be between ${min} and ${max}',
      between_inclusive: 'Must be between ${min} and ${max}, inclusive',
      "boolean": 'Must be true or false',
      creditcard: 'Must be a valid credit card number',
      date: 'Must be a valid date',
      dateformat: 'Must use "${format}" format',
      defined: 'Required',
      email: 'Must be a valid email address',
      empty: 'Must be empty',
      equals: 'Must be equal to ${other}',
      gt: 'Must be greater than ${min}',
      gte: 'Must be greater than or equal to ${min}',
      integer: 'Must be an integer',
      ip: 'Must be a valid IP address',
      isblank: 'May not be blank',
      isnil: 'Required',
      isnull: 'Required',
      iso8601: 'Must be a valid ISO8601 date',
      json: 'Must be a valid JSON',
      length: 'Must have a length of at least ${min}',
      length_between: 'Must have a length between ${min} and ${max}',
      lt: 'Must be less than ${max}',
      lte: 'Must be less than or equal to ${max}',
      match: 'Must match "${pattern}"',
      negative: 'Must be a negative number',
      not: 'Can not be ${value}',
      number: 'Must be a number',
      numeric: 'Must be numeric',
      object: 'Must be an object',
      positive: 'Must be a positive number',
      required: 'Required',
      same: 'Must have the same value as "${other}"',
      string: 'Must be a string',
      url: 'Must be a valid URL',
      uuid: 'Must be a valid UUID'
    }
    /**
     * Persian - Islamic Republic of Iran
     */

  };
  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

  function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  var assertString_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = assertString;

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }

    function assertString(input) {
      var isString = typeof input === 'string' || input instanceof String;

      if (!isString) {
        var invalidType;

        if (input === null) {
          invalidType = 'null';
        } else {
          invalidType = _typeof$1(input);

          if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
            invalidType = input.constructor.name;
          } else {
            invalidType = "a ".concat(invalidType);
          }
        }

        throw new TypeError("Expected string but received ".concat(invalidType, "."));
      }
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(assertString_1);
  var alpha_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commaDecimal = exports.dotDecimal = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
    var alpha = {
      'en-US': /^[A-Z]+$/i,
      'bg-BG': /^[А-Я]+$/i,
      'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      'da-DK': /^[A-ZÆØÅ]+$/i,
      'de-DE': /^[A-ZÄÖÜß]+$/i,
      'el-GR': /^[Α-ω]+$/i,
      'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      'nb-NO': /^[A-ZÆØÅ]+$/i,
      'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      'nn-NO': /^[A-ZÆØÅ]+$/i,
      'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      'pt-PT': /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
      'ru-RU': /^[А-ЯЁ]+$/i,
      'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
      'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
      'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
      'sv-SE': /^[A-ZÅÄÖ]+$/i,
      'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
      'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    exports.alpha = alpha;
    var alphanumeric = {
      'en-US': /^[0-9A-Z]+$/i,
      'bg-BG': /^[0-9А-Я]+$/i,
      'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      'da-DK': /^[0-9A-ZÆØÅ]+$/i,
      'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
      'el-GR': /^[0-9Α-ω]+$/i,
      'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
      'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
      'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      'pt-PT': /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
      'ru-RU': /^[0-9А-ЯЁ]+$/i,
      'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
      'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
      'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
      'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    exports.alphanumeric = alphanumeric;
    var decimal = {
      'en-US': '.',
      ar: '٫'
    };
    exports.decimal = decimal;
    var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
    exports.englishLocales = englishLocales;

    for (var locale, i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha['en-US'];
      alphanumeric[locale] = alphanumeric['en-US'];
      decimal[locale] = decimal['en-US'];
    } // Source: http://www.localeplanet.com/java/


    var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
    exports.arabicLocales = arabicLocales;

    for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    } // Source: https://en.wikipedia.org/wiki/Decimal_mark


    var dotDecimal = [];
    exports.dotDecimal = dotDecimal;
    var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA'];
    exports.commaDecimal = commaDecimal;

    for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
      decimal[dotDecimal[_i2]] = decimal['en-US'];
    }

    for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
      decimal[commaDecimal[_i3]] = ',';
    }

    alpha['pt-BR'] = alpha['pt-PT'];
    alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
    decimal['pt-BR'] = decimal['pt-PT']; // see #862

    alpha['pl-Pl'] = alpha['pl-PL'];
    alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
    decimal['pl-Pl'] = decimal['pl-PL'];
  });
  unwrapExports(alpha_1);
  alpha_1.commaDecimal;
  alpha_1.dotDecimal;
  alpha_1.arabicLocales;
  alpha_1.englishLocales;
  alpha_1.decimal;
  alpha_1.alphanumeric;
  alpha_1.alpha;
  var isAlpha_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isAlpha;
    exports.locales = void 0;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function isAlpha(str) {
      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
      (0, _assertString["default"])(str);

      if (locale in alpha_1.alpha) {
        return alpha_1.alpha[locale].test(str);
      }

      throw new Error("Invalid locale '".concat(locale, "'"));
    }

    var locales = Object.keys(alpha_1.alpha);
    exports.locales = locales;
  });
  var isAlpha = unwrapExports(isAlpha_1);
  isAlpha_1.locales;
  var isAlphanumeric_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isAlphanumeric;
    exports.locales = void 0;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function isAlphanumeric(str) {
      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
      (0, _assertString["default"])(str);

      if (locale in alpha_1.alphanumeric) {
        return alpha_1.alphanumeric[locale].test(str);
      }

      throw new Error("Invalid locale '".concat(locale, "'"));
    }

    var locales = Object.keys(alpha_1.alphanumeric);
    exports.locales = locales;
  });
  var isAlphanumeric = unwrapExports(isAlphanumeric_1);
  isAlphanumeric_1.locales;
  var isBase64_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isBase64;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var notBase64 = /[^A-Z0-9+\/=]/i;

    function isBase64(str) {
      (0, _assertString["default"])(str);
      var len = str.length;

      if (!len || len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }

      var firstPaddingChar = str.indexOf('=');
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isBase64 = unwrapExports(isBase64_1);
  var isCreditCard_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isCreditCard;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    /* eslint-disable max-len */


    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
    /* eslint-enable max-len */

    function isCreditCard(str) {
      (0, _assertString["default"])(str);
      var sanitized = str.replace(/[- ]+/g, '');

      if (!creditCard.test(sanitized)) {
        return false;
      }

      var sum = 0;
      var digit;
      var tmpNum;
      var shouldDouble;

      for (var i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, i + 1);
        tmpNum = parseInt(digit, 10);

        if (shouldDouble) {
          tmpNum *= 2;

          if (tmpNum >= 10) {
            sum += tmpNum % 10 + 1;
          } else {
            sum += tmpNum;
          }
        } else {
          sum += tmpNum;
        }

        shouldDouble = !shouldDouble;
      }

      return !!(sum % 10 === 0 ? sanitized : false);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isCreditCard = unwrapExports(isCreditCard_1);
  var merge_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = merge;

    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : undefined;

      for (var key in defaults) {
        if (typeof obj[key] === 'undefined') {
          obj[key] = defaults[key];
        }
      }

      return obj;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(merge_1);
  var isByteLength_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isByteLength;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }
    /* eslint-disable prefer-rest-params */


    function isByteLength(str, options) {
      (0, _assertString["default"])(str);
      var min;
      var max;

      if (_typeof$1(options) === 'object') {
        min = options.min || 0;
        max = options.max;
      } else {
        // backwards compatibility: isByteLength(str, min [, max])
        min = arguments[1];
        max = arguments[2];
      }

      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === 'undefined' || len <= max);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(isByteLength_1);
  var isFQDN_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isFQDN;

    var _assertString = _interopRequireDefault(assertString_1);

    var _merge = _interopRequireDefault(merge_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false
    };

    function isFQDN(str, options) {
      (0, _assertString["default"])(str);
      options = (0, _merge["default"])(options, default_fqdn_options);
      /* Remove the optional trailing dot before checking validity */

      if (options.allow_trailing_dot && str[str.length - 1] === '.') {
        str = str.substring(0, str.length - 1);
      }

      var parts = str.split('.');

      for (var i = 0; i < parts.length; i++) {
        if (parts[i].length > 63) {
          return false;
        }
      }

      if (options.require_tld) {
        var tld = parts.pop();

        if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        } // disallow spaces


        if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
          return false;
        }
      }

      for (var part, _i = 0; _i < parts.length; _i++) {
        part = parts[_i];

        if (options.allow_underscores) {
          part = part.replace(/_/g, '');
        }

        if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        } // disallow full-width chars


        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }

        if (part[0] === '-' || part[part.length - 1] === '-') {
          return false;
        }
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(isFQDN_1);
  var isIP_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isIP;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    var ipv6Block = /^[0-9A-F]{1,4}$/i;

    function isIP(str) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      (0, _assertString["default"])(str);
      version = String(version);

      if (!version) {
        return isIP(str, 4) || isIP(str, 6);
      } else if (version === '4') {
        if (!ipv4Maybe.test(str)) {
          return false;
        }

        var parts = str.split('.').sort(function (a, b) {
          return a - b;
        });
        return parts[3] <= 255;
      } else if (version === '6') {
        var blocks = str.split(':');
        var foundOmissionBlock = false; // marker to indicate ::
        // At least some OS accept the last 32 bits of an IPv6 address
        // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
        // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
        // and '::a.b.c.d' is deprecated, but also valid.

        var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
        var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

        if (blocks.length > expectedNumberOfBlocks) {
          return false;
        } // initial or final ::


        if (str === '::') {
          return true;
        } else if (str.substr(0, 2) === '::') {
          blocks.shift();
          blocks.shift();
          foundOmissionBlock = true;
        } else if (str.substr(str.length - 2) === '::') {
          blocks.pop();
          blocks.pop();
          foundOmissionBlock = true;
        }

        for (var i = 0; i < blocks.length; ++i) {
          // test for a :: which can not be at the string start/end
          // since those cases have been handled above
          if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
            if (foundOmissionBlock) {
              return false; // multiple :: in address
            }

            foundOmissionBlock = true;
          } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ;else if (!ipv6Block.test(blocks[i])) {
            return false;
          }
        }

        if (foundOmissionBlock) {
          return blocks.length >= 1;
        }

        return blocks.length === expectedNumberOfBlocks;
      }

      return false;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isIP = unwrapExports(isIP_1);
  var isEmail_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isEmail;

    var _assertString = _interopRequireDefault(assertString_1);

    var _merge = _interopRequireDefault(merge_1);

    var _isByteLength = _interopRequireDefault(isByteLength_1);

    var _isFQDN = _interopRequireDefault(isFQDN_1);

    var _isIP = _interopRequireDefault(isIP_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_email_options = {
      allow_display_name: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true
    };
    /* eslint-disable max-len */

    /* eslint-disable no-control-regex */

    var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    /* eslint-enable max-len */

    /* eslint-enable no-control-regex */

    function isEmail(str, options) {
      (0, _assertString["default"])(str);
      options = (0, _merge["default"])(options, default_email_options);

      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(displayName);

        if (display_email) {
          str = display_email[1];
        } else if (options.require_display_name) {
          return false;
        }
      }

      var parts = str.split('@');
      var domain = parts.pop();
      var user = parts.join('@');
      var lower_domain = domain.toLowerCase();

      if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
        /*
          Previously we removed dots for gmail addresses before validating.
          This was removed because it allows `multiple..dots@gmail.com`
          to be reported as valid, but it is not.
          Gmail only normalizes single dots, removing them from here is pointless,
          should be done in normalizeEmail
        */
        user = user.toLowerCase(); // Removing sub-address from username before gmail validation

        var username = user.split('+')[0]; // Dots are not included in gmail length restriction

        if (!(0, _isByteLength["default"])(username.replace('.', ''), {
          min: 6,
          max: 30
        })) {
          return false;
        }

        var _user_parts = username.split('.');

        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }

      if (!(0, _isByteLength["default"])(user, {
        max: 64
      }) || !(0, _isByteLength["default"])(domain, {
        max: 254
      })) {
        return false;
      }

      if (!(0, _isFQDN["default"])(domain, {
        require_tld: options.require_tld
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }

        if (!(0, _isIP["default"])(domain)) {
          if (!domain.startsWith('[') || !domain.endsWith(']')) {
            return false;
          }

          var noBracketdomain = domain.substr(1, domain.length - 2);

          if (noBracketdomain.length === 0 || !(0, _isIP["default"])(noBracketdomain)) {
            return false;
          }
        }
      }

      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }

      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split('.');

      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isEmail = unwrapExports(isEmail_1);
  var isISO8601_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isISO8601;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    /* eslint-disable max-len */
    // from http://goo.gl/0ejHHW


    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    /* eslint-enable max-len */

    var isValidDate = function isValidDate(str) {
      // str must have passed the ISO8601 check
      // this check is meant to catch invalid dates
      // like 2009-02-31
      // first check for ordinal dates
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);

      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]); // if is leap year

        if (oYear % 4 === 0 && oYear % 100 !== 0) return oDay <= 366;
        return oDay <= 365;
      }

      var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match[1];
      var month = match[2];
      var day = match[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day; // create a date object and compare

      var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
      if (isNaN(d.getUTCFullYear())) return false;

      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }

      return true;
    };

    function isISO8601(str, options) {
      (0, _assertString["default"])(str);
      var check = iso8601.test(str);
      if (!options) return check;
      if (check && options.strict) return isValidDate(str);
      return check;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isISO8601 = unwrapExports(isISO8601_1);
  var isJSON_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isJSON;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }

    function isJSON(str) {
      (0, _assertString["default"])(str);

      try {
        var obj = JSON.parse(str);
        return !!obj && _typeof$1(obj) === 'object';
      } catch (e) {
        /* ignore */
      }

      return false;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isJSON = unwrapExports(isJSON_1);
  var isURL_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isURL;

    var _assertString = _interopRequireDefault(assertString_1);

    var _isFQDN = _interopRequireDefault(isFQDN_1);

    var _isIP = _interopRequireDefault(isIP_1);

    var _merge = _interopRequireDefault(merge_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_url_options = {
      protocols: ['http', 'https', 'ftp'],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

    function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === '[object RegExp]';
    }

    function checkHost(host, matches) {
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];

        if (host === match || isRegExp(match) && match.test(host)) {
          return true;
        }
      }

      return false;
    }

    function isURL(url, options) {
      (0, _assertString["default"])(url);

      if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
        return false;
      }

      if (url.indexOf('mailto:') === 0) {
        return false;
      }

      options = (0, _merge["default"])(options, default_url_options);
      var protocol, auth, host, hostname, port, port_str, split, ipv6;
      split = url.split('#');
      url = split.shift();
      split = url.split('?');
      url = split.shift();
      split = url.split('://');

      if (split.length > 1) {
        protocol = split.shift().toLowerCase();

        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.substr(0, 2) === '//') {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }

        split[0] = url.substr(2);
      }

      url = split.join('://');

      if (url === '') {
        return false;
      }

      split = url.split('/');
      url = split.shift();

      if (url === '' && !options.require_host) {
        return true;
      }

      split = url.split('@');

      if (split.length > 1) {
        if (options.disallow_auth) {
          return false;
        }

        auth = split.shift();

        if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
          return false;
        }
      }

      hostname = split.join('@');
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);

      if (ipv6_match) {
        host = '';
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split = hostname.split(':');
        host = split.shift();

        if (split.length) {
          port_str = split.join(':');
        }
      }

      if (port_str !== null) {
        port = parseInt(port_str, 10);

        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      }

      if (!(0, _isIP["default"])(host) && !(0, _isFQDN["default"])(host, options) && (!ipv6 || !(0, _isIP["default"])(ipv6, 6))) {
        return false;
      }

      host = host || ipv6;

      if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
        return false;
      }

      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isURL = unwrapExports(isURL_1);
  var isUUID_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isUUID;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var uuid = {
      3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };

    function isUUID(str) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
      (0, _assertString["default"])(str);
      var pattern = uuid[version];
      return pattern && pattern.test(str);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isUUID = unwrapExports(isUUID_1);
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal$1) == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  var _freeGlobal = freeGlobal;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;
  /** Built-in value references. */

  var Symbol$1 = _root.Symbol;
  var _Symbol = Symbol$1;
  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;
  /** Used for built-in method references. */

  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;
  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  function isObject(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;
  /** `Object#toString` result references. */

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = _baseGetTag(value);

    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;
  /** Used for built-in method references. */

  var funcProto = Function.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$1 = funcProto$1.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */

  function getNative(object, key) {
    var value = _getValue(object, key);

    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var defineProperty = function () {
    try {
      var func = _getNative(Object, 'defineProperty');

      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  var _defineProperty = defineProperty;
  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;
  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }

    return object;
  }

  var _copyObject = copyObject;
  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */

  function identity(value) {
    return value;
  }

  var identity_1 = identity;
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  var _apply = apply;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max;
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;
  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */

  function constant(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant;
  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString;
  /** Used to detect hot functions by number of calls within a span of milliseconds. */

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeNow = Date.now;
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;
  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */

  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */

  function isIndex(value, length) {
    var type = _typeof(value);

    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;
  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */

  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }

    var type = _typeof(index);

    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
      return eq_1(object[index], value);
    }

    return false;
  }

  var _isIterateeCall = isIterateeCall;
  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */

  function createAssigner(assigner) {
    return _baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }

  var _createAssigner = createAssigner;
  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$4;
    return value === proto;
  }

  var _isPrototype = isPrototype;
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]';
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;
  /** Used for built-in method references. */

  var objectProto$5 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
  /** Built-in value references. */

  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */

  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments;
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray = Array.isArray;
  var isArray_1 = isArray;
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;
  var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Built-in value references. */

    var Buffer = moduleExports ? _root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse_1;
    module.exports = isBuffer;
  });
  /** `Object#toString` result references. */

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && _freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    module.exports = nodeUtil;
  });
  /* Node.js helper references. */


  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */

  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;
  /** Used for built-in method references. */

  var objectProto$6 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;
  /** Used for built-in method references. */

  var objectProto$7 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;
  /** Used for built-in method references. */

  var objectProto$8 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */

  var assign = _createAssigner(function (object, source) {
    if (_isPrototype(source) || isArrayLike_1(source)) {
      _copyObject(source, keys_1(source), object);

      return;
    }

    for (var key in source) {
      if (hasOwnProperty$6.call(source, key)) {
        _assignValue(object, key, source[key]);
      }
    }
  });

  var assign_1 = assign;
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;
  /** Built-in value references. */

  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */

  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  var _baseFlatten = baseFlatten;
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */

  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  var _copyArray = copyArray;
  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */

  function concat() {
    var length = arguments.length;

    if (!length) {
      return [];
    }

    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }

    return _arrayPush(isArray_1(array) ? _copyArray(array) : [array], _baseFlatten(args, 1));
  }

  var concat_1 = concat;
  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */

  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  var _basePropertyOf = basePropertyOf;
  /** Used to map Latin Unicode letters to basic Latin letters. */

  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',
    '\xc1': 'A',
    '\xc2': 'A',
    '\xc3': 'A',
    '\xc4': 'A',
    '\xc5': 'A',
    '\xe0': 'a',
    '\xe1': 'a',
    '\xe2': 'a',
    '\xe3': 'a',
    '\xe4': 'a',
    '\xe5': 'a',
    '\xc7': 'C',
    '\xe7': 'c',
    '\xd0': 'D',
    '\xf0': 'd',
    '\xc8': 'E',
    '\xc9': 'E',
    '\xca': 'E',
    '\xcb': 'E',
    '\xe8': 'e',
    '\xe9': 'e',
    '\xea': 'e',
    '\xeb': 'e',
    '\xcc': 'I',
    '\xcd': 'I',
    '\xce': 'I',
    '\xcf': 'I',
    '\xec': 'i',
    '\xed': 'i',
    '\xee': 'i',
    '\xef': 'i',
    '\xd1': 'N',
    '\xf1': 'n',
    '\xd2': 'O',
    '\xd3': 'O',
    '\xd4': 'O',
    '\xd5': 'O',
    '\xd6': 'O',
    '\xd8': 'O',
    '\xf2': 'o',
    '\xf3': 'o',
    '\xf4': 'o',
    '\xf5': 'o',
    '\xf6': 'o',
    '\xf8': 'o',
    '\xd9': 'U',
    '\xda': 'U',
    '\xdb': 'U',
    '\xdc': 'U',
    '\xf9': 'u',
    '\xfa': 'u',
    '\xfb': 'u',
    '\xfc': 'u',
    '\xdd': 'Y',
    '\xfd': 'y',
    '\xff': 'y',
    '\xc6': 'Ae',
    '\xe6': 'ae',
    '\xde': 'Th',
    '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    "\u0100": 'A',
    "\u0102": 'A',
    "\u0104": 'A',
    "\u0101": 'a',
    "\u0103": 'a',
    "\u0105": 'a',
    "\u0106": 'C',
    "\u0108": 'C',
    "\u010A": 'C',
    "\u010C": 'C',
    "\u0107": 'c',
    "\u0109": 'c',
    "\u010B": 'c',
    "\u010D": 'c',
    "\u010E": 'D',
    "\u0110": 'D',
    "\u010F": 'd',
    "\u0111": 'd',
    "\u0112": 'E',
    "\u0114": 'E',
    "\u0116": 'E',
    "\u0118": 'E',
    "\u011A": 'E',
    "\u0113": 'e',
    "\u0115": 'e',
    "\u0117": 'e',
    "\u0119": 'e',
    "\u011B": 'e',
    "\u011C": 'G',
    "\u011E": 'G',
    "\u0120": 'G',
    "\u0122": 'G',
    "\u011D": 'g',
    "\u011F": 'g',
    "\u0121": 'g',
    "\u0123": 'g',
    "\u0124": 'H',
    "\u0126": 'H',
    "\u0125": 'h',
    "\u0127": 'h',
    "\u0128": 'I',
    "\u012A": 'I',
    "\u012C": 'I',
    "\u012E": 'I',
    "\u0130": 'I',
    "\u0129": 'i',
    "\u012B": 'i',
    "\u012D": 'i',
    "\u012F": 'i',
    "\u0131": 'i',
    "\u0134": 'J',
    "\u0135": 'j',
    "\u0136": 'K',
    "\u0137": 'k',
    "\u0138": 'k',
    "\u0139": 'L',
    "\u013B": 'L',
    "\u013D": 'L',
    "\u013F": 'L',
    "\u0141": 'L',
    "\u013A": 'l',
    "\u013C": 'l',
    "\u013E": 'l',
    "\u0140": 'l',
    "\u0142": 'l',
    "\u0143": 'N',
    "\u0145": 'N',
    "\u0147": 'N',
    "\u014A": 'N',
    "\u0144": 'n',
    "\u0146": 'n',
    "\u0148": 'n',
    "\u014B": 'n',
    "\u014C": 'O',
    "\u014E": 'O',
    "\u0150": 'O',
    "\u014D": 'o',
    "\u014F": 'o',
    "\u0151": 'o',
    "\u0154": 'R',
    "\u0156": 'R',
    "\u0158": 'R',
    "\u0155": 'r',
    "\u0157": 'r',
    "\u0159": 'r',
    "\u015A": 'S',
    "\u015C": 'S',
    "\u015E": 'S',
    "\u0160": 'S',
    "\u015B": 's',
    "\u015D": 's',
    "\u015F": 's',
    "\u0161": 's',
    "\u0162": 'T',
    "\u0164": 'T',
    "\u0166": 'T',
    "\u0163": 't',
    "\u0165": 't',
    "\u0167": 't',
    "\u0168": 'U',
    "\u016A": 'U',
    "\u016C": 'U',
    "\u016E": 'U',
    "\u0170": 'U',
    "\u0172": 'U',
    "\u0169": 'u',
    "\u016B": 'u',
    "\u016D": 'u',
    "\u016F": 'u',
    "\u0171": 'u',
    "\u0173": 'u',
    "\u0174": 'W',
    "\u0175": 'w',
    "\u0176": 'Y',
    "\u0177": 'y',
    "\u0178": 'Y',
    "\u0179": 'Z',
    "\u017B": 'Z',
    "\u017D": 'Z',
    "\u017A": 'z',
    "\u017C": 'z',
    "\u017E": 'z',
    "\u0132": 'IJ',
    "\u0133": 'ij',
    "\u0152": 'Oe',
    "\u0153": 'oe',
    "\u0149": "'n",
    "\u017F": 's'
  };
  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */

  var deburrLetter = _basePropertyOf(deburredLetters);

  var _deburrLetter = deburrLetter;
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */

  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;
  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
  }

  var isSymbol_1 = isSymbol;
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  var _baseToString = baseToString;
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */

  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;
  /** Used to match Latin Unicode letters (excluding mathematical operators). */

  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  /** Used to compose unicode character classes. */

  var rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
  /** Used to compose unicode capture groups. */

  var rsCombo = '[' + rsComboRange + ']';
  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */

  var reComboMark = RegExp(rsCombo, 'g');
  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */

  function deburr(string) {
    string = toString_1(string);
    return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
  }

  var deburr_1 = deburr;
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */

  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var _arrayEach = arrayEach;
  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  var _createBaseFor = createBaseFor;
  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */

  var baseFor = _createBaseFor();

  var _baseFor = baseFor;
  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;
  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  var _createBaseEach = createBaseEach;
  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */

  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;
  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */

  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;
  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */

  function forEach(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayEach : _baseEach;
    return func(collection, _castFunction(iteratee));
  }

  var forEach_1 = forEach;
  var each = forEach_1;
  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = _typeof(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;
  /* Built-in method references that are verified to be native. */

  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used for built-in method references. */

  var objectProto$9 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;
  /** Used for built-in method references. */

  var objectProto$a = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
  }

  var _hashHas = hashHas;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `Hash`.


  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;
  /** Used for built-in method references. */

  var arrayProto = Array.prototype;
  /** Built-in value references. */

  var splice = arrayProto.splice;
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;
  /* Built-in method references that are verified to be native. */

  var Map = _getNative(_root, 'Map');

  var _Map = Map;
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */

  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);

    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;
  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = _MapCache;
  var memoize_1 = memoize;
  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;
  /** Used to match property names within property paths. */

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */

  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  var _stringToPath = stringToPath;
  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;
  /** Used as references for various `Number` constants. */

  var INFINITY$1 = 1 / 0;
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  var _toKey = toKey;
  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */

  function baseGet(object, path) {
    path = _castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  var _baseGet = baseGet;
  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;
  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */

  function baseGt(value, other) {
    return value > other;
  }

  var _baseGt = baseGt;
  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;
  /**
   * Creates a function that performs a relational operation on two values.
   *
   * @private
   * @param {Function} operator The function to perform the operation.
   * @returns {Function} Returns the new relational operation function.
   */

  function createRelationalOperation(operator) {
    return function (value, other) {
      if (!(typeof value == 'string' && typeof other == 'string')) {
        value = toNumber_1(value);
        other = toNumber_1(other);
      }

      return operator(value, other);
    };
  }

  var _createRelationalOperation = createRelationalOperation;
  /**
   * Checks if `value` is greater than `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   * @see _.lt
   * @example
   *
   * _.gt(3, 1);
   * // => true
   *
   * _.gt(3, 3);
   * // => false
   *
   * _.gt(1, 3);
   * // => false
   */

  var gt = _createRelationalOperation(_baseGt);

  var gt_1 = gt;
  /**
   * Checks if `value` is greater than or equal to `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than or equal to
   *  `other`, else `false`.
   * @see _.lte
   * @example
   *
   * _.gte(3, 1);
   * // => true
   *
   * _.gte(3, 3);
   * // => true
   *
   * _.gte(1, 3);
   * // => false
   */

  var gte = _createRelationalOperation(function (value, other) {
    return value >= other;
  });

  var gte_1 = gte;
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  var _baseFindIndex = baseFindIndex;
  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */

  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;
  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  var _strictIndexOf = strictIndexOf;
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;
  /** `Object#toString` result references. */

  var stringTag$1 = '[object String]';
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */

  function isString(value) {
    return typeof value == 'string' || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$1;
  }

  var isString_1 = isString;
  /** Used as references for various `Number` constants. */

  var INFINITY$2 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber_1(value);

    if (value === INFINITY$2 || value === -INFINITY$2) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;
  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */

  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var toInteger_1 = toInteger;
  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */

  function baseValues(object, props) {
    return _arrayMap(props, function (key) {
      return object[key];
    });
  }

  var _baseValues = baseValues;
  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */

  function values(object) {
    return object == null ? [] : _baseValues(object, keys_1(object));
  }

  var values_1 = values;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax$1 = Math.max;
  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */

  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike_1(collection) ? collection : values_1(collection);
    fromIndex = fromIndex && !guard ? toInteger_1(fromIndex) : 0;
    var length = collection.length;

    if (fromIndex < 0) {
      fromIndex = nativeMax$1(length + fromIndex, 0);
    }

    return isString_1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _baseIndexOf(collection, value, fromIndex) > -1;
  }

  var includes_1 = includes;
  /** `Object#toString` result references. */

  var boolTag$1 = '[object Boolean]';
  /**
   * Checks if `value` is classified as a boolean primitive or object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
   * @example
   *
   * _.isBoolean(false);
   * // => true
   *
   * _.isBoolean(null);
   * // => false
   */

  function isBoolean(value) {
    return value === true || value === false || isObjectLike_1(value) && _baseGetTag(value) == boolTag$1;
  }

  var isBoolean_1 = isBoolean;
  /* Built-in method references that are verified to be native. */

  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;
  /* Built-in method references that are verified to be native. */

  var Promise = _getNative(_root, 'Promise');

  var _Promise = Promise;
  /* Built-in method references that are verified to be native. */

  var Set = _getNative(_root, 'Set');

  var _Set = Set;
  /* Built-in method references that are verified to be native. */

  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;
  /** `Object#toString` result references. */

  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$1 = '[object DataView]';
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */


  var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;

          case mapCtorString:
            return mapTag$1;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$1;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;
  /** `Object#toString` result references. */

  var mapTag$2 = '[object Map]',
      setTag$2 = '[object Set]';
  /** Used for built-in method references. */

  var objectProto$b = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */

  function isEmpty(value) {
    if (value == null) {
      return true;
    }

    if (isArrayLike_1(value) && (isArray_1(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer_1(value) || isTypedArray_1(value) || isArguments_1(value))) {
      return !value.length;
    }

    var tag = _getTag(value);

    if (tag == mapTag$2 || tag == setTag$2) {
      return !value.size;
    }

    if (_isPrototype(value)) {
      return !_baseKeys(value).length;
    }

    for (var key in value) {
      if (hasOwnProperty$9.call(value, key)) {
        return false;
      }
    }

    return true;
  }

  var isEmpty_1 = isEmpty;
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;
  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  } // Add methods to `Stack`.


  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  var _setCacheAdd = setCacheAdd;
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;
  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;
  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */

  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;
  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;
  /** Built-in value references. */

  var Uint8Array = _root.Uint8Array;
  var _Uint8Array = Uint8Array;
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  /** `Object#toString` result references. */

  var boolTag$2 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$3 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$3 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]';
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$2:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$2:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag$3:
        var convert = _mapToArray;

      case setTag$3:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);

        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);

        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;
  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */

  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;
  /** Used for built-in method references. */

  var objectProto$c = Object.prototype;
  /** Built-in value references. */

  var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$2 = 1;
  /** Used for built-in method references. */

  var objectProto$d = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$a = objectProto$d.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$3 = 1;
  /** `Object#toString` result references. */

  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$2 = '[object Object]';
  /** Used for built-in method references. */

  var objectProto$e = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);
    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;
    var objIsObj = objTag == objectTag$2,
        othIsObj = othTag == objectTag$2,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;
  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;
  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */

  function isEqual(value, other) {
    return _baseIsEqual(value, other);
  }

  var isEqual_1 = isEqual;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsFinite = _root.isFinite;
  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */

  function isFinite(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  var _isFinite = isFinite;
  /**
   * Checks if `value` is an integer.
   *
   * **Note:** This method is based on
   * [`Number.isInteger`](https://mdn.io/Number/isInteger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
   * @example
   *
   * _.isInteger(3);
   * // => true
   *
   * _.isInteger(Number.MIN_VALUE);
   * // => false
   *
   * _.isInteger(Infinity);
   * // => false
   *
   * _.isInteger('3');
   * // => false
   */

  function isInteger(value) {
    return typeof value == 'number' && value == toInteger_1(value);
  }

  var isInteger_1 = isInteger;
  /** `Object#toString` result references. */

  var numberTag$2 = '[object Number]';
  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */

  function isNumber(value) {
    return typeof value == 'number' || isObjectLike_1(value) && _baseGetTag(value) == numberTag$2;
  }

  var isNumber_1 = isNumber;
  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */

  function isNaN$1(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber_1(value) && value != +value;
  }

  var _isNaN = isNaN$1;
  /**
   * Checks if `value` is `null` or `undefined`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
   * @example
   *
   * _.isNil(null);
   * // => true
   *
   * _.isNil(void 0);
   * // => true
   *
   * _.isNil(NaN);
   * // => false
   */

  function isNil(value) {
    return value == null;
  }

  var isNil_1 = isNil;
  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */

  function isNull(value) {
    return value === null;
  }

  var isNull_1 = isNull;
  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */

  function isUndefined(value) {
    return value === undefined;
  }

  var isUndefined_1 = isUndefined;
  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */

  function baseLt(value, other) {
    return value < other;
  }

  var _baseLt = baseLt;
  /**
   * Checks if `value` is less than `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   * @see _.gt
   * @example
   *
   * _.lt(1, 3);
   * // => true
   *
   * _.lt(3, 3);
   * // => false
   *
   * _.lt(3, 1);
   * // => false
   */

  var lt = _createRelationalOperation(_baseLt);

  var lt_1 = lt;
  /**
   * Checks if `value` is less than or equal to `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than or equal to
   *  `other`, else `false`.
   * @see _.gte
   * @example
   *
   * _.lte(1, 3);
   * // => true
   *
   * _.lte(3, 3);
   * // => true
   *
   * _.lte(3, 1);
   * // => false
   */

  var lte = _createRelationalOperation(function (value, other) {
    return value <= other;
  });

  var lte_1 = lte;
  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */

  function baseSet(object, path, value, customizer) {
    if (!isObject_1(object)) {
      return object;
    }

    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = _toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject_1(objValue) ? objValue : _isIndex(path[index + 1]) ? [] : {};
        }
      }

      _assignValue(nested, key, newValue);

      nested = nested[key];
    }

    return object;
  }

  var _baseSet = baseSet;
  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */

  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = _baseGet(object, path);

      if (predicate(value, path)) {
        _baseSet(result, _castPath(path, object), value);
      }
    }

    return result;
  }

  var _basePickBy = basePickBy;
  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;
  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;
  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */

  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;
  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */

  function basePick(object, paths) {
    return _basePickBy(object, paths, function (value, path) {
      return hasIn_1(object, path);
    });
  }

  var _basePick = basePick;
  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */

  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? _baseFlatten(array, 1) : [];
  }

  var flatten_1 = flatten;
  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */

  function flatRest(func) {
    return _setToString(_overRest(func, undefined, flatten_1), func + '');
  }

  var _flatRest = flatRest;
  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */

  var pick = _flatRest(function (object, paths) {
    return object == null ? {} : _basePick(object, paths);
  });

  var pick_1 = pick;
  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */

  function set(object, path, value) {
    return object == null ? object : _baseSet(object, path, value);
  }

  var set_1 = set;
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */

  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;
  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  var asciiSize = _baseProperty('length');

  var _asciiSize = asciiSize;
  /** Used to compose unicode character classes. */

  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange$1 = "\\u0300-\\u036f",
      reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsZWJ = "\\u200d";
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange$1 + rsVarRange + ']');
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */

  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;
  /** Used to compose unicode character classes. */

  var rsAstralRange$1 = "\\ud800-\\udfff",
      rsComboMarksRange$2 = "\\u0300-\\u036f",
      reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
      rsVarRange$1 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo$1 = '[' + rsComboRange$2 + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo$1 + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$1 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo$1 + '?', rsCombo$1, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;

    while (reUnicode.test(string)) {
      ++result;
    }

    return result;
  }

  var _unicodeSize = unicodeSize;
  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */

  function stringSize(string) {
    return _hasUnicode(string) ? _unicodeSize(string) : _asciiSize(string);
  }

  var _stringSize = stringSize;
  /** `Object#toString` result references. */

  var mapTag$4 = '[object Map]',
      setTag$4 = '[object Set]';
  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */

  function size(collection) {
    if (collection == null) {
      return 0;
    }

    if (isArrayLike_1(collection)) {
      return isString_1(collection) ? _stringSize(collection) : collection.length;
    }

    var tag = _getTag(collection);

    if (tag == mapTag$4 || tag == setTag$4) {
      return collection.size;
    }

    return _baseKeys(collection).length;
  }

  var size_1 = size;
  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  var _baseSlice = baseSlice;
  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;
  /** `Object#toString` result references. */

  var regexpTag$2 = '[object RegExp]';
  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */

  function baseIsRegExp(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == regexpTag$2;
  }

  var _baseIsRegExp = baseIsRegExp;
  /* Node.js helper references. */

  var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;
  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */

  var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;
  var isRegExp_1 = isRegExp;
  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;
  /** Used to compose unicode character classes. */

  var rsAstralRange$2 = "\\ud800-\\udfff",
      rsComboMarksRange$3 = "\\u0300-\\u036f",
      reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$3 = "\\u20d0-\\u20ff",
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsVarRange$2 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral$1 = '[' + rsAstralRange$2 + ']',
      rsCombo$2 = '[' + rsComboRange$3 + ']',
      rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
      rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$2 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$2 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsSymbol$1 = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral$1].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode$1 = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol$1 + rsSeq$1, 'g');
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function unicodeToArray(string) {
    return string.match(reUnicode$1) || [];
  }

  var _unicodeToArray = unicodeToArray;
  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function stringToArray(string) {
    return _hasUnicode(string) ? _unicodeToArray(string) : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;
  /** Used as references for the maximum length and index of an array. */

  var MAX_ARRAY_LENGTH = 4294967295;
  /**
   * Splits `string` by `separator`.
   *
   * **Note:** This method is based on
   * [`String#split`](https://mdn.io/String/split).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to split.
   * @param {RegExp|string} separator The separator pattern to split by.
   * @param {number} [limit] The length to truncate results to.
   * @returns {Array} Returns the string segments.
   * @example
   *
   * _.split('a-b-c', '-', 2);
   * // => ['a', 'b']
   */

  function split(string, separator, limit) {
    if (limit && typeof limit != 'number' && _isIterateeCall(string, separator, limit)) {
      separator = limit = undefined;
    }

    limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

    if (!limit) {
      return [];
    }

    string = toString_1(string);

    if (string && (typeof separator == 'string' || separator != null && !isRegExp_1(separator))) {
      separator = _baseToString(separator);

      if (!separator && _hasUnicode(string)) {
        return _castSlice(_stringToArray(string), 0, limit);
      }
    }

    return string.split(separator, limit);
  }

  var split_1 = split;
  /**
   * This method returns `true`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `true`.
   * @example
   *
   * _.times(2, _.stubTrue);
   * // => [true, true]
   */

  function stubTrue() {
    return true;
  }

  var stubTrue_1 = stubTrue;
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var _nativeKeysIn = nativeKeysIn;
  /** Used for built-in method references. */

  var objectProto$f = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$c = objectProto$f.hasOwnProperty;
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }

    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$c.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeysIn = baseKeysIn;
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */

  function keysIn(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn;
  /**
   * This method is like `_.assignIn` except that it accepts `customizer`
   * which is invoked to produce the assigned values. If `customizer` returns
   * `undefined`, assignment is handled by the method instead. The `customizer`
   * is invoked with five arguments: (objValue, srcValue, key, object, source).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extendWith
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} [customizer] The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @see _.assignWith
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   return _.isUndefined(objValue) ? srcValue : objValue;
   * }
   *
   * var defaults = _.partialRight(_.assignInWith, customizer);
   *
   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */

  var assignInWith = _createAssigner(function (object, source, srcIndex, customizer) {
    _copyObject(source, keysIn_1(source), object, customizer);
  });

  var assignInWith_1 = assignInWith;
  /** Built-in value references. */

  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;
  /** `Object#toString` result references. */

  var objectTag$3 = '[object Object]';
  /** Used for built-in method references. */

  var funcProto$2 = Function.prototype,
      objectProto$g = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$2 = funcProto$2.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$d = objectProto$g.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString$2.call(Object);
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$d.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;
  /** `Object#toString` result references. */

  var domExcTag = '[object DOMException]',
      errorTag$2 = '[object Error]';
  /**
   * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
   * `SyntaxError`, `TypeError`, or `URIError` object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
   * @example
   *
   * _.isError(new Error);
   * // => true
   *
   * _.isError(Error);
   * // => false
   */

  function isError(value) {
    if (!isObjectLike_1(value)) {
      return false;
    }

    var tag = _baseGetTag(value);

    return tag == errorTag$2 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject_1(value);
  }

  var isError_1 = isError;
  /**
   * Attempts to invoke `func`, returning either the result or the caught error
   * object. Any additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Function} func The function to attempt.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {*} Returns the `func` result or error object.
   * @example
   *
   * // Avoid throwing errors for invalid selectors.
   * var elements = _.attempt(function(selector) {
   *   return document.querySelectorAll(selector);
   * }, '>_>');
   *
   * if (_.isError(elements)) {
   *   elements = [];
   * }
   */

  var attempt = _baseRest(function (func, args) {
    try {
      return _apply(func, undefined, args);
    } catch (e) {
      return isError_1(e) ? e : new Error(e);
    }
  });

  var attempt_1 = attempt;
  /** Used for built-in method references. */

  var objectProto$h = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$e = objectProto$h.hasOwnProperty;
  /**
   * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
   * of source objects to the destination object for all destination properties
   * that resolve to `undefined`.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to assign.
   * @param {Object} object The parent object of `objValue`.
   * @returns {*} Returns the value to assign.
   */

  function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === undefined || eq_1(objValue, objectProto$h[key]) && !hasOwnProperty$e.call(object, key)) {
      return srcValue;
    }

    return objValue;
  }

  var _customDefaultsAssignIn = customDefaultsAssignIn;
  /** Used to escape characters for inclusion in compiled string literals. */

  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    "\u2028": 'u2028',
    "\u2029": 'u2029'
  };
  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  var _escapeStringChar = escapeStringChar;
  /** Used to match template delimiters. */

  var reInterpolate = /<%=([\s\S]+?)%>/g;
  var _reInterpolate = reInterpolate;
  /** Used to map characters to HTML entities. */

  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  var escapeHtmlChar = _basePropertyOf(htmlEscapes);

  var _escapeHtmlChar = escapeHtmlChar;
  /** Used to match HTML entities and HTML characters. */

  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */

  function escape(string) {
    string = toString_1(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, _escapeHtmlChar) : string;
  }

  var _escape = escape;
  /** Used to match template delimiters. */

  var reEscape = /<%-([\s\S]+?)%>/g;
  var _reEscape = reEscape;
  /** Used to match template delimiters. */

  var reEvaluate = /<%([\s\S]+?)%>/g;
  var _reEvaluate = reEvaluate;
  /**
   * By default, the template delimiters used by lodash are like those in
   * embedded Ruby (ERB) as well as ES2015 template strings. Change the
   * following template settings to use alternative delimiters.
   *
   * @static
   * @memberOf _
   * @type {Object}
   */

  var templateSettings = {
    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'escape': _reEscape,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'evaluate': _reEvaluate,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'interpolate': _reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type {string}
     */
    'variable': '',

    /**
     * Used to import variables into the compiled template.
     *
     * @memberOf _.templateSettings
     * @type {Object}
     */
    'imports': {
      /**
       * A reference to the `lodash` function.
       *
       * @memberOf _.templateSettings.imports
       * @type {Function}
       */
      '_': {
        'escape': _escape
      }
    }
  };
  var templateSettings_1 = templateSettings;
  /** Used to match empty string literals in compiled template source. */

  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */

  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  /** Used to ensure capturing order of template delimiters. */

  var reNoMatch = /($^)/;
  /** Used to match unescaped characters in compiled string literals. */

  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  /** Used for built-in method references. */

  var objectProto$i = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$f = objectProto$i.hasOwnProperty;
  /**
   * Creates a compiled template function that can interpolate data properties
   * in "interpolate" delimiters, HTML-escape interpolated data properties in
   * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
   * properties may be accessed as free variables in the template. If a setting
   * object is given, it takes precedence over `_.templateSettings` values.
   *
   * **Note:** In the development build `_.template` utilizes
   * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
   * for easier debugging.
   *
   * For more information on precompiling templates see
   * [lodash's custom builds documentation](https://lodash.com/custom-builds).
   *
   * For more information on Chrome extension sandboxes see
   * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The template string.
   * @param {Object} [options={}] The options object.
   * @param {RegExp} [options.escape=_.templateSettings.escape]
   *  The HTML "escape" delimiter.
   * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
   *  The "evaluate" delimiter.
   * @param {Object} [options.imports=_.templateSettings.imports]
   *  An object to import into the template as free variables.
   * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
   *  The "interpolate" delimiter.
   * @param {string} [options.sourceURL='templateSources[n]']
   *  The sourceURL of the compiled template.
   * @param {string} [options.variable='obj']
   *  The data object variable name.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Function} Returns the compiled template function.
   * @example
   *
   * // Use the "interpolate" delimiter to create a compiled template.
   * var compiled = _.template('hello <%= user %>!');
   * compiled({ 'user': 'fred' });
   * // => 'hello fred!'
   *
   * // Use the HTML "escape" delimiter to escape data property values.
   * var compiled = _.template('<b><%- value %></b>');
   * compiled({ 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
   * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the internal `print` function in "evaluate" delimiters.
   * var compiled = _.template('<% print("hello " + user); %>!');
   * compiled({ 'user': 'barney' });
   * // => 'hello barney!'
   *
   * // Use the ES template literal delimiter as an "interpolate" delimiter.
   * // Disable support by replacing the "interpolate" delimiter.
   * var compiled = _.template('hello ${ user }!');
   * compiled({ 'user': 'pebbles' });
   * // => 'hello pebbles!'
   *
   * // Use backslashes to treat delimiters as plain text.
   * var compiled = _.template('<%= "\\<%- value %\\>" %>');
   * compiled({ 'value': 'ignored' });
   * // => '<%- value %>'
   *
   * // Use the `imports` option to import `jQuery` as `jq`.
   * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
   * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the `sourceURL` option to specify a custom sourceURL for the template.
   * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
   *
   * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
   * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   * //   var __t, __p = '';
   * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
   * //   return __p;
   * // }
   *
   * // Use custom template delimiters.
   * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
   * var compiled = _.template('hello {{ user }}!');
   * compiled({ 'user': 'mustache' });
   * // => 'hello mustache!'
   *
   * // Use the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and stack traces.
   * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */

  function template(string, options, guard) {
    // Based on John Resig's `tmpl` implementation
    // (http://ejohn.org/blog/javascript-micro-templating/)
    // and Laura Doktorova's doT.js (https://github.com/olado/doT).
    var settings = templateSettings_1.imports._.templateSettings || templateSettings_1;

    if (guard && _isIterateeCall(string, options, guard)) {
      options = undefined;
    }

    string = toString_1(string);
    options = assignInWith_1({}, options, settings, _customDefaultsAssignIn);

    var imports = assignInWith_1({}, options.imports, settings.imports, _customDefaultsAssignIn),
        importsKeys = keys_1(imports),
        importsValues = _baseValues(imports, importsKeys);

    var isEscaping,
        isEvaluating,
        index = 0,
        interpolate = options.interpolate || reNoMatch,
        source = "__p += '"; // Compile the regexp to match each delimiter.

    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === _reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
    // The sourceURL gets injected into the source that's eval-ed, so be careful
    // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
    // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

    var sourceURL = hasOwnProperty$f.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
    string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

      source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar); // Replace delimiters with snippets.

      if (escapeValue) {
        isEscaping = true;
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }

      if (evaluateValue) {
        isEvaluating = true;
        source += "';\n" + evaluateValue + ";\n__p += '";
      }

      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }

      index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
      // order to produce the correct `offset` value.

      return match;
    });
    source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
    // code to add the data object to the top of the scope chain.
    // Like with sourceURL, we take care to not check the option's prototype,
    // as this configuration is a code injection vector.

    var variable = hasOwnProperty$f.call(options, 'variable') && options.variable;

    if (!variable) {
      source = 'with (obj) {\n' + source + '\n}\n';
    } // Cleanup code by stripping empty strings.


    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

    source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
    var result = attempt_1(function () {
      return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
    }); // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.

    result.source = source;

    if (isError_1(result)) {
      throw result;
    }

    return result;
  }

  var template_1 = template;
  /**
   * Converts `string`, as a whole, to lower case just like
   * [String#toLowerCase](https://mdn.io/toLowerCase).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the lower cased string.
   * @example
   *
   * _.toLower('--Foo-Bar--');
   * // => '--foo-bar--'
   *
   * _.toLower('fooBar');
   * // => 'foobar'
   *
   * _.toLower('__FOO_BAR__');
   * // => '__foo_bar__'
   */

  function toLower(value) {
    return toString_1(value).toLowerCase();
  }

  var toLower_1 = toLower;
  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   *
   * @param {Date|Number} argument - the value to convert
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Clone the date:
   * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert the timestamp to date:
   * const result = toDate(1392098430000)
   * //=> Tue Feb 11 2014 11:30:30
   */

  function toDate(argument) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var argStr = Object.prototype.toString.call(argument); // Clone the date

    if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime());
    } else if (typeof argument === 'number' || argStr === '[object Number]') {
      return new Date(argument);
    } else {
      if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
        // eslint-disable-next-line no-console
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

        console.warn(new Error().stack);
      }

      return new Date(NaN);
    }
  }

  function toInteger$1(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }

    var number = Number(dirtyNumber);

    if (isNaN(number)) {
      return number;
    }

    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }
  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be added
   * @returns {Date} the new date with the milliseconds added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */


  function addMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var timestamp = toDate(dirtyDate).getTime();
    var amount = toInteger$1(dirtyAmount);
    return new Date(timestamp + amount);
  }

  var MILLISECONDS_IN_MINUTE = 60000;
  /**
   * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
   * They usually appear for dates that denote time before the timezones were introduced
   * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
   * and GMT+01:00:00 after that date)
   *
   * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
   * which would lead to incorrect calculations.
   *
   * This function returns the timezone offset in milliseconds that takes seconds in account.
   */

  function getTimezoneOffsetInMilliseconds(dirtyDate) {
    var date = new Date(dirtyDate.getTime());
    var baseTimezoneOffset = date.getTimezoneOffset();
    date.setSeconds(0, 0);
    var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
    return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
  }
  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Now `isValid` doesn't throw an exception
   *   if the first argument is not an instance of Date.
   *   Instead, argument is converted beforehand using `toDate`.
   *
   *   Examples:
   *
   *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
   *   |---------------------------|---------------|---------------|
   *   | `new Date()`              | `true`        | `true`        |
   *   | `new Date('2016-01-01')`  | `true`        | `true`        |
   *   | `new Date('')`            | `false`       | `false`       |
   *   | `new Date(1488370835081)` | `true`        | `true`        |
   *   | `new Date(NaN)`           | `false`       | `false`       |
   *   | `'2016-01-01'`            | `TypeError`   | `true`        |
   *   | `''`                      | `TypeError`   | `false`       |
   *   | `1488370835081`           | `TypeError`   | `true`        |
   *   | `NaN`                     | `TypeError`   | `false`       |
   *
   *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
   *   that try to coerce arguments to the expected type
   *   (which is also the case with other *date-fns* functions).
   *
   * @param {*} date - the date to check
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // For the valid date:
   * var result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * var result = isValid(1393804800000)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * var result = isValid(new Date(''))
   * //=> false
   */


  function isValid(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    return !isNaN(date);
  }

  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },
    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },
    halfAMinute: 'half a minute',
    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },
    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },
    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },
    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },
    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },
    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },
    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },
    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },
    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },
    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },
    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  };

  function formatDistance(token, count, options) {
    options = options || {};
    var result;

    if (typeof formatDistanceLocale[token] === 'string') {
      result = formatDistanceLocale[token];
    } else if (count === 1) {
      result = formatDistanceLocale[token].one;
    } else {
      result = formatDistanceLocale[token].other.replace('{{count}}', count);
    }

    if (options.addSuffix) {
      if (options.comparison > 0) {
        return 'in ' + result;
      } else {
        return result + ' ago';
      }
    }

    return result;
  }

  function buildFormatLongFn(args) {
    return function (dirtyOptions) {
      var options = dirtyOptions || {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }

  var dateFormats = {
    full: 'EEEE, MMMM do, y',
    "long": 'MMMM do, y',
    medium: 'MMM d, y',
    "short": 'MM/dd/yyyy'
  };
  var timeFormats = {
    full: 'h:mm:ss a zzzz',
    "long": 'h:mm:ss a z',
    medium: 'h:mm:ss a',
    "short": 'h:mm a'
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    "long": "{{date}} 'at' {{time}}",
    medium: '{{date}}, {{time}}',
    "short": '{{date}}, {{time}}'
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: 'full'
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: 'full'
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: 'full'
    })
  };
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: 'P'
  };

  function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  }

  function buildLocalizeFn(args) {
    return function (dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var context = options.context ? String(options.context) : 'standalone';
      var valuesArray;

      if (context === 'formatting' && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;

        var _width = options.width ? String(options.width) : args.defaultWidth;

        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }

      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }

  var eraValues = {
    narrow: ['B', 'A'],
    abbreviated: ['BC', 'AD'],
    wide: ['Before Christ', 'Anno Domini']
  };
  var quarterValues = {
    narrow: ['1', '2', '3', '4'],
    abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
    wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

  };
  var monthValues = {
    narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
    abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };
  var dayValues = {
    narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    "short": ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  };
  var dayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    }
  };

  function ordinalNumber(dirtyNumber, _dirtyOptions) {
    var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`:
    //
    //   var options = dirtyOptions || {}
    //   var unit = String(options.unit)
    //
    // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'

    var rem100 = number % 100;

    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + 'st';

        case 2:
          return number + 'nd';

        case 3:
          return number + 'rd';
      }
    }

    return number + 'th';
  }

  var localize = {
    ordinalNumber: ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: 'wide'
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: 'wide',
      argumentCallback: function argumentCallback(quarter) {
        return Number(quarter) - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: 'wide'
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: 'wide'
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: 'wide',
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: 'wide'
    })
  };

  function buildMatchPatternFn(args) {
    return function (dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var matchResult = string.match(args.matchPattern);

      if (!matchResult) {
        return null;
      }

      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);

      if (!parseResult) {
        return null;
      }

      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value: value,
        rest: string.slice(matchedString.length)
      };
    };
  }

  function buildMatchFn(args) {
    return function (dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);

      if (!matchResult) {
        return null;
      }

      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var value;

      if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
        value = parsePatterns.findIndex(function (pattern) {
          return pattern.test(string);
        });
      } else {
        value = findKey(parsePatterns, function (pattern) {
          return pattern.test(string);
        });
      }

      value = args.valueCallback ? args.valueCallback(value) : value;
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value: value,
        rest: string.slice(matchedString.length)
      };
    };
  }

  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
  }

  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    "short": /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseEraPatterns,
      defaultParseWidth: 'any'
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: 'any',
      valueCallback: function valueCallback(index) {
        return index + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: 'any'
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseDayPatterns,
      defaultParseWidth: 'any'
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: 'any',
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: 'any'
    })
  };
  /**
   * @type {Locale}
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
   * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
   */

  var locale = {
    formatDistance: formatDistance,
    formatLong: formatLong,
    formatRelative: formatRelative,
    localize: localize,
    match: match,
    options: {
      weekStartsOn: 0
      /* Sunday */
      ,
      firstWeekContainsDate: 1
    }
  };
  /**
   * @name subMilliseconds
   * @category Millisecond Helpers
   * @summary Subtract the specified number of milliseconds from the given date.
   *
   * @description
   * Subtract the specified number of milliseconds from the given date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be subtracted
   * @returns {Date} the new date with the milliseconds subtracted
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
   * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:29.250
   */

  function subMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var amount = toInteger$1(dirtyAmount);
    return addMilliseconds(dirtyDate, -amount);
  }

  function addLeadingZeros(number, targetLength) {
    var sign = number < 0 ? '-' : '';
    var output = Math.abs(number).toString();

    while (output.length < targetLength) {
      output = '0' + output;
    }

    return sign + output;
  }
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* |                                |
   * |  d  | Day of month                   |  D  |                                |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  m  | Minute                         |  M  | Month                          |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  y  | Year (abs)                     |  Y  |                                |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   */


  var formatters = {
    // Year
    y: function y(date, token) {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
    },
    // Month
    M: function M(date, token) {
      var month = date.getUTCMonth();
      return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d: function d(date, token) {
      return addLeadingZeros(date.getUTCDate(), token.length);
    },
    // AM or PM
    a: function a(date, token) {
      var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return dayPeriodEnumValue.toUpperCase();

        case 'aaaaa':
          return dayPeriodEnumValue[0];

        case 'aaaa':
        default:
          return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
      }
    },
    // Hour [1-12]
    h: function h(date, token) {
      return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H: function H(date, token) {
      return addLeadingZeros(date.getUTCHours(), token.length);
    },
    // Minute
    m: function m(date, token) {
      return addLeadingZeros(date.getUTCMinutes(), token.length);
    },
    // Second
    s: function s(date, token) {
      return addLeadingZeros(date.getUTCSeconds(), token.length);
    },
    // Fraction of second
    S: function S(date, token) {
      var numberOfDigits = token.length;
      var milliseconds = date.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCDayOfYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCISOWeek(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function getUTCISOWeekYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCISOWeekYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var year = getUTCISOWeekYear(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary);
    return date;
  }

  var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCISOWeek(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)

    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCWeek(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function getUTCWeekYear(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var year = date.getUTCFullYear();
    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate);
    var year = getUTCWeekYear(dirtyDate, dirtyOptions);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek(firstWeek, dirtyOptions);
    return date;
  }

  var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCWeek(dirtyDate, options) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)

    return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
  }

  var dayPeriodEnum = {
    am: 'am',
    pm: 'pm',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */

  };
  var formatters$1 = {
    // Era
    G: function G(date, token, localize) {
      var era = date.getUTCFullYear() > 0 ? 1 : 0;

      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return localize.era(era, {
            width: 'abbreviated'
          });
        // A, B

        case 'GGGGG':
          return localize.era(era, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return localize.era(era, {
            width: 'wide'
          });
      }
    },
    // Year
    y: function y(date, token, localize) {
      // Ordinal number
      if (token === 'yo') {
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, {
          unit: 'year'
        });
      }

      return formatters.y(date, token);
    },
    // Local week-numbering year
    Y: function Y(date, token, localize, options) {
      var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

      if (token === 'YY') {
        var twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      } // Ordinal number


      if (token === 'Yo') {
        return localize.ordinalNumber(weekYear, {
          unit: 'year'
        });
      } // Padding


      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function R(date, token) {
      var isoWeekYear = getUTCISOWeekYear(date); // Padding

      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function u(date, token) {
      var year = date.getUTCFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function Q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
          return String(quarter);
        // 01, 02, 03, 04

        case 'QQ':
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone quarter
    q: function q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

      switch (token) {
        // 1, 2, 3, 4
        case 'q':
          return String(quarter);
        // 01, 02, 03, 04

        case 'qq':
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Month
    M: function M(date, token, localize) {
      var month = date.getUTCMonth();

      switch (token) {
        case 'M':
        case 'MM':
          return formatters.M(date, token);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return localize.month(month, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone month
    L: function L(date, token, localize) {
      var month = date.getUTCMonth();

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return String(month + 1);
        // 01, 02, ..., 12

        case 'LL':
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return localize.month(month, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Local week of year
    w: function w(date, token, localize, options) {
      var week = getUTCWeek(date, options);

      if (token === 'wo') {
        return localize.ordinalNumber(week, {
          unit: 'week'
        });
      }

      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function I(date, token, localize) {
      var isoWeek = getUTCISOWeek(date);

      if (token === 'Io') {
        return localize.ordinalNumber(isoWeek, {
          unit: 'week'
        });
      }

      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function d(date, token, localize) {
      if (token === 'do') {
        return localize.ordinalNumber(date.getUTCDate(), {
          unit: 'date'
        });
      }

      return formatters.d(date, token);
    },
    // Day of year
    D: function D(date, token, localize) {
      var dayOfYear = getUTCDayOfYear(date);

      if (token === 'Do') {
        return localize.ordinalNumber(dayOfYear, {
          unit: 'dayOfYear'
        });
      }

      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function E(date, token, localize) {
      var dayOfWeek = date.getUTCDay();

      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Local day of week
    e: function e(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case 'e':
          return String(localDayOfWeek);
        // Padded numerical value

        case 'ee':
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th

        case 'eo':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });

        case 'eee':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone local day of week
    c: function c(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

      switch (token) {
        // Numerical value (same as in `e`)
        case 'c':
          return String(localDayOfWeek);
        // Padded numerical value

        case 'cc':
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th

        case 'co':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });

        case 'ccc':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // ISO day of week
    i: function i(date, token, localize) {
      var dayOfWeek = date.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

      switch (token) {
        // 2
        case 'i':
          return String(isoDayOfWeek);
        // 02

        case 'ii':
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd

        case 'io':
          return localize.ordinalNumber(isoDayOfWeek, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'iiiii':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'iiiiii':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'iiii':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM or PM
    a: function a(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'aaaaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM, PM, midnight, noon
    b: function b(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;

      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
      }

      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'bbbbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function B(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;

      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }

      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'BBBBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Hour [1-12]
    h: function h(date, token, localize) {
      if (token === 'ho') {
        var hours = date.getUTCHours() % 12;
        if (hours === 0) hours = 12;
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return formatters.h(date, token);
    },
    // Hour [0-23]
    H: function H(date, token, localize) {
      if (token === 'Ho') {
        return localize.ordinalNumber(date.getUTCHours(), {
          unit: 'hour'
        });
      }

      return formatters.H(date, token);
    },
    // Hour [0-11]
    K: function K(date, token, localize) {
      var hours = date.getUTCHours() % 12;

      if (token === 'Ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function k(date, token, localize) {
      var hours = date.getUTCHours();
      if (hours === 0) hours = 24;

      if (token === 'ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function m(date, token, localize) {
      if (token === 'mo') {
        return localize.ordinalNumber(date.getUTCMinutes(), {
          unit: 'minute'
        });
      }

      return formatters.m(date, token);
    },
    // Second
    s: function s(date, token, localize) {
      if (token === 'so') {
        return localize.ordinalNumber(date.getUTCSeconds(), {
          unit: 'second'
        });
      }

      return formatters.s(date, token);
    },
    // Fraction of second
    S: function S(date, token) {
      return formatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function X(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      if (timezoneOffset === 0) {
        return 'Z';
      }

      switch (token) {
        // Hours and optional minutes
        case 'X':
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`

        case 'XXXX':
        case 'XX':
          // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`

        case 'XXXXX':
        case 'XXX': // Hours and minutes with `:` delimiter

        default:
          return formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function x(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Hours and optional minutes
        case 'x':
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`

        case 'xxxx':
        case 'xx':
          // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`

        case 'xxxxx':
        case 'xxx': // Hours and minutes with `:` delimiter

        default:
          return formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (GMT)
    O: function O(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case 'O':
        case 'OO':
        case 'OOO':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
        // Long

        case 'OOOO':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (specific non-location)
    z: function z(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case 'z':
        case 'zz':
        case 'zzz':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
        // Long

        case 'zzzz':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':');
      }
    },
    // Seconds timestamp
    t: function t(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = Math.floor(originalDate.getTime() / 1000);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function T(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = originalDate.getTime();
      return addLeadingZeros(timestamp, token.length);
    }
  };

  function formatTimezoneShort(offset, dirtyDelimiter) {
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;

    if (minutes === 0) {
      return sign + String(hours);
    }

    var delimiter = dirtyDelimiter || '';
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }

  function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? '-' : '+';
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }

    return formatTimezone(offset, dirtyDelimiter);
  }

  function formatTimezone(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    var minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }

  function dateLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'P':
        return formatLong.date({
          width: 'short'
        });

      case 'PP':
        return formatLong.date({
          width: 'medium'
        });

      case 'PPP':
        return formatLong.date({
          width: 'long'
        });

      case 'PPPP':
      default:
        return formatLong.date({
          width: 'full'
        });
    }
  }

  function timeLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'p':
        return formatLong.time({
          width: 'short'
        });

      case 'pp':
        return formatLong.time({
          width: 'medium'
        });

      case 'ppp':
        return formatLong.time({
          width: 'long'
        });

      case 'pppp':
      default:
        return formatLong.time({
          width: 'full'
        });
    }
  }

  function dateTimeLongFormatter(pattern, formatLong) {
    var matchResult = pattern.match(/(P+)(p+)?/);
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];

    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong);
    }

    var dateTimeFormat;

    switch (datePattern) {
      case 'P':
        dateTimeFormat = formatLong.dateTime({
          width: 'short'
        });
        break;

      case 'PP':
        dateTimeFormat = formatLong.dateTime({
          width: 'medium'
        });
        break;

      case 'PPP':
        dateTimeFormat = formatLong.dateTime({
          width: 'long'
        });
        break;

      case 'PPPP':
      default:
        dateTimeFormat = formatLong.dateTime({
          width: 'full'
        });
        break;
    }

    return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
  }

  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var protectedDayOfYearTokens = ['D', 'DD'];
  var protectedWeekYearTokens = ['YY', 'YYYY'];

  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }

  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }

  function throwProtectedError(token) {
    if (token === 'YYYY') {
      throw new RangeError('Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr');
    } else if (token === 'YY') {
      throw new RangeError('Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr');
    } else if (token === 'D') {
      throw new RangeError('Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr');
    } else if (token === 'DD') {
      throw new RangeError('Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr');
    }
  } // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps


  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'(.*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. The result may vary by locale.
   *
   * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   * (see the last example)
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 7 below the table).
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   | Notes |
   * |---------------------------------|---------|-----------------------------------|-------|
   * | Era                             | G..GGG  | AD, BC                            |       |
   * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 | GGGGG   | A, B                              |       |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
   * |                                 | yy      | 44, 01, 00, 17                    | 5     |
   * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
   * |                                 | yyyyy   | ...                               | 3,5   |
   * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
   * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
   * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
   * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
   * |                                 | YYYYY   | ...                               | 3,5   |
   * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
   * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
   * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
   * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
   * |                                 | RRRRR   | ...                               | 3,5,7 |
   * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
   * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
   * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
   * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
   * |                                 | uuuuu   | ...                               | 3,5   |
   * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
   * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | QQ      | 01, 02, 03, 04                    |       |
   * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
   * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | qq      | 01, 02, 03, 04                    |       |
   * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
   * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | MM      | 01, 02, ..., 12                   |       |
   * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 | MMMM    | January, February, ..., December  | 2     |
   * |                                 | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
   * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | LL      | 01, 02, ..., 12                   |       |
   * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 | LLLL    | January, February, ..., December  | 2     |
   * |                                 | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | w       | 1, 2, ..., 53                     |       |
   * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
   * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | II      | 01, 02, ..., 53                   | 7     |
   * | Day of month                    | d       | 1, 2, ..., 31                     |       |
   * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
   * |                                 | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
   * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
   * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
   * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 | DDDD    | ...                               | 3     |
   * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
   * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
   * |                                 | ii      | 01, 02, ..., 07                   | 7     |
   * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
   * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
   * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
   * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
   * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | ee      | 02, 03, ..., 01                   |       |
   * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | cc      | 02, 03, ..., 01                   |       |
   * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          | a..aaa  | AM, PM                            |       |
   * |                                 | aaaa    | a.m., p.m.                        | 2     |
   * |                                 | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
   * |                                 | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
   * |                                 | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
   * |                                 | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
   * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
   * |                                 | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          | m       | 0, 1, ..., 59                     |       |
   * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | mm      | 00, 01, ..., 59                   |       |
   * | Second                          | s       | 0, 1, ..., 59                     |       |
   * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | ss      | 00, 01, ..., 59                   |       |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
   * |                                 | SS      | 00, 01, ..., 99                   |       |
   * |                                 | SSS     | 000, 0001, ..., 999               |       |
   * |                                 | SSSS    | ...                               | 3     |
   * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
   * |                                 | XX      | -0800, +0530, Z                   |       |
   * |                                 | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
   * |                                 | xx      | -0800, +0530, +0000               |       |
   * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
   * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
   * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
   * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
   * | Seconds timestamp               | t       | 512969520                         | 7     |
   * |                                 | tt      | ...                               | 3,7   |
   * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
   * |                                 | TT      | ...                               | 3,7   |
   * | Long localized date             | P       | 05/29/1453                        | 7     |
   * |                                 | PP      | May 29, 1453                      | 7     |
   * |                                 | PPP     | May 29th, 1453                    | 7     |
   * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
   * | Long localized time             | p       | 12:00 AM                          | 7     |
   * |                                 | pp      | 12:00:00 AM                       | 7     |
   * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
   * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
   * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
   * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
   * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
   * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
   *    the output will be the same as default pattern for this unit, usually
   *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
   *    are marked with "2" in the last column of the table.
   *
   *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
   *
   * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
   *    The output will be padded with zeros to match the length of the pattern.
   *
   *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
   *
   * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 5. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` always returns the last two digits of a year,
   *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
   *
   *    | Year | `yy` | `uu` |
   *    |------|------|------|
   *    | 1    |   01 |   01 |
   *    | 14   |   14 |   14 |
   *    | 376  |   76 |  376 |
   *    | 1453 |   53 | 1453 |
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
   *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
   *
   * 6. Specific non-location timezones are currently unavailable in `date-fns`,
   *    so right now these tokens fall back to GMT timezones.
   *
   * 7. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `t`: seconds timestamp
   *    - `T`: milliseconds timestamp
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The second argument is now required for the sake of explicitness.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   format(new Date(2016, 0, 1))
   *
   *   // v2.0.0 onward
   *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
   *   ```
   *
   * - New format string API for `format` function
   *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
   *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
   *
   * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
   *
   * @param {Date|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://git.io/fxCyr
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://git.io/fxCyr
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
   *   locale: eoLocale
   * })
   * //=> '2-a de julio 2014'
   *
   * @example
   * // Escape string by single quote characters:
   * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
   * //=> "3 o'clock"
   */

  function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var formatStr = String(dirtyFormatStr);
    var options = dirtyOptions || {};
    var locale$1 = options.locale || locale;
    var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    if (!locale$1.localize) {
      throw new RangeError('locale must contain localize property');
    }

    if (!locale$1.formatLong) {
      throw new RangeError('locale must contain formatLong property');
    }

    var originalDate = toDate(dirtyDate);

    if (!isValid(originalDate)) {
      throw new RangeError('Invalid time value');
    } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


    var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
    var utcDate = subMilliseconds(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale$1,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
      var firstCharacter = substring[0];

      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale$1.formatLong, formatterOptions);
      }

      return substring;
    }).join('').match(formattingTokensRegExp).map(function (substring) {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return "'";
      }

      var firstCharacter = substring[0];

      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }

      var formatter = formatters$1[firstCharacter];

      if (formatter) {
        if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
          throwProtectedError(substring);
        }

        if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
          throwProtectedError(substring);
        }

        return formatter(utcDate, substring, locale$1.localize, formatterOptions);
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      }

      return substring;
    }).join('');
    return result;
  }

  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }

  function assign$1(target, dirtyObject) {
    if (target == null) {
      throw new TypeError('assign requires that input parameter not be null or undefined');
    }

    dirtyObject = dirtyObject || {};

    for (var property in dirtyObject) {
      if (dirtyObject.hasOwnProperty(property)) {
        target[property] = dirtyObject[property];
      }
    }

    return target;
  }
  /**
   * @name isAfter
   * @category Common Helpers
   * @summary Is the first date after the second one?
   *
   * @description
   * Is the first date after the second one?
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date that should be after the other one to return true
   * @param {Date|Number} dateToCompare - the date to compare with
   * @returns {Boolean} the first date is after the second date
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Is 10 July 1989 after 11 February 1987?
   * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> true
   */


  function isAfter(dirtyDate, dirtyDateToCompare) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() > dateToCompare.getTime();
  }
  /**
   * @name isBefore
   * @category Common Helpers
   * @summary Is the first date before the second one?
   *
   * @description
   * Is the first date before the second one?
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date that should be before the other one to return true
   * @param {Date|Number} dateToCompare - the date to compare with
   * @returns {Boolean} the first date is before the second date
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Is 10 July 1989 before 11 February 1987?
   * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> false
   */


  function isBefore(dirtyDate, dirtyDateToCompare) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() < dateToCompare.getTime();
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    var date = toDate(dirtyDate);
    var day = toInteger$1(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCISODay(dirtyDate, dirtyDay) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var day = toInteger$1(dirtyDay);

    if (day % 7 === 0) {
      day = day - 7;
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var isoWeek = toInteger$1(dirtyISOWeek);
    var diff = getUTCISOWeek(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var week = toInteger$1(dirtyWeek);
    var diff = getUTCWeek(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE$1 = 60000;
  var MILLISECONDS_IN_SECOND = 1000;
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59
    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

  };
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

  function parseNumericPattern(pattern, string, valueCallback) {
    var matchResult = string.match(pattern);

    if (!matchResult) {
      return null;
    }

    var value = parseInt(matchResult[0], 10);
    return {
      value: valueCallback ? valueCallback(value) : value,
      rest: string.slice(matchResult[0].length)
    };
  }

  function parseTimezonePattern(pattern, string) {
    var matchResult = string.match(pattern);

    if (!matchResult) {
      return null;
    } // Input is 'Z'


    if (matchResult[0] === 'Z') {
      return {
        value: 0,
        rest: string.slice(1)
      };
    }

    var sign = matchResult[1] === '+' ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1 + seconds * MILLISECONDS_IN_SECOND),
      rest: string.slice(matchResult[0].length)
    };
  }

  function parseAnyDigitsSigned(string, valueCallback) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
  }

  function parseNDigits(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

      default:
        return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
    }
  }

  function parseNDigitsSigned(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

      default:
        return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
    }
  }

  function dayPeriodEnumToHours(enumValue) {
    switch (enumValue) {
      case 'morning':
        return 4;

      case 'evening':
        return 17;

      case 'pm':
      case 'noon':
      case 'afternoon':
        return 12;

      case 'am':
      case 'midnight':
      case 'night':
      default:
        return 0;
    }
  }

  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0; // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC

    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;

    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }

    return isCommonEra ? result : 1 - result;
  }

  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // User for validation

  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
   * |  p  |                                |  P  |                                |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   */


  var parsers = {
    // Era
    G: {
      priority: 140,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return match.era(string, {
              width: 'abbreviated'
            }) || match.era(string, {
              width: 'narrow'
            });
          // A, B

          case 'GGGGG':
            return match.era(string, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return match.era(string, {
              width: 'wide'
            }) || match.era(string, {
              width: 'abbreviated'
            }) || match.era(string, {
              width: 'narrow'
            });
        }
      },
      set: function set(date, flags, value, _options) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['R', 'u', 't', 'T']
    },
    // Year
    y: {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
      priority: 130,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'yy'
          };
        };

        switch (token) {
          case 'y':
            return parseNDigits(4, string, valueCallback);

          case 'yo':
            return match.ordinalNumber(string, {
              unit: 'year',
              valueCallback: valueCallback
            });

          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function validate(_date, value, _options) {
        return value.isTwoDigitYear || value.year > 0;
      },
      set: function set(date, flags, value, _options) {
        var currentYear = date.getUTCFullYear();

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
    },
    // Local week-numbering year
    Y: {
      priority: 130,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'YY'
          };
        };

        switch (token) {
          case 'Y':
            return parseNDigits(4, string, valueCallback);

          case 'Yo':
            return match.ordinalNumber(string, {
              unit: 'year',
              valueCallback: valueCallback
            });

          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function validate(_date, value, _options) {
        return value.isTwoDigitYear || value.year > 0;
      },
      set: function set(date, flags, value, options) {
        var currentYear = getUTCWeekYear(date, options);

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      },
      incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
    },
    // ISO week-numbering year
    R: {
      priority: 130,
      parse: function parse(string, token, _match, _options) {
        if (token === 'R') {
          return parseNDigitsSigned(4, string);
        }

        return parseNDigitsSigned(token.length, string);
      },
      set: function set(_date, _flags, value, _options) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek(firstWeekOfYear);
      },
      incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
    },
    // Extended year
    u: {
      priority: 130,
      parse: function parse(string, token, _match, _options) {
        if (token === 'u') {
          return parseNDigitsSigned(4, string);
        }

        return parseNDigitsSigned(token.length, string);
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
    },
    // Quarter
    Q: {
      priority: 120,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
          case 'QQ':
            // 01, 02, 03, 04
            return parseNDigits(token.length, string);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return match.ordinalNumber(string, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return match.quarter(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return match.quarter(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 4;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Stand-alone quarter
    q: {
      priority: 120,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
          case 'qq':
            // 01, 02, 03, 04
            return parseNDigits(token.length, string);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return match.ordinalNumber(string, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return match.quarter(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return match.quarter(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 4;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Month
    M: {
      priority: 110,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'M':
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          // 01, 02, ..., 12

          case 'MM':
            return parseNDigits(2, string, valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return match.ordinalNumber(string, {
              unit: 'month',
              valueCallback: valueCallback
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return match.month(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return match.month(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.month(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Stand-alone month
    L: {
      priority: 110,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          // 01, 02, ..., 12

          case 'LL':
            return parseNDigits(2, string, valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return match.ordinalNumber(string, {
              unit: 'month',
              valueCallback: valueCallback
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return match.month(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return match.month(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.month(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Local week of year
    w: {
      priority: 100,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'w':
            return parseNumericPattern(numericPatterns.week, string);

          case 'wo':
            return match.ordinalNumber(string, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 53;
      },
      set: function set(date, _flags, value, options) {
        return startOfUTCWeek(setUTCWeek(date, value, options), options);
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
    },
    // ISO week of year
    I: {
      priority: 100,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'I':
            return parseNumericPattern(numericPatterns.week, string);

          case 'Io':
            return match.ordinalNumber(string, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 53;
      },
      set: function set(date, _flags, value, options) {
        return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
      },
      incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
    },
    // Day of the month
    d: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'd':
            return parseNumericPattern(numericPatterns.date, string);

          case 'do':
            return match.ordinalNumber(string, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(date, value, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();

        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Day of year
    D: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'D':
          case 'DD':
            return parseNumericPattern(numericPatterns.dayOfYear, string);

          case 'Do':
            return match.ordinalNumber(string, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(date, value, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
    },
    // Day of week
    E: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
    },
    // Local day of week
    e: {
      priority: 90,
      parse: function parse(string, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'e':
          case 'ee':
            // 03
            return parseNDigits(token.length, string, valueCallback);
          // 3rd

          case 'eo':
            return match.ordinalNumber(string, {
              unit: 'day',
              valueCallback: valueCallback
            });
          // Tue

          case 'eee':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
    },
    // Stand-alone local day of week
    c: {
      priority: 90,
      parse: function parse(string, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'c':
          case 'cc':
            // 03
            return parseNDigits(token.length, string, valueCallback);
          // 3rd

          case 'co':
            return match.ordinalNumber(string, {
              unit: 'day',
              valueCallback: valueCallback
            });
          // Tue

          case 'ccc':
            return match.day(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
    },
    // ISO day of week
    i: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          if (value === 0) {
            return 7;
          }

          return value;
        };

        switch (token) {
          // 2
          case 'i':
          case 'ii':
            // 02
            return parseNDigits(token.length, string);
          // 2nd

          case 'io':
            return match.ordinalNumber(string, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // T

          case 'iiiii':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // Tu

          case 'iiiiii':
            return match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // Tuesday

          case 'iiii':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 7;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCISODay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
    },
    // AM or PM
    a: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaaa':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['b', 'B', 'H', 'K', 'k', 't', 'T']
    },
    // AM, PM, midnight
    b: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbbb':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'B', 'H', 'K', 'k', 't', 'T']
    },
    // in the morning, in the afternoon, in the evening, at night
    B: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBBB':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 't', 'T']
    },
    // Hour [1-12]
    h: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'h':
            return parseNumericPattern(numericPatterns.hour12h, string);

          case 'ho':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 12;
      },
      set: function set(date, _flags, value, _options) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      },
      incompatibleTokens: ['H', 'K', 'k', 't', 'T']
    },
    // Hour [0-23]
    H: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'H':
            return parseNumericPattern(numericPatterns.hour23h, string);

          case 'Ho':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 23;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
    },
    // Hour [0-11]
    K: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'K':
            return parseNumericPattern(numericPatterns.hour11h, string);

          case 'Ko':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'H', 'k', 't', 'T']
    },
    // Hour [1-24]
    k: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'k':
            return parseNumericPattern(numericPatterns.hour24h, string);

          case 'ko':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 24;
      },
      set: function set(date, _flags, value, _options) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
    },
    // Minute
    m: {
      priority: 60,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'm':
            return parseNumericPattern(numericPatterns.minute, string);

          case 'mo':
            return match.ordinalNumber(string, {
              unit: 'minute'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 59;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Second
    s: {
      priority: 50,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 's':
            return parseNumericPattern(numericPatterns.second, string);

          case 'so':
            return match.ordinalNumber(string, {
              unit: 'second'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 59;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCSeconds(value, 0);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Fraction of second
    S: {
      priority: 30,
      parse: function parse(string, token, _match, _options) {
        var valueCallback = function valueCallback(value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };

        return parseNDigits(token.length, string, valueCallback);
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMilliseconds(value);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Timezone (ISO-8601. +00:00 is `'Z'`)
    X: {
      priority: 10,
      parse: function parse(string, token, _match, _options) {
        switch (token) {
          case 'X':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

          case 'XX':
            return parseTimezonePattern(timezonePatterns.basic, string);

          case 'XXXX':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

          case 'XXXXX':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

          case 'XXX':
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function set(date, flags, value, _options) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      },
      incompatibleTokens: ['t', 'T', 'x']
    },
    // Timezone (ISO-8601)
    x: {
      priority: 10,
      parse: function parse(string, token, _match, _options) {
        switch (token) {
          case 'x':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

          case 'xx':
            return parseTimezonePattern(timezonePatterns.basic, string);

          case 'xxxx':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

          case 'xxxxx':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

          case 'xxx':
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function set(date, flags, value, _options) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      },
      incompatibleTokens: ['t', 'T', 'X']
    },
    // Seconds timestamp
    t: {
      priority: 40,
      parse: function parse(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function set(_date, _flags, value, _options) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: '*'
    },
    // Milliseconds timestamp
    T: {
      priority: 20,
      parse: function parse(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function set(_date, _flags, value, _options) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: '*'
    }
  };
  var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps

  var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

  var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp$1 = /^'(.*?)'?$/;
  var doubleQuoteRegExp$1 = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format string.
   *
   * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters in the format string wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the format string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 5 below the table).
   *
   * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
   * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
   *
   * ```javascript
   * parse('23 AM', 'HH a', new Date())
   * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
   * ```
   *
   * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
   *
   * Accepted format string patterns:
   * | Unit                            |Prior| Pattern | Result examples                   | Notes |
   * |---------------------------------|-----|---------|-----------------------------------|-------|
   * | Era                             | 140 | G..GGG  | AD, BC                            |       |
   * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 |     | GGGGG   | A, B                              |       |
   * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
   * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
   * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
   * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
   * |                                 |     | yyyyy   | ...                               | 2,4   |
   * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
   * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
   * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
   * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
   * |                                 |     | YYYYY   | ...                               | 2,4   |
   * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
   * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
   * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
   * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
   * |                                 |     | RRRRR   | ...                               | 2,4,5 |
   * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
   * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
   * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
   * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
   * |                                 |     | uuuuu   | ...                               | 2,4   |
   * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
   * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
   * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
   * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | qq      | 01, 02, 03, 04                    |       |
   * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
   * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
   * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | MM      | 01, 02, ..., 12                   |       |
   * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | MMMM    | January, February, ..., December  | 2     |
   * |                                 |     | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
   * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | LL      | 01, 02, ..., 12                   |       |
   * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | LLLL    | January, February, ..., December  | 2     |
   * |                                 |     | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
   * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
   * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
   * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
   * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
   * |                                 |     | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
   * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
   * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
   * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 |     | DDDD    | ...                               | 2     |
   * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
   * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
   * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
   * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
   * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
   * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
   * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 5     |
   * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | ee      | 02, 03, ..., 01                   |       |
   * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | cc      | 02, 03, ..., 01                   |       |
   * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
   * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
   * |                                 |     | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 |     | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
   * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
   * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
   * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
   * |                                 |     | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
   * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
   * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | mm      | 00, 01, ..., 59                   |       |
   * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
   * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | ss      | 00, 01, ..., 59                   |       |
   * | Seconds timestamp               |  40 | t       | 512969520                         |       |
   * |                                 |     | tt      | ...                               | 2     |
   * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
   * |                                 |     | SS      | 00, 01, ..., 99                   |       |
   * |                                 |     | SSS     | 000, 0001, ..., 999               |       |
   * |                                 |     | SSSS    | ...                               | 2     |
   * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
   * |                                 |     | TT      | ...                               | 2     |
   * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
   * |                                 |     | XX      | -0800, +0530, Z                   |       |
   * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
   * |                                 |     | xx      | -0800, +0530, +0000               |       |
   * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
   * |                                 |     | PP      | May 29, 1453                      |       |
   * |                                 |     | PPP     | May 29th, 1453                    |       |
   * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
   * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
   * |                                 |     | pp      | 12:00:00 AM                       |       |
   * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
   * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
   * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
   * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular.
   *    In `format` function, they will produce different result:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   *    `parse` will try to match both formatting and stand-alone units interchangably.
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table:
   *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
   *      as wide as the sequence
   *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
   *      These variations are marked with "2" in the last column of the table.
   *
   * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 4. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` will try to guess the century of two digit year by proximity with `backupDate`:
   *
   *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
   *
   *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
   *
   *    while `uu` will just assign the year as is:
   *
   *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
   *
   *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
   *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
   *
   * 5. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
   *    on the given locale.
   *
   *    using `en-US` locale: `P` => `MM/dd/yyyy`
   *    using `en-US` locale: `p` => `hh:mm a`
   *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
   *    using `pt-BR` locale: `p` => `HH:mm`
   *
   * Values will be assigned to the date in the descending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `backupDate` which works as a context of parsing.
   *
   * `backupDate` must be passed for correct work of the function.
   * If you're not sure which `backupDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `backupDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `backupDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Old `parse` was renamed to `toDate`.
   *   Now `parse` is a new function which parses a string using a provided format.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   toDate('2016-01-01')
   *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
   *   ```
   *
   * @param {String} dateString - the string to parse
   * @param {String} formatString - the string of tokens
   * @param {Date|Number} backupDate - defines values missing from the parsed dateString
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://git.io/fxCyr
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://git.io/fxCyr
   * @returns {Date} the parsed date
   * @throws {TypeError} 3 arguments required
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} `options.locale` must contain `match` property
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in Esperanto locale in the context of 2010 year:
   * import eo from 'date-fns/locale/eo'
   * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
   *   locale: eo
   * })
   * //=> Sun Feb 28 2010 00:00:00
   */

  function parse(dirtyDateString, dirtyFormatString, dirtyBackupDate, dirtyOptions) {
    if (arguments.length < 3) {
      throw new TypeError('3 arguments required, but only ' + arguments.length + ' present');
    }

    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var options = dirtyOptions || {};
    var locale$1 = options.locale || locale;

    if (!locale$1.match) {
      throw new RangeError('locale must contain match property');
    }

    var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    if (formatString === '') {
      if (dateString === '') {
        return toDate(dirtyBackupDate);
      } else {
        return new Date(NaN);
      }
    }

    var subFnOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale$1 // If timezone isn't specified, it will be set to the system timezone

    };
    var setters = [{
      priority: TIMEZONE_UNIT_PRIORITY,
      set: dateToSystemTimezone,
      index: 0
    }];
    var i;
    var tokens = formatString.match(longFormattingTokensRegExp$1).map(function (substring) {
      var firstCharacter = substring[0];

      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale$1.formatLong, subFnOptions);
      }

      return substring;
    }).join('').match(formattingTokensRegExp$1);
    var usedTokens = [];

    for (i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
        throwProtectedError(token);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token);
      }

      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = void 0;

          for (var _i = 0; _i < usedTokens.length; _i++) {
            var usedToken = usedTokens[_i].token;

            if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
              incompatibleToken = usedTokens[_i];
              break;
            }
          }

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.parse(dateString, token, locale$1.match, subFnOptions);

        if (!parseResult) {
          return new Date(NaN);
        }

        setters.push({
          priority: parser.priority,
          set: parser.set,
          validate: parser.validate,
          value: parseResult.value,
          index: setters.length
        });
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString$1(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return new Date(NaN);
        }
      }
    } // Check if the remaining input contains something other than whitespace


    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }

    var uniquePrioritySetters = setters.map(function (setter) {
      return setter.priority;
    }).sort(function (a, b) {
      return b - a;
    }).filter(function (priority, index, array) {
      return array.indexOf(priority) === index;
    }).map(function (priority) {
      return setters.filter(function (setter) {
        return setter.priority === priority;
      }).reverse();
    }).map(function (setterArray) {
      return setterArray[0];
    });
    var date = toDate(dirtyBackupDate);

    if (isNaN(date)) {
      return new Date(NaN);
    } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


    var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
    var flags = {};

    for (i = 0; i < uniquePrioritySetters.length; i++) {
      var setter = uniquePrioritySetters[i];

      if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

      if (result[0]) {
        utcDate = result[0];
        assign$1(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }

    return utcDate;
  }

  function dateToSystemTimezone(date, flags) {
    if (flags.timestampIsSet) {
      return date;
    }

    var convertedDate = new Date(0);
    convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    return convertedDate;
  }

  function cleanEscapedString$1(input) {
    return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
  }

  var MILLISECONDS_IN_HOUR$1 = 3600000;
  var MILLISECONDS_IN_MINUTE$2 = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  /**
   * @name parseISO
   * @category Common Helpers
   * @summary Parse ISO string
   *
   * @description
   * Parse the given string in ISO 8601 format and return an instance of Date.
   *
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument isn't a string, the function cannot parse the string or
   * the values are invalid, it returns Invalid Date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The previous `parse` implementation was renamed to `parseISO`.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   parseISO('2016-01-01')
   *   ```
   *
   * - `parseISO` now validates separate date and time values in ISO-8601 strings
   *   and returns `Invalid Date` if the date is invalid.
   *
   *   ```javascript
   *   parseISO('2018-13-32')
   *   //=> Invalid Date
   *   ```
   *
   * - `parseISO` now doesn't fall back to `new Date` constructor
   *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
   *
   * @param {String} argument - the value to convert
   * @param {Object} [options] - an object with options.
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = parseISO('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = parseISO('+02014101', { additionalDigits: 1 })
   * //=> Fri Apr 11 2014 00:00:00
   */

  function parseISO(argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger$1(options.additionalDigits);

    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2');
    }

    if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
      return new Date(NaN);
    }

    var dateStrings = splitDateString(argument);
    var date;

    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }

    if (isNaN(date) || !date) {
      return new Date(NaN);
    }

    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);

      if (isNaN(time) || time === null) {
        return new Date(NaN);
      }
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);

      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var fullTime = timestamp + time;
      var fullTimeDate = new Date(fullTime);
      offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST

      var fullTimeDateNextDay = new Date(fullTime);
      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);
      var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - offset;

      if (offsetDiff > 0) {
        offset += offsetDiff;
      }
    }

    return new Date(timestamp + time + offset);
  }

  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;

    if (/:/.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];

      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }

    if (timeString) {
      var token = patterns.timezone.exec(timeString);

      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings;
  }

  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
    var captures = dateString.match(regex); // Invalid ISO-formatted year

    if (!captures) return {
      year: null
    };
    var year = captures[1] && parseInt(captures[1]);
    var century = captures[2] && parseInt(captures[2]);
    return {
      year: century == null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }

  function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return null;
    var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

    if (!captures) return null;
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;

    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }

      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date = new Date(0);

      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }

      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }

  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }

  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures) return null; // Invalid ISO-formatted time

    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);

    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }

    return hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2 + seconds * 1000;
  }

  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(',', '.')) || 0;
  }

  function parseTimezone(timezoneString) {
    if (timezoneString === 'Z') return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    var sign = captures[1] === '+' ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;

    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }

    return sign * (hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2);
  }

  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // Validation functions
  // February is null to handle the leap year (using ||)


  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function isLeapYearIndex$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100;
  }

  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex$1(year) ? 29 : 28));
  }

  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$1(year) ? 366 : 365);
  }

  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }

  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }

    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }

  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  var parseDate$1 = function parseDate(value, format) {
    if (isString_1(value)) {
      return format ? parse(value, format, new Date()) : parseISO(value);
    } else {
      return toDate(value);
    }
  }; // We want to set the messages a superglobal so that imports across files
  // reference the same messages object.


  var _global = typeof window !== 'undefined' ? window : commonjsGlobal || {};
  /**
   * Global validation message registry.
   */


  var messages = _global.__vuemc_validation_messages = _global.__vuemc_validation_messages || new ( /*#__PURE__*/function () {
    function _class() {
      _classCallCheck(this, _class);

      this.reset();
    }
    /**
     * Resets everything to the default configuration.
     */


    _createClass(_class, [{
      key: "reset",
      value: function reset() {
        this.$locale = 'en-us';
        this.$fallback = 'en-us';
        this.$locales = {};
        this.register(en_us);
      }
      /**
       * Sets the active locale.
       *
       * @param {string} locale
       */

    }, {
      key: "locale",
      value: function locale(_locale) {
        this.$locale = toLower_1(_locale);
      }
      /**
       * Registers a language pack.
       */

    }, {
      key: "register",
      value: function register(bundle) {
        var _this = this;

        var locale = toLower_1(bundle.locale);
        each(get_1(bundle, 'messages', {}), function (message, name) {
          set_1(_this.$locales, [locale, name], template_1(message));
        });
      }
      /**
       * Replaces or adds a new message for a given name and optional locale.
       *
       * @param {string} name
       * @param {string} format
       */

    }, {
      key: "set",
      value: function set(name, format, locale) {
        var $template = isString_1(format) ? template_1(format) : format; // Use the given locale.

        if (locale) {
          set_1(this.$locales, [locale, name], $template); // Otherwise use the active locale.
        } else if (this.$locale) {
          set_1(this.$locales, [this.$locale, name], $template); // Otherwise fall back to the default locale.
        } else {
          set_1(this.$locales, [this.$fallback, name], $template);
        }
      }
      /**
       * Returns a formatted string for a given message name and context data.
       *
       * @param {string} name
       * @param {Object} data
       *
       * @returns {string} The formatted message.
       */

    }, {
      key: "get",
      value: function get(name) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Attempt to find the name using the active locale, falling back to the
        // active locale's language, and finally falling back to the default.

        var template = get_1(this.$locales, [this.$locale, name], get_1(this.$locales, [split_1(this.$locale, '-')[0], name], get_1(this.$locales, [this.$fallback, name]))); // Fall back to a blank string so that we don't potentially
        // leak message names or context data into the template.

        if (!template) {
          return '';
        }

        return template(data);
      }
    }]);

    return _class;
  }())();
  /**
   * Rule helpers for easy validation.
   * These can all be used directly in a model's validation configuration.
   *
   * @example
   *
   * import {ascii, length} from 'vue-mc/validation'
   *
   * class User extends Model {
   *     validation() {
   *         return {
   *             password: ascii.and(length(6)),
   *         }
   *     }
   * }
   */

  /**
   * Creates a new validation rule.
   *
   * Rules returned by this function can be chained with `or` and `and`.
   * For example: `ruleA.or(ruleB.and(RuleC)).and(RuleD)`
   *
   * The error message can be set or replaced using `format(message|template)`.
   *
   * @param {Object} config:
   *     - name: Name of the error message.
   *     - data: Context for the error message.
   *     - test: Function accepting (value, model), which should
   *             return `true` if the value is valid.
   *
   * @returns {Function} Validation rule.
   */

  var rule = function rule(config) {
    var name = get_1(config, 'name');
    var data = get_1(config, 'data', {});
    var test = get_1(config, 'test', stubTrue_1);
    /**
     * This is the function that is called when using this rule.
     * It has some extra metadata to allow rule chaining and custom formats.
     */

    var $rule = function $rule(value, attribute, model) {
      // `true` if this rule's core acceptance criteria was met.
      var valid = test(value, attribute, model); // If valid, check that all rules in the "and" chain also pass.

      if (valid) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = $rule._and[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _and = _step.value;

            var result = _and(value, attribute, model); // If any of the chained rules return a string, we know that
            // that rule has failed, and therefore this chain is invalid.


            if (isString_1(result)) {
              return result;
            }
          } // Either there weren't any "and" rules or they all passed.

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true; // This rule's acceptance criteria was not met, but there is a chance
        // that a rule in the "or" chain's might pass.
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = $rule._or[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _or = _step2.value;

            var _result = _or(value, attribute, model); // A rule should either return true in the event of a general
            // "pass", or nothing at all. A failure would have to be a
            // string message (usually from another rule).


            if (_result === true || isUndefined_1(_result)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } // At this point we want to report that this rule has failed, because
      // none of the "and" or "or" chains passed either.
      // Add the invalid value to the message context, which is made available
      // to all rules by default. This allows for ${value} interpolation.


      assign_1(data, {
        attribute: attribute,
        value: value
      }); // This would be a custom format explicitly set on this rule.

      var format = get_1($rule, '_format'); // Use the default message if an explicit format isn't set.

      if (!format) {
        return messages.get(name, data);
      } // Replace the custom format with a template if it's still a string.


      if (isString_1(format)) {
        $rule._format = format = template_1(format);
      }

      return format(data);
    };
    /**
     * @returns {Function} A copy of this rule, so that appending to a chain or
     *                     setting a custom format doesn't modify the base rule.
     */


    $rule.copy = function () {
      return assign_1(rule({
        name: name,
        test: test,
        data: data
      }), pick_1($rule, ['_format', '_and', '_or']));
    };
    /**
     * Sets a custom error message format on this rule.
     *
     * @param {string|Function} format
     */


    $rule.format = function (format) {
      return assign_1($rule.copy(), {
        _format: format
      });
    };
    /**
     * Adds another rule or function to this rule's OR chain. If the given rule
     * passes when this one fails, this rule will return `true`.
     *
     * @param {Function|Function[]} rules One or more functions to add to the chain.
     */


    $rule.or = function (rules) {
      return assign_1($rule.copy(), {
        _or: concat_1($rule._or, rules)
      });
    };
    /**
     * Adds another rule or function to this rule's AND chain. If the given rule
     * fails when this one passes, this rule will return `false`.
     *
     * @param {Function|Function[]} rules One or more functions to add to the chain.
     */


    $rule.and = function (rules) {
      return assign_1($rule.copy(), {
        _and: concat_1($rule._and, rules)
      });
    };

    $rule._and = []; // "and" chain

    $rule._or = []; // "or" chain

    $rule._format = null; // Custom format

    return $rule;
  };
  /**
   * AVAILABLE RULES
   */

  /**
   * Checks if the value is after a given date string or `Date` object.
   */


  var after = function after(date) {
    return rule({
      name: 'after',
      data: {
        date: date
      },
      test: function test(value) {
        return isAfter(parseDate$1(value), parseDate$1(date));
      }
    });
  };
  /**
   * Checks if a value only has letters.
   */


  var alpha = rule({
    name: 'alpha',
    test: function test(value) {
      return isString_1(value) && isAlpha(deburr_1(value));
    }
  });
  /**
   * Checks if a value only has letters or numbers.
   */

  var alphanumeric = rule({
    name: 'alphanumeric',
    test: function test(value) {
      return isString_1(value) && isAlphanumeric(deburr_1(value));
    }
  });
  /**
   * Checks if a value is an array.
   */

  var array = rule({
    name: 'array',
    test: isArray_1
  });
  /**
   * Checks if a value is a string consisting only of ASCII characters.
   */

  var ascii = rule({
    name: 'ascii',
    test: function test(value) {
      return isString_1(value) && /^[\x00-\x7F]+$/.test(value);
    }
  });
  /**
   * Checks if a value is a valid Base64 string.
   */

  var base64 = rule({
    name: 'base64',
    test: function test(value) {
      return isString_1(value) && isBase64(value);
    }
  });
  /**
   * Checks if a value is before a given date string or `Date` object.
   */

  var before = function before(date) {
    return rule({
      name: 'before',
      data: {
        date: date
      },
      test: function test(value) {
        return isBefore(parseDate$1(value), parseDate$1(date));
      }
    });
  };
  /**
   * Checks if a value is between a given minimum or maximum, inclusive by default.
   */


  var between = function between(min, max) {
    var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var _min = +(isString_1(min) ? parseDate$1(min) : min);

    var _max = +(isString_1(max) ? parseDate$1(max) : max);

    return rule({
      data: {
        min: min,
        max: max
      },
      name: inclusive ? 'between_inclusive' : 'between',
      test: function test(value) {
        var _value = +(isString_1(value) ? parseDate$1(value) : value);

        return inclusive ? gte_1(_value, _min) && lte_1(_value, _max) : gt_1(_value, _min) && lt_1(_value, _max);
      }
    });
  };
  /**
   * Checks if a value is a boolean (strictly true or false).
   */


  var _boolean = rule({
    name: 'boolean',
    test: isBoolean_1
  });

  var creditcard = rule({
    name: 'creditcard',
    test: function test(value) {
      return isString_1(value) && isCreditCard(value);
    }
  });
  /**
   * Checks if a value is parseable as a date.
   */

  var date = rule({
    name: 'date',
    test: function test(value) {
      return isValid(parseDate$1(value));
    }
  });
  /**
   * Checks if a value matches the given date format.
   *
   * @see https://date-fns.org/v2.0.0-alpha.9/docs/format
   */

  var dateformat = function dateformat(format$1) {
    return rule({
      name: 'dateformat',
      data: {
        format: format$1
      },
      test: function test(value) {
        try {
          return isValid(parseDate$1(value.toString(), format$1)) && format(parseDate$1(value.toString(), format$1), format$1) === value.toString();
        } catch (error) {
          if (error instanceof RangeError) {
            return false;
          } else {
            throw error;
          }
        }
      }
    });
  };
  /**
   * Checks if a value is not `undefined`
   */


  var defined = rule({
    name: 'defined',
    test: function test(value) {
      return !isUndefined_1(value);
    }
  });
  /**
   * Checks if a value is a valid email address.
   */

  var email = rule({
    name: 'email',
    test: function test(value) {
      return isString_1(value) && isEmail(value);
    }
  });
  /**
   * Checks if value is considered empty.
   *
   * @see https://lodash.com/docs/#isEmpty
   */

  var empty = rule({
    name: 'empty',
    test: isEmpty_1
  });
  /**
   * Alias for `equals`
   */

  var equal = function equal(other) {
    return equals(other);
  };
  /**
   * Checks if a value equals the given value.
   */


  var equals = function equals(other) {
    return rule({
      name: 'equals',
      data: {
        other: other
      },
      test: function test(value) {
        return isEqual_1(value, other);
      }
    });
  };
  /**
   * Checks if a value is greater than a given minimum.
   */


  var gt$1 = function gt(min) {
    return rule({
      name: 'gt',
      data: {
        min: min
      },
      test: function test(value) {
        return gt_1(value, min);
      }
    });
  };
  /**
   * Checks if a value is greater than or equal to a given minimum.
   */


  var gte$1 = function gte(min) {
    return rule({
      name: 'gte',
      data: {
        min: min
      },
      test: function test(value) {
        return gte_1(value, min);
      }
    });
  };
  /**
   * Checks if a value is an integer.
   */


  var integer = rule({
    name: 'integer',
    test: isInteger_1
  });
  /**
   * Checks if a value is a valid IP address.
   */

  var ip = rule({
    name: 'ip',
    test: function test(value) {
      return isString_1(value) && isIP(value);
    }
  });
  /**
   * Checks if a value is a zero-length string.
   */

  var isblank = rule({
    name: 'isblank',
    test: function test(value) {
      return value === '';
    }
  });
  /**
   * Checks if a value is `null` or `undefined`.
   */

  var isnil = rule({
    name: 'isnil',
    test: isNil_1
  });
  /**
   * Checks if a value is `null`.
   */

  var isnull = rule({
    name: 'isnull',
    test: isNull_1
  });
  /**
   * Checks if a value is a valid ISO8601 date string.
   */

  var iso8601 = rule({
    name: 'iso8601',
    test: function test(value) {
      return isString_1(value) && isISO8601(value);
    }
  });
  /**
   * Checks if a value is valid JSON.
   */

  var json = rule({
    name: 'json',
    test: function test(value) {
      return isString_1(value) && isJSON(value);
    }
  });
  /**
   * Checks if a value's length is at least a given minimum, and no more than an
   * optional maximum.
   *
   * @see https://lodash.com/docs/#toLength
   */

  var length = function length(min, max) {
    // No maximum means the value must be *at least* the minimum.
    if (isUndefined_1(max)) {
      return rule({
        name: 'length',
        data: {
          min: min,
          max: max
        },
        test: function test(value) {
          return size_1(value) >= min;
        }
      });
    } // Minimum and maximum given, so check that the value is within the range.


    return rule({
      name: 'length_between',
      data: {
        min: min,
        max: max
      },
      test: function test(value) {
        var length = size_1(value);
        return length >= min && length <= max;
      }
    });
  };
  /**
   * Checks if a value is less than a given maximum.
   */


  var lt$1 = function lt(max) {
    return rule({
      name: 'lt',
      data: {
        max: max
      },
      test: function test(value) {
        return lt_1(value, max);
      }
    });
  };
  /**
   * Checks if a value is less than or equal to a given maximum.
   */


  var lte$1 = function lte(max) {
    return rule({
      name: 'lte',
      data: {
        max: max
      },
      test: function test(value) {
        return lte_1(value, max);
      }
    });
  };
  /**
   * Checks if a value matches a given regular expression string or RegExp.
   */


  var match$1 = function match(pattern) {
    return rule({
      name: 'match',
      data: {
        pattern: pattern
      },
      test: function test(value) {
        return new RegExp(pattern).test(value);
      }
    });
  };
  /**
   * Alias for `lte`.
   */


  var max = function max(_max2) {
    return lte$1(_max2);
  };
  /**
   * Alias for `gte`.
   */


  var min = function min(_min2) {
    return gte$1(_min2);
  };
  /**
   * Checks if a value is negative.
   */


  var negative = rule({
    name: 'negative',
    test: function test(value) {
      return toNumber_1(value) < 0;
    }
  });
  /**
   *
   */

  var not = function not() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return rule({
      name: 'not',
      test: function test(value) {
        return !includes_1(values, value);
      }
    });
  };
  /**
   * Checks if a value is a number (integer or float), excluding `NaN`.
   */


  var number = rule({
    name: 'number',
    test: function test(value) {
      return _isFinite(value);
    }
  });
  /**
   * Checks if a value is a number or numeric string, excluding `NaN`.
   */

  var numeric = rule({
    name: 'numeric',
    test: function test(value) {
      return isNumber_1(value) && !_isNaN(value) || value && isString_1(value) && !_isNaN(toNumber_1(value));
    }
  });
  /**
   * Checks if a value is an object, excluding arrays and functions.
   */

  var object = rule({
    name: 'object',
    test: function test(value) {
      return isObject_1(value) && !isArray_1(value) && !isFunction_1(value);
    }
  });
  /**
   * Checks if a value is positive.
   */

  var positive = rule({
    name: 'positive',
    test: function test(value) {
      return toNumber_1(value) > 0;
    }
  });
  /**
   * Checks if a value is present, ie. not `null`, `undefined`, or a blank string.
   */

  var required = rule({
    name: 'required',
    test: function test(value) {
      return !(isNil_1(value) || value === '');
    }
  });
  /**
   * Checks if a value equals another attribute's value.
   */

  var same = function same(other) {
    return rule({
      name: 'same',
      data: {
        other: other
      },
      test: function test(value, attribute, model) {
        return isEqual_1(value, model.get(other));
      }
    });
  };
  /**
   * Checks if a value is a string.
   */


  var string = rule({
    name: 'string',
    test: isString_1
  });
  /**
   * Checks if a value is a valid URL string.
   */

  var url = rule({
    name: 'url',
    test: function test(value) {
      return isString_1(value) && isURL(value);
    }
  });
  /**
   * Checks if a value is a valid UUID.
   */

  var uuid = rule({
    name: 'uuid',
    test: function test(value) {
      return isString_1(value) && isUUID(value);
    }
  });
  exports.after = after;
  exports.alpha = alpha;
  exports.alphanumeric = alphanumeric;
  exports.array = array;
  exports.ascii = ascii;
  exports.base64 = base64;
  exports.before = before;
  exports.between = between;
  exports["boolean"] = _boolean;
  exports.creditcard = creditcard;
  exports.date = date;
  exports.dateformat = dateformat;
  exports.defined = defined;
  exports.email = email;
  exports.empty = empty;
  exports.equal = equal;
  exports.equals = equals;
  exports.gt = gt$1;
  exports.gte = gte$1;
  exports.integer = integer;
  exports.ip = ip;
  exports.isblank = isblank;
  exports.isnil = isnil;
  exports.isnull = isnull;
  exports.iso8601 = iso8601;
  exports.json = json;
  exports.length = length;
  exports.lt = lt$1;
  exports.lte = lte$1;
  exports.match = match$1;
  exports.max = max;
  exports.messages = messages;
  exports.min = min;
  exports.negative = negative;
  exports.not = not;
  exports.number = number;
  exports.numeric = numeric;
  exports.object = object;
  exports.positive = positive;
  exports.required = required;
  exports.rule = rule;
  exports.same = same;
  exports.string = string;
  exports.url = url;
  exports.uuid = uuid;
})(validation);

class Branch extends vueMc.Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            active: true,
            is_default: false,
            firm: {}
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            company_id: (id) => lodash.toNumber(id) || null,
            country_id: (id) => lodash.toNumber(id) || null,
            state_id: (id) => lodash.toNumber(id) || null,
            town_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {
            company: validation.required
        };
    }
    routes() {
        return {
            fetch: "branches.show",
            create: "branches.store",
            update: "branches.update",
            delete: "branches.destroy",
        };
    }
}

class BranchCollection extends vueMc.Collection {
    model() {
        return Branch;
    }
    routes() {
        return {
            fetch: "branches.index",
            list: "branches.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
    byCompany(iCompanyID) {
        return this.filterBy({ company: iCompanyID });
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
    byDefault() {
        return this.filterBy({ default: 1 });
    }
}

class Company extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: true,
            preview_image: null,
            ucfe_code: null,
            ucfe_terminal: null,
            ucfe_url: null,
            ucfe_password: null,
            firm: {},
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "companies.show",
            create: "companies.store",
            update: "companies.update",
            delete: "companies.destroy",
        };
    }
}

class CompanyCollection extends vueMc.Collection {
    model() {
        return Company;
    }
    routes() {
        return {
            fetch: "companies.index",
        };
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
    bySearch(sValue) {
        return this.filterBy({ search: sValue });
    }
    byCategory(sValue) {
        return this.filterBy({ category: sValue });
    }
    byUser(sValue) {
        return this.filterBy({ user: sValue });
    }
}

class CompanySettings extends vueMc.Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            max_global_discounts: null,
            discounts_per_line: null,
            print_after_billing: null,
            print_payment_conditions: null,
            addenda_in_own_page: null,
            addenda_only_for_credits: null,
            prices_without_tax: null,
            addenda: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            company_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {
            company_id: validation.required,
        };
    }
    routes() {
        return {
            fetch: "company.settings.show",
            create: "company.settings.store",
            update: "company.settings.update",
            delete: "company.settings.destroy",
        };
    }
}

class CompanySettingsCollection extends vueMc.Collection {
    model() {
        return CompanySettings;
    }
    routes() {
        return {
            fetch: "company.settings.index",
        };
    }
}

class CurrencyRate extends vueMc.Model {
    defaults() {
        return {
            id: null,
            currency_id: null,
            company_id: null,
            name: null,
            rate: null,
            rated_at: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "currencyrates.show",
            create: "currencyrates.store",
            update: "currencyrates.update",
            delete: "currencyrates.destroy",
        };
    }
}

class CurrencyRates extends vueMc.Collection {
    model() {
        return CurrencyRate;
    }
    routes() {
        return {
            fetch: "currencyrates.index",
        };
    }
}

class Customer extends vueMc.Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            currency_limit_id: null,
            active: true,
            tax_exempt: false,
            type: 1,
            firm: {},
            preview_image: null,
            credit_limit: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "customers.show",
            create: "customers.store",
            update: "customers.update",
            delete: "customers.destroy",
            fetchPaymentterms: "customers.paymentterm.index",
            createPaymentterm: "customers.paymentterm.store",
            destroyPaymentterm: "customers.paymentterm.destroy",
            fetchCurrencies: "customers.currency.index",
            createCurrency: "customers.currency.store",
            destroyCurrency: "customers.currency.destroy",
        };
    }
    options() {
        return {
            methods: {
                fetchPaymentterms: "GET",
                createPaymentterm: "POST",
                destroyPaymentterm: "DELETE",
                fetchCurrencies: "GET",
                createCurrency: "POST",
                destroyCurrency: "DELETE",
            },
        };
    }
    async getPaymentTerms() {
        return await this.createCustomRequest("fetchPaymentterms", ["id"]);
    }
    async addPaymentTerms(iPaymentTermId) {
        return await this.createCustomRequest("createPaymentterm", { paymentterm_id: iPaymentTermId }, ["id"]);
    }
    async delPaymentTerms(iPaymentTermId) {
        return await this.createCustomRequest("destroyPaymentterm", { paymentterm_id: iPaymentTermId }, ["id"]);
    }
    async getCurrencies() {
        return await this.createCustomRequest("fetchCurrencies", ["id"]);
    }
    async addCurrency(iCurrencyId, fCreditLimit) {
        const obData = { currency_id: iCurrencyId };
        if (fCreditLimit) {
            lodash.set(obData, "credit_limit", fCreditLimit);
        }
        return await this.createCustomRequest("createCurrency", obData, ["id"]);
    }
    async delCurrency(iCurrencyId) {
        return await this.createCustomRequest("destroyCurrency", { currency_id: iCurrencyId }, ["id"]);
    }
}

class CustomerCollection extends vueMc.Collection {
    model() {
        return Customer;
    }
    routes() {
        return {
            fetch: "customers.index",
            list: "customers.list",
        };
    }
    byCompany(iCompanyID) {
        return this.filterBy({ company: iCompanyID });
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
    bySearch(sValue) {
        return this.filterBy({ search: sValue });
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class Discount extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            value: null,
            description: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {
            value: validation.required,
        };
    }
    routes() {
        return {
            fetch: "discounts.show",
            create: "discounts.store",
            update: "discounts.update",
            delete: "discounts.destroy",
        };
    }
}

class DiscountCollection extends vueMc.Collection {
    model() {
        return Discount;
    }
    routes() {
        return {
            fetch: "discounts.index",
            list: "discounts.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class Firm extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            slug: null,
            code: null,
            description: null,
            doc_id: null,
            doc_type: null,
            address: null,
            email: null,
            phone: null,
            mobile: null,
            // Location data
            country_id: null,
            state_id: null,
            town_id: null,
            // DGI Data
            dgi_local_sec_nro: null,
            dgi_dir_fiscal: null,
            dgi_loc_nom: null,
            dgi_dpto_nom: null,
            dgi_denominacion: null,
            dgi_nombre_fantasia: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "firms.show",
            create: "firms.store",
            update: "firms.update",
            delete: "firms.destroy",
        };
    }
}

class FirmCollection extends vueMc.Collection {
    model() {
        return Firm;
    }
    routes() {
        return {
            fetch: "firms.index",
        };
    }
}

class Invoice extends vueMc.Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            branch_id: null,
            customer_id: null,
            invoice_type_id: null,
            payment_term_id: null,
            payment_method_id: null,
            invoice_group_id: null,
            invoice_movement_type_id: null,
            currency_id: null,
            price_list_id: null,
            order_serial: null,
            order_number: null,
            transaction_id: null,
            description: null,
            payment_response: null,
            customer_data: null,
            is_contingency: false,
            is_cash: true,
            created_at: new Date().toISOString(),
            updated_at: null,
            due_date: null,
            sign_at: null,
            cert: null,
            qr: null,
            id_cae: null,
            expiration_cae: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "invoices.show",
            create: "invoices.store",
            update: "invoices.update",
            delete: "invoices.destroy",
        };
    }
}

class InvoiceCollection extends vueMc.Collection {
    model() {
        return Invoice;
    }
    routes() {
        return {
            fetch: "invoices.index",
            list: "invoices.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class InvoiceGroup extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            code: null,
            created_at: null,
            updated_at: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "invoicegroups.show",
            create: "invoicegroups.store",
            update: "invoicegroups.update",
            delete: "invoicegroups.destroy",
        };
    }
}

class InvoiceGroupCollection extends vueMc.Collection {
    model() {
        return InvoiceGroup;
    }
    routes() {
        return {
            fetch: "invoicegroups.index",
            list: "invoicegroups.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class InvoiceMovementType extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            code: null,
            created_at: null,
            updated_at: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "invoicemovementtypes.show",
            create: "invoicemovementtypes.store",
            update: "invoicemovementtypes.update",
            delete: "invoicemovementtypes.destroy",
        };
    }
}

class InvoiceMovementTypeCollection extends vueMc.Collection {
    model() {
        return InvoiceMovementType;
    }
    routes() {
        return {
            fetch: "invoicemovementtypes.index",
            list: "invoicemovementtypes.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class InvoicePosition extends vueMc.Model {
    defaults() {
        return {
            id: null,
            invoice_id: null,
            currency_id: null,
            tax_type_id: null,
            price: null,
            quantity: null,
            quote: null,
            item_id: null,
            item_type: null,
            tax_percent: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
            invoice_id: (id) => lodash.toNumber(id) || null,
            currency_id: (id) => lodash.toNumber(id) || null,
            tax_type_id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "invoicepositions.show",
            create: "invoicepositions.store",
            update: "invoicepositions.update",
            delete: "invoicepositions.destroy",
        };
    }
}

class InvoicePositionCollection extends vueMc.Collection {
    model() {
        return InvoicePosition;
    }
    routes() {
        return {
            fetch: "invoicepositions.index",
            list: "invoicepositions.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class InvoiceType extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            code: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {
            name: validation.required,
            code: validation.required,
        };
    }
    routes() {
        return {
            fetch: "invoicetypes.show",
            create: "invoicetypes.store",
            update: "invoicetypes.update",
            delete: "invoicetypes.destroy",
        };
    }
}

class InvoiceTypeCollection extends vueMc.Collection {
    model() {
        return InvoiceType;
    }
    routes() {
        return {
            fetch: "invoicetypes.index",
            list: "invoicetypes.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class PaymentMethod extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: true,
            name: null,
            code: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "paymentmethods.show",
            create: "paymentmethods.store",
            update: "paymentmethods.update",
            delete: "paymentmethods.destroy",
        };
    }
}

class PaymentMethodCollection extends vueMc.Collection {
    model() {
        return PaymentMethod;
    }
    routes() {
        return {
            fetch: "paymentmethods.index",
            list: "paymentmethods.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class PaymentTerm extends vueMc.Model {
    defaults() {
        return {
            id: null,
            active: false,
            cash: false,
            name: null,
            code: null,
            type: "fixed",
            frequency: "month",
            frequency_interval: 0,
            cycles: 0,
            delay: 0,
            description: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "paymentterms.show",
            create: "paymentterms.store",
            update: "paymentterms.update",
            delete: "paymentterms.destroy",
        };
    }
}

class PaymentTerms extends vueMc.Collection {
    model() {
        return PaymentTerm;
    }
    routes() {
        return {
            fetch: "paymentterms.index",
            list: "paymentterms.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class PriceList extends vueMc.Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            name: null,
            code: null,
            active: true,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "pricelists.show",
            create: "pricelists.store",
            update: "pricelists.update",
            delete: "pricelists.destroy",
            fetchOffers: "pricelists.offers",
        };
    }
    options() {
        return {
            methods: {
                fetchOffers: "GET",
            },
        };
    }
    async getOffers() {
        return await this.createCustomRequest("fetchOffers", ["id"]);
    }
}

class PriceListCollection extends vueMc.Collection {
    model() {
        return PriceList;
    }
    routes() {
        return {
            fetch: "pricelists.index",
            list: "pricelists.list",
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
}

class ProductGw extends vueMc.Model {
    defaults() {
        return {
            id: null,
            product_id: null,
            taxtype_id: null,
            is_service: null,
            is_sell: null,
            with_tax_expenses: null,
            barcode: null,
            account_sales: null,
            account_purchase: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "products.show",
            create: "products.store",
            update: "products.update",
            delete: "products.destroy",
        };
    }
}

class ProductGwCollection extends vueMc.Collection {
    model() {
        return ProductGw;
    }
    routes() {
        return {
            fetch: "products.index",
        };
    }
}

class TaxType extends vueMc.Model {
    defaults() {
        return {
            id: null,
            name: null,
            code: null,
            description: null,
            percent: null,
            sort_order: null,
            created_at: null,
            updated_at: null,
        };
    }
    mutations() {
        return {
            id: (id) => lodash.toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "taxtypes.show",
            create: "taxtypes.store",
            update: "taxtypes.update",
            delete: "taxtypes.destroy",
        };
    }
}

class TaxTypeCollection extends vueMc.Collection {
    model() {
        return TaxType;
    }
    routes() {
        return {
            fetch: "taxtypes.index",
            list: "taxtypes.list",
            reorder: "taxtypes.reorder",
        };
    }
    options() {
        return {
            methods: {
                reorder: "POST",
            },
        };
    }
    async list() {
        return await this.createCustomRequest("list");
    }
    async reorder(arListId) {
        return await this.customRequest("reorder", { ids: arListId });
    }
}

class Settings extends vueMc.Model {
    defaults() {
        return {
            preview_image: null,
        };
    }
    mutations() {
        return {};
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "settings.show",
            create: "settings.store",
        };
    }
}

exports.Account = Account;
exports.AccountCollection = AccountCollection;
exports.AccountConfig = AccountConfig;
exports.AccountConfigCollection = AccountConfigCollection;
exports.AccountType = AccountType;
exports.AccountTypeCollection = AccountTypeCollection;
exports.Branch = Branch;
exports.BranchCollection = BranchCollection;
exports.Company = Company;
exports.CompanyCollection = CompanyCollection;
exports.CompanySettings = CompanySettings;
exports.CompanySettingsCollection = CompanySettingsCollection;
exports.CurrencyRate = CurrencyRate;
exports.CurrencyRates = CurrencyRates;
exports.Customer = Customer;
exports.CustomerCollection = CustomerCollection;
exports.Discount = Discount;
exports.DiscountCollection = DiscountCollection;
exports.Firm = Firm;
exports.FirmCollection = FirmCollection;
exports.Invoice = Invoice;
exports.InvoiceCollection = InvoiceCollection;
exports.InvoiceGroup = InvoiceGroup;
exports.InvoiceGroupCollection = InvoiceGroupCollection;
exports.InvoiceMovementType = InvoiceMovementType;
exports.InvoiceMovementTypeCollection = InvoiceMovementTypeCollection;
exports.InvoicePosition = InvoicePosition;
exports.InvoicePositionCollection = InvoicePositionCollection;
exports.InvoiceType = InvoiceType;
exports.InvoiceTypeCollection = InvoiceTypeCollection;
exports.PaymentMethod = PaymentMethod;
exports.PaymentMethodCollection = PaymentMethodCollection;
exports.PaymentTerm = PaymentTerm;
exports.PaymentTerms = PaymentTerms;
exports.PriceList = PriceList;
exports.PriceListCollection = PriceListCollection;
exports.ProductGw = ProductGw;
exports.ProductGwCollection = ProductGwCollection;
exports.Settings = Settings;
exports.TaxType = TaxType;
exports.TaxTypeCollection = TaxTypeCollection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1jLWd3LmpzIiwic291cmNlcyI6WyIuLi9zcmMvbW9kZWxzL0FjY291bnQudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQWNjb3VudENvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0FjY291bnRDb25maWcudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQWNjb3VudENvbmZpZ0NvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0FjY291bnRUeXBlLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL0FjY291bnRUeXBlQ29sbGVjdGlvbi50cyIsIi4uL25vZGVfbW9kdWxlcy92dWUtbWMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uL3NyYy9tb2RlbHMvQnJhbmNoLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL0JyYW5jaENvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0NvbXBhbnkudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQ29tcGFueUNvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0NvbXBhbnlTZXR0aW5ncy50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9Db21wYW55U2V0dGluZ3NDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9DdXJyZW5jeVJhdGUudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQ3VycmVuY3lSYXRlcy50cyIsIi4uL3NyYy9tb2RlbHMvQ3VzdG9tZXIudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvQ3VzdG9tZXJDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9EaXNjb3VudC50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9EaXNjb3VudENvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0Zpcm0udHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvRmlybUNvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0ludm9pY2UudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvSW52b2ljZUNvbGxlY3Rpb24udHMiLCIuLi9zcmMvbW9kZWxzL0ludm9pY2VHcm91cC50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9JbnZvaWNlR3JvdXBDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9JbnZvaWNlTW92ZW1lbnRUeXBlLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL0ludm9pY2VNb3ZlbWVudFR5cGVDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9JbnZvaWNlUG9zaXRpb24udHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvSW52b2ljZVBvc2l0aW9uQ29sbGVjdGlvbi50cyIsIi4uL3NyYy9tb2RlbHMvSW52b2ljZVR5cGUudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvSW52b2ljZVR5cGVDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9QYXltZW50TWV0aG9kLnRzIiwiLi4vc3JjL2NvbGxlY3Rpb25zL1BheW1lbnRNZXRob2RDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9QYXltZW50VGVybS50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9QYXltZW50VGVybXMudHMiLCIuLi9zcmMvbW9kZWxzL1ByaWNlTGlzdC50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9QcmljZUxpc3RDb2xsZWN0aW9uLnRzIiwiLi4vc3JjL21vZGVscy9Qcm9kdWN0R3cudHMiLCIuLi9zcmMvY29sbGVjdGlvbnMvUHJvZHVjdEd3Q29sbGVjdGlvbi50cyIsIi4uL3NyYy9tb2RlbHMvVGF4VHlwZS50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9UYXhUeXBlQ29sbGVjdGlvbi50cyIsIi4uL3NyYy9tb2RlbHMvU2V0dGluZ3MudHMiXSwic291cmNlc0NvbnRlbnQiOltudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbi8qKlxuICogQWZyaWthYW5zXG4gKi9cbnZhciBlbl91cyA9IHtcbiAgbG9jYWxlOiAnZW4tVVMnLFxuICBtZXNzYWdlczoge1xuICAgIGFmdGVyOiAnTXVzdCBiZSBhZnRlciAke2RhdGV9JyxcbiAgICBhbHBoYTogJ0NhbiBvbmx5IHVzZSBsZXR0ZXJzJyxcbiAgICBhbHBoYW51bWVyaWM6ICdNdXN0IGJlIGFscGhhbnVtZXJpYycsXG4gICAgYXJyYXk6ICdNdXN0IGJlIGFuIGFycmF5JyxcbiAgICBhc2NpaTogJ011c3QgYmUgQVNDSUknLFxuICAgIGJhc2U2NDogJ011c3QgYmUgdmFsaWQgQmFzZTY0JyxcbiAgICBiZWZvcmU6ICdNdXN0IGJlIGJlZm9yZSAke2RhdGV9JyxcbiAgICBiZXR3ZWVuOiAnTXVzdCBiZSBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9JyxcbiAgICBiZXR3ZWVuX2luY2x1c2l2ZTogJ011c3QgYmUgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSwgaW5jbHVzaXZlJyxcbiAgICBcImJvb2xlYW5cIjogJ011c3QgYmUgdHJ1ZSBvciBmYWxzZScsXG4gICAgY3JlZGl0Y2FyZDogJ011c3QgYmUgYSB2YWxpZCBjcmVkaXQgY2FyZCBudW1iZXInLFxuICAgIGRhdGU6ICdNdXN0IGJlIGEgdmFsaWQgZGF0ZScsXG4gICAgZGF0ZWZvcm1hdDogJ011c3QgdXNlIFwiJHtmb3JtYXR9XCIgZm9ybWF0JyxcbiAgICBkZWZpbmVkOiAnUmVxdWlyZWQnLFxuICAgIGVtYWlsOiAnTXVzdCBiZSBhIHZhbGlkIGVtYWlsIGFkZHJlc3MnLFxuICAgIGVtcHR5OiAnTXVzdCBiZSBlbXB0eScsXG4gICAgZXF1YWxzOiAnTXVzdCBiZSBlcXVhbCB0byAke290aGVyfScsXG4gICAgZ3Q6ICdNdXN0IGJlIGdyZWF0ZXIgdGhhbiAke21pbn0nLFxuICAgIGd0ZTogJ011c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7bWlufScsXG4gICAgaW50ZWdlcjogJ011c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgaXA6ICdNdXN0IGJlIGEgdmFsaWQgSVAgYWRkcmVzcycsXG4gICAgaXNibGFuazogJ01heSBub3QgYmUgYmxhbmsnLFxuICAgIGlzbmlsOiAnUmVxdWlyZWQnLFxuICAgIGlzbnVsbDogJ1JlcXVpcmVkJyxcbiAgICBpc284NjAxOiAnTXVzdCBiZSBhIHZhbGlkIElTTzg2MDEgZGF0ZScsXG4gICAganNvbjogJ011c3QgYmUgYSB2YWxpZCBKU09OJyxcbiAgICBsZW5ndGg6ICdNdXN0IGhhdmUgYSBsZW5ndGggb2YgYXQgbGVhc3QgJHttaW59JyxcbiAgICBsZW5ndGhfYmV0d2VlbjogJ011c3QgaGF2ZSBhIGxlbmd0aCBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9JyxcbiAgICBsdDogJ011c3QgYmUgbGVzcyB0aGFuICR7bWF4fScsXG4gICAgbHRlOiAnTXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHttYXh9JyxcbiAgICBtYXRjaDogJ011c3QgbWF0Y2ggXCIke3BhdHRlcm59XCInLFxuICAgIG5lZ2F0aXZlOiAnTXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gICAgbm90OiAnQ2FuIG5vdCBiZSAke3ZhbHVlfScsXG4gICAgbnVtYmVyOiAnTXVzdCBiZSBhIG51bWJlcicsXG4gICAgbnVtZXJpYzogJ011c3QgYmUgbnVtZXJpYycsXG4gICAgb2JqZWN0OiAnTXVzdCBiZSBhbiBvYmplY3QnLFxuICAgIHBvc2l0aXZlOiAnTXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gICAgcmVxdWlyZWQ6ICdSZXF1aXJlZCcsXG4gICAgc2FtZTogJ011c3QgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBhcyBcIiR7b3RoZXJ9XCInLFxuICAgIHN0cmluZzogJ011c3QgYmUgYSBzdHJpbmcnLFxuICAgIHVybDogJ011c3QgYmUgYSB2YWxpZCBVUkwnLFxuICAgIHV1aWQ6ICdNdXN0IGJlIGEgdmFsaWQgVVVJRCdcbiAgfVxuICAvKipcbiAgICogUGVyc2lhbiAtIElzbGFtaWMgUmVwdWJsaWMgb2YgSXJhblxuICAgKi9cblxufTtcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBhc3NlcnRTdHJpbmdfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydFN0cmluZztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKGlucHV0KSB7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG5cbiAgaWYgKCFpc1N0cmluZykge1xuICAgIHZhciBpbnZhbGlkVHlwZTtcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgaW52YWxpZFR5cGUgPSAnbnVsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFsaWRUeXBlID0gX3R5cGVvZihpbnB1dCk7XG5cbiAgICAgIGlmIChpbnZhbGlkVHlwZSA9PT0gJ29iamVjdCcgJiYgaW5wdXQuY29uc3RydWN0b3IgJiYgaW5wdXQuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkge1xuICAgICAgICBpbnZhbGlkVHlwZSA9IGlucHV0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkVHlwZSA9IFwiYSBcIi5jb25jYXQoaW52YWxpZFR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgYnV0IHJlY2VpdmVkIFwiLmNvbmNhdChpbnZhbGlkVHlwZSwgXCIuXCIpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudW53cmFwRXhwb3J0cyhhc3NlcnRTdHJpbmdfMSk7XG5cbnZhciBhbHBoYV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb21tYURlY2ltYWwgPSBleHBvcnRzLmRvdERlY2ltYWwgPSBleHBvcnRzLmFyYWJpY0xvY2FsZXMgPSBleHBvcnRzLmVuZ2xpc2hMb2NhbGVzID0gZXhwb3J0cy5kZWNpbWFsID0gZXhwb3J0cy5hbHBoYW51bWVyaWMgPSBleHBvcnRzLmFscGhhID0gdm9pZCAwO1xudmFyIGFscGhhID0ge1xuICAnZW4tVVMnOiAvXltBLVpdKyQvaSxcbiAgJ2JnLUJHJzogL15b0JAt0K9dKyQvaSxcbiAgJ2NzLUNaJzogL15bQS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSskL2ksXG4gICdkYS1ESyc6IC9eW0EtWsOGw5jDhV0rJC9pLFxuICAnZGUtREUnOiAvXltBLVrDhMOWw5zDn10rJC9pLFxuICAnZWwtR1InOiAvXlvOkS3PiV0rJC9pLFxuICAnZXMtRVMnOiAvXltBLVrDgcOJw43DkcOTw5rDnF0rJC9pLFxuICAnZnItRlInOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0rJC9pLFxuICAnaXQtSVQnOiAvXltBLVrDgMOJw4jDjMOOw5PDksOZXSskL2ksXG4gICduYi1OTyc6IC9eW0EtWsOGw5jDhV0rJC9pLFxuICAnbmwtTkwnOiAvXltBLVrDgcOJw4vDj8OTw5bDnMOaXSskL2ksXG4gICdubi1OTyc6IC9eW0EtWsOGw5jDhV0rJC9pLFxuICAnaHUtSFUnOiAvXltBLVrDgcOJw43Dk8OWxZDDmsOcxbBdKyQvaSxcbiAgJ3BsLVBMJzogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XSskL2ksXG4gICdwdC1QVCc6IC9eW0EtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSskL2ksXG4gICdydS1SVSc6IC9eW9CQLdCv0IFdKyQvaSxcbiAgJ3NsLVNJJzogL15bQS1axIzEhsSQxaDFvV0rJC9pLFxuICAnc2stU0snOiAvXltBLVrDgcSMxI7DicONxYfDk8WgxaTDmsOdxb3EucWUxL3DhMOUXSskL2ksXG4gICdzci1SU0BsYXRpbic6IC9eW0EtWsSMxIbFvcWgxJBdKyQvaSxcbiAgJ3NyLVJTJzogL15b0JAt0K/QgtCI0InQitCL0I9dKyQvaSxcbiAgJ3N2LVNFJzogL15bQS1aw4XDhMOWXSskL2ksXG4gICd0ci1UUic6IC9eW0EtWsOHxJ7EsMSxw5bFnsOcXSskL2ksXG4gICd1ay1VQSc6IC9eW9CQLdCp0KzQrtCv0IRJ0IfSkNGWXSskL2ksXG4gICdrdS1JUSc6IC9eW9im2KfYqNm+2KrYrNqG2K3Yrtiv2LHaldiy2pjYs9i02LnYutmB2qTZgtqp2q/ZhNq12YXZhtmI24bavtuV24zbjtmK2LfYpNir2KLYpdij2YPYtti12KnYuNiwXSskL2ksXG4gIGFyOiAvXlvYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKyQvXG59O1xuZXhwb3J0cy5hbHBoYSA9IGFscGhhO1xudmFyIGFscGhhbnVtZXJpYyA9IHtcbiAgJ2VuLVVTJzogL15bMC05QS1aXSskL2ksXG4gICdiZy1CRyc6IC9eWzAtOdCQLdCvXSskL2ksXG4gICdjcy1DWic6IC9eWzAtOUEtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0rJC9pLFxuICAnZGEtREsnOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ2RlLURFJzogL15bMC05QS1aw4TDlsOcw59dKyQvaSxcbiAgJ2VsLUdSJzogL15bMC05zpEtz4ldKyQvaSxcbiAgJ2VzLUVTJzogL15bMC05QS1aw4HDicONw5HDk8Oaw5xdKyQvaSxcbiAgJ2ZyLUZSJzogL15bMC05QS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhdKyQvaSxcbiAgJ2l0LUlUJzogL15bMC05QS1aw4DDicOIw4zDjsOTw5LDmV0rJC9pLFxuICAnaHUtSFUnOiAvXlswLTlBLVrDgcOJw43Dk8OWxZDDmsOcxbBdKyQvaSxcbiAgJ25iLU5PJzogL15bMC05QS1aw4bDmMOFXSskL2ksXG4gICdubC1OTCc6IC9eWzAtOUEtWsOBw4nDi8OPw5PDlsOcw5pdKyQvaSxcbiAgJ25uLU5PJzogL15bMC05QS1aw4bDmMOFXSskL2ksXG4gICdwbC1QTCc6IC9eWzAtOUEtWsSExIbEmMWaxYHFg8OTxbvFuV0rJC9pLFxuICAncHQtUFQnOiAvXlswLTlBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0rJC9pLFxuICAncnUtUlUnOiAvXlswLTnQkC3Qr9CBXSskL2ksXG4gICdzbC1TSSc6IC9eWzAtOUEtWsSMxIbEkMWgxb1dKyQvaSxcbiAgJ3NrLVNLJzogL15bMC05QS1aw4HEjMSOw4nDjcWHw5PFoMWkw5rDncW9xLnFlMS9w4TDlF0rJC9pLFxuICAnc3ItUlNAbGF0aW4nOiAvXlswLTlBLVrEjMSGxb3FoMSQXSskL2ksXG4gICdzci1SUyc6IC9eWzAtOdCQLdCv0ILQiNCJ0IrQi9CPXSskL2ksXG4gICdzdi1TRSc6IC9eWzAtOUEtWsOFw4TDll0rJC9pLFxuICAndHItVFInOiAvXlswLTlBLVrDh8SexLDEscOWxZ7DnF0rJC9pLFxuICAndWstVUEnOiAvXlswLTnQkC3QqdCs0K7Qr9CESdCH0pDRll0rJC9pLFxuICAna3UtSVEnOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdim2KfYqNm+2KrYrNqG2K3Yrtiv2LHaldiy2pjYs9i02LnYutmB2qTZgtqp2q/ZhNq12YXZhtmI24bavtuV24zbjtmK2LfYpNir2KLYpdij2YPYtti12KnYuNiwXSskL2ksXG4gIGFyOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0rJC9cbn07XG5leHBvcnRzLmFscGhhbnVtZXJpYyA9IGFscGhhbnVtZXJpYztcbnZhciBkZWNpbWFsID0ge1xuICAnZW4tVVMnOiAnLicsXG4gIGFyOiAn2asnXG59O1xuZXhwb3J0cy5kZWNpbWFsID0gZGVjaW1hbDtcbnZhciBlbmdsaXNoTG9jYWxlcyA9IFsnQVUnLCAnR0InLCAnSEsnLCAnSU4nLCAnTlonLCAnWkEnLCAnWk0nXTtcbmV4cG9ydHMuZW5nbGlzaExvY2FsZXMgPSBlbmdsaXNoTG9jYWxlcztcblxuZm9yICh2YXIgbG9jYWxlLCBpID0gMDsgaSA8IGVuZ2xpc2hMb2NhbGVzLmxlbmd0aDsgaSsrKSB7XG4gIGxvY2FsZSA9IFwiZW4tXCIuY29uY2F0KGVuZ2xpc2hMb2NhbGVzW2ldKTtcbiAgYWxwaGFbbG9jYWxlXSA9IGFscGhhWydlbi1VUyddO1xuICBhbHBoYW51bWVyaWNbbG9jYWxlXSA9IGFscGhhbnVtZXJpY1snZW4tVVMnXTtcbiAgZGVjaW1hbFtsb2NhbGVdID0gZGVjaW1hbFsnZW4tVVMnXTtcbn0gLy8gU291cmNlOiBodHRwOi8vd3d3LmxvY2FsZXBsYW5ldC5jb20vamF2YS9cblxuXG52YXIgYXJhYmljTG9jYWxlcyA9IFsnQUUnLCAnQkgnLCAnRFonLCAnRUcnLCAnSVEnLCAnSk8nLCAnS1cnLCAnTEInLCAnTFknLCAnTUEnLCAnUU0nLCAnUUEnLCAnU0EnLCAnU0QnLCAnU1knLCAnVE4nLCAnWUUnXTtcbmV4cG9ydHMuYXJhYmljTG9jYWxlcyA9IGFyYWJpY0xvY2FsZXM7XG5cbmZvciAodmFyIF9sb2NhbGUsIF9pID0gMDsgX2kgPCBhcmFiaWNMb2NhbGVzLmxlbmd0aDsgX2krKykge1xuICBfbG9jYWxlID0gXCJhci1cIi5jb25jYXQoYXJhYmljTG9jYWxlc1tfaV0pO1xuICBhbHBoYVtfbG9jYWxlXSA9IGFscGhhLmFyO1xuICBhbHBoYW51bWVyaWNbX2xvY2FsZV0gPSBhbHBoYW51bWVyaWMuYXI7XG4gIGRlY2ltYWxbX2xvY2FsZV0gPSBkZWNpbWFsLmFyO1xufSAvLyBTb3VyY2U6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlY2ltYWxfbWFya1xuXG5cbnZhciBkb3REZWNpbWFsID0gW107XG5leHBvcnRzLmRvdERlY2ltYWwgPSBkb3REZWNpbWFsO1xudmFyIGNvbW1hRGVjaW1hbCA9IFsnYmctQkcnLCAnY3MtQ1onLCAnZGEtREsnLCAnZGUtREUnLCAnZWwtR1InLCAnZXMtRVMnLCAnZnItRlInLCAnaXQtSVQnLCAna3UtSVEnLCAnaHUtSFUnLCAnbmItTk8nLCAnbm4tTk8nLCAnbmwtTkwnLCAncGwtUEwnLCAncHQtUFQnLCAncnUtUlUnLCAnc2wtU0knLCAnc3ItUlNAbGF0aW4nLCAnc3ItUlMnLCAnc3YtU0UnLCAndHItVFInLCAndWstVUEnXTtcbmV4cG9ydHMuY29tbWFEZWNpbWFsID0gY29tbWFEZWNpbWFsO1xuXG5mb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBkb3REZWNpbWFsLmxlbmd0aDsgX2kyKyspIHtcbiAgZGVjaW1hbFtkb3REZWNpbWFsW19pMl1dID0gZGVjaW1hbFsnZW4tVVMnXTtcbn1cblxuZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgY29tbWFEZWNpbWFsLmxlbmd0aDsgX2kzKyspIHtcbiAgZGVjaW1hbFtjb21tYURlY2ltYWxbX2kzXV0gPSAnLCc7XG59XG5cbmFscGhhWydwdC1CUiddID0gYWxwaGFbJ3B0LVBUJ107XG5hbHBoYW51bWVyaWNbJ3B0LUJSJ10gPSBhbHBoYW51bWVyaWNbJ3B0LVBUJ107XG5kZWNpbWFsWydwdC1CUiddID0gZGVjaW1hbFsncHQtUFQnXTsgLy8gc2VlICM4NjJcblxuYWxwaGFbJ3BsLVBsJ10gPSBhbHBoYVsncGwtUEwnXTtcbmFscGhhbnVtZXJpY1sncGwtUGwnXSA9IGFscGhhbnVtZXJpY1sncGwtUEwnXTtcbmRlY2ltYWxbJ3BsLVBsJ10gPSBkZWNpbWFsWydwbC1QTCddO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYWxwaGFfMSk7XG52YXIgYWxwaGFfMiA9IGFscGhhXzEuY29tbWFEZWNpbWFsO1xudmFyIGFscGhhXzMgPSBhbHBoYV8xLmRvdERlY2ltYWw7XG52YXIgYWxwaGFfNCA9IGFscGhhXzEuYXJhYmljTG9jYWxlcztcbnZhciBhbHBoYV81ID0gYWxwaGFfMS5lbmdsaXNoTG9jYWxlcztcbnZhciBhbHBoYV82ID0gYWxwaGFfMS5kZWNpbWFsO1xudmFyIGFscGhhXzcgPSBhbHBoYV8xLmFscGhhbnVtZXJpYztcbnZhciBhbHBoYV84ID0gYWxwaGFfMS5hbHBoYTtcblxudmFyIGlzQWxwaGFfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWxwaGE7XG5leHBvcnRzLmxvY2FsZXMgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cblxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0FscGhhKHN0cikge1xuICB2YXIgbG9jYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZW4tVVMnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gYWxwaGFfMS5hbHBoYSkge1xuICAgIHJldHVybiBhbHBoYV8xLmFscGhhW2xvY2FsZV0udGVzdChzdHIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChsb2NhbGUsIFwiJ1wiKSk7XG59XG5cbnZhciBsb2NhbGVzID0gT2JqZWN0LmtleXMoYWxwaGFfMS5hbHBoYSk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzO1xufSk7XG5cbnZhciBpc0FscGhhID0gdW53cmFwRXhwb3J0cyhpc0FscGhhXzEpO1xudmFyIGlzQWxwaGFfMiA9IGlzQWxwaGFfMS5sb2NhbGVzO1xuXG52YXIgaXNBbHBoYW51bWVyaWNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWxwaGFudW1lcmljO1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBbHBoYW51bWVyaWMoc3RyKSB7XG4gIHZhciBsb2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdlbi1VUyc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiBhbHBoYV8xLmFscGhhbnVtZXJpYykge1xuICAgIHJldHVybiBhbHBoYV8xLmFscGhhbnVtZXJpY1tsb2NhbGVdLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKGFscGhhXzEuYWxwaGFudW1lcmljKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7XG59KTtcblxudmFyIGlzQWxwaGFudW1lcmljID0gdW53cmFwRXhwb3J0cyhpc0FscGhhbnVtZXJpY18xKTtcbnZhciBpc0FscGhhbnVtZXJpY18yID0gaXNBbHBoYW51bWVyaWNfMS5sb2NhbGVzO1xuXG52YXIgaXNCYXNlNjRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQmFzZTY0O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbm90QmFzZTY0ID0gL1teQS1aMC05K1xcLz1dL2k7XG5cbmZ1bmN0aW9uIGlzQmFzZTY0KHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcblxuICBpZiAoIWxlbiB8fCBsZW4gJSA0ICE9PSAwIHx8IG5vdEJhc2U2NC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZmlyc3RQYWRkaW5nQ2hhciA9IHN0ci5pbmRleE9mKCc9Jyk7XG4gIHJldHVybiBmaXJzdFBhZGRpbmdDaGFyID09PSAtMSB8fCBmaXJzdFBhZGRpbmdDaGFyID09PSBsZW4gLSAxIHx8IGZpcnN0UGFkZGluZ0NoYXIgPT09IGxlbiAtIDIgJiYgc3RyW2xlbiAtIDFdID09PSAnPSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNCYXNlNjQgPSB1bndyYXBFeHBvcnRzKGlzQmFzZTY0XzEpO1xuXG52YXIgaXNDcmVkaXRDYXJkXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0NyZWRpdENhcmQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBjcmVkaXRDYXJkID0gL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18KDIyMlsxLTldfDIyWzMtOV1bMC05XXwyWzMtNl1bMC05XXsyfXwyN1swMV1bMC05XXwyNzIwKVswLTldezEyfXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX18NlsyN11bMC05XXsxNH0pJC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gaXNDcmVkaXRDYXJkKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgc2FuaXRpemVkID0gc3RyLnJlcGxhY2UoL1stIF0rL2csICcnKTtcblxuICBpZiAoIWNyZWRpdENhcmQudGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBkaWdpdDtcbiAgdmFyIHRtcE51bTtcbiAgdmFyIHNob3VsZERvdWJsZTtcblxuICBmb3IgKHZhciBpID0gc2FuaXRpemVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGlnaXQgPSBzYW5pdGl6ZWQuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuXG4gICAgaWYgKHNob3VsZERvdWJsZSkge1xuICAgICAgdG1wTnVtICo9IDI7XG5cbiAgICAgIGlmICh0bXBOdW0gPj0gMTApIHtcbiAgICAgICAgc3VtICs9IHRtcE51bSAlIDEwICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgfVxuXG4gICAgc2hvdWxkRG91YmxlID0gIXNob3VsZERvdWJsZTtcbiAgfVxuXG4gIHJldHVybiAhIShzdW0gJSAxMCA9PT0gMCA/IHNhbml0aXplZCA6IGZhbHNlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc0NyZWRpdENhcmQgPSB1bndyYXBFeHBvcnRzKGlzQ3JlZGl0Q2FyZF8xKTtcblxudmFyIG1lcmdlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtZXJnZTtcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZGVmYXVsdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG51bndyYXBFeHBvcnRzKG1lcmdlXzEpO1xuXG52YXIgaXNCeXRlTGVuZ3RoXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0J5dGVMZW5ndGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuZnVuY3Rpb24gaXNCeXRlTGVuZ3RoKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuXG4gIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgIG1pbiA9IG9wdGlvbnMubWluIHx8IDA7XG4gICAgbWF4ID0gb3B0aW9ucy5tYXg7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlzQnl0ZUxlbmd0aChzdHIsIG1pbiBbLCBtYXhdKVxuICAgIG1pbiA9IGFyZ3VtZW50c1sxXTtcbiAgICBtYXggPSBhcmd1bWVudHNbMl07XG4gIH1cblxuICB2YXIgbGVuID0gZW5jb2RlVVJJKHN0cikuc3BsaXQoLyUuLnwuLykubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGxlbiA+PSBtaW4gJiYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IGxlbiA8PSBtYXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudW53cmFwRXhwb3J0cyhpc0J5dGVMZW5ndGhfMSk7XG5cbnZhciBpc0ZRRE5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRlFETjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobWVyZ2VfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2ZxZG5fb3B0aW9ucyA9IHtcbiAgcmVxdWlyZV90bGQ6IHRydWUsXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNGUUROKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2ZxZG5fb3B0aW9ucyk7XG4gIC8qIFJlbW92ZSB0aGUgb3B0aW9uYWwgdHJhaWxpbmcgZG90IGJlZm9yZSBjaGVja2luZyB2YWxpZGl0eSAqL1xuXG4gIGlmIChvcHRpb25zLmFsbG93X3RyYWlsaW5nX2RvdCAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLicpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFydHNbaV0ubGVuZ3RoID4gNjMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcblxuICAgIGlmICghcGFydHMubGVuZ3RoIHx8ICEvXihbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH18eG5bYS16MC05LV17Mix9KSQvaS50ZXN0KHRsZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGRpc2FsbG93IHNwYWNlc1xuXG5cbiAgICBpZiAoL1tcXHNcXHUyMDAyLVxcdTIwMEJcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXFx1REI0MFxcdURDMjBdLy50ZXN0KHRsZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBwYXJ0LCBfaSA9IDA7IF9pIDwgcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgcGFydCA9IHBhcnRzW19pXTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93X3VuZGVyc2NvcmVzKSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9fL2csICcnKTtcbiAgICB9XG5cbiAgICBpZiAoIS9eW2EtelxcdTAwYTEtXFx1ZmZmZjAtOS1dKyQvaS50ZXN0KHBhcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBkaXNhbGxvdyBmdWxsLXdpZHRoIGNoYXJzXG5cblxuICAgIGlmICgvW1xcdWZmMDEtXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocGFydFswXSA9PT0gJy0nIHx8IHBhcnRbcGFydC5sZW5ndGggLSAxXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGlzRlFETl8xKTtcblxudmFyIGlzSVBfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpcHY0TWF5YmUgPSAvXihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSkkLztcbnZhciBpcHY2QmxvY2sgPSAvXlswLTlBLUZdezEsNH0kL2k7XG5cbmZ1bmN0aW9uIGlzSVAoc3RyKSB7XG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcblxuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gaXNJUChzdHIsIDQpIHx8IGlzSVAoc3RyLCA2KTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAnNCcpIHtcbiAgICBpZiAoIWlwdjRNYXliZS50ZXN0KHN0cikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzWzNdIDw9IDI1NTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAnNicpIHtcbiAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KCc6Jyk7XG4gICAgdmFyIGZvdW5kT21pc3Npb25CbG9jayA9IGZhbHNlOyAvLyBtYXJrZXIgdG8gaW5kaWNhdGUgOjpcbiAgICAvLyBBdCBsZWFzdCBzb21lIE9TIGFjY2VwdCB0aGUgbGFzdCAzMiBiaXRzIG9mIGFuIElQdjYgYWRkcmVzc1xuICAgIC8vIChpLmUuIDIgb2YgdGhlIGJsb2NrcykgaW4gSVB2NCBub3RhdGlvbiwgYW5kIFJGQyAzNDkzIHNheXNcbiAgICAvLyB0aGF0ICc6OmZmZmY6YS5iLmMuZCcgaXMgdmFsaWQgZm9yIElQdjQtbWFwcGVkIElQdjYgYWRkcmVzc2VzLFxuICAgIC8vIGFuZCAnOjphLmIuYy5kJyBpcyBkZXByZWNhdGVkLCBidXQgYWxzbyB2YWxpZC5cblxuICAgIHZhciBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPSBpc0lQKGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0sIDQpO1xuICAgIHZhciBleHBlY3RlZE51bWJlck9mQmxvY2tzID0gZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrID8gNyA6IDg7XG5cbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGluaXRpYWwgb3IgZmluYWwgOjpcblxuXG4gICAgaWYgKHN0ciA9PT0gJzo6Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyB0ZXN0IGZvciBhIDo6IHdoaWNoIGNhbiBub3QgYmUgYXQgdGhlIHN0cmluZyBzdGFydC9lbmRcbiAgICAgIC8vIHNpbmNlIHRob3NlIGNhc2VzIGhhdmUgYmVlbiBoYW5kbGVkIGFib3ZlXG4gICAgICBpZiAoYmxvY2tzW2ldID09PSAnJyAmJiBpID4gMCAmJiBpIDwgYmxvY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbXVsdGlwbGUgOjogaW4gYWRkcmVzc1xuICAgICAgICB9XG5cbiAgICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrICYmIGkgPT09IGJsb2Nrcy5sZW5ndGggLSAxKSA7IGVsc2UgaWYgKCFpcHY2QmxvY2sudGVzdChibG9ja3NbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja3MubGVuZ3RoID09PSBleHBlY3RlZE51bWJlck9mQmxvY2tzO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzSVAgPSB1bndyYXBFeHBvcnRzKGlzSVBfMSk7XG5cbnZhciBpc0VtYWlsXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtYWlsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcblxudmFyIF9pc0J5dGVMZW5ndGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzQnl0ZUxlbmd0aF8xKTtcblxudmFyIF9pc0ZRRE4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzRlFETl8xKTtcblxudmFyIF9pc0lQID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9lbWFpbF9vcHRpb25zID0ge1xuICBhbGxvd19kaXNwbGF5X25hbWU6IGZhbHNlLFxuICByZXF1aXJlX2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIGFsbG93X3V0ZjhfbG9jYWxfcGFydDogdHJ1ZSxcbiAgcmVxdWlyZV90bGQ6IHRydWVcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxudmFyIGRpc3BsYXlOYW1lID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1thLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLFxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcc10qPCguKyk+JC9pO1xudmFyIGVtYWlsVXNlclBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl0rJC9pO1xudmFyIGdtYWlsVXNlclBhcnQgPSAvXlthLXpcXGRdKyQvO1xudmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl0pKSokL2k7XG52YXIgZW1haWxVc2VyVXRmOFBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rJC9pO1xudmFyIHF1b3RlZEVtYWlsVXNlclV0ZjggPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZVxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkqJC9pO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5mdW5jdGlvbiBpc0VtYWlsKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2VtYWlsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lIHx8IG9wdGlvbnMuYWxsb3dfZGlzcGxheV9uYW1lKSB7XG4gICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuXG4gICAgaWYgKGRpc3BsYXlfZW1haWwpIHtcbiAgICAgIHN0ciA9IGRpc3BsYXlfZW1haWxbMV07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCdAJyk7XG4gIHZhciBkb21haW4gPSBwYXJ0cy5wb3AoKTtcbiAgdmFyIHVzZXIgPSBwYXJ0cy5qb2luKCdAJyk7XG4gIHZhciBsb3dlcl9kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcblxuICBpZiAob3B0aW9ucy5kb21haW5fc3BlY2lmaWNfdmFsaWRhdGlvbiAmJiAobG93ZXJfZG9tYWluID09PSAnZ21haWwuY29tJyB8fCBsb3dlcl9kb21haW4gPT09ICdnb29nbGVtYWlsLmNvbScpKSB7XG4gICAgLypcbiAgICAgIFByZXZpb3VzbHkgd2UgcmVtb3ZlZCBkb3RzIGZvciBnbWFpbCBhZGRyZXNzZXMgYmVmb3JlIHZhbGlkYXRpbmcuXG4gICAgICBUaGlzIHdhcyByZW1vdmVkIGJlY2F1c2UgaXQgYWxsb3dzIGBtdWx0aXBsZS4uZG90c0BnbWFpbC5jb21gXG4gICAgICB0byBiZSByZXBvcnRlZCBhcyB2YWxpZCwgYnV0IGl0IGlzIG5vdC5cbiAgICAgIEdtYWlsIG9ubHkgbm9ybWFsaXplcyBzaW5nbGUgZG90cywgcmVtb3ZpbmcgdGhlbSBmcm9tIGhlcmUgaXMgcG9pbnRsZXNzLFxuICAgICAgc2hvdWxkIGJlIGRvbmUgaW4gbm9ybWFsaXplRW1haWxcbiAgICAqL1xuICAgIHVzZXIgPSB1c2VyLnRvTG93ZXJDYXNlKCk7IC8vIFJlbW92aW5nIHN1Yi1hZGRyZXNzIGZyb20gdXNlcm5hbWUgYmVmb3JlIGdtYWlsIHZhbGlkYXRpb25cblxuICAgIHZhciB1c2VybmFtZSA9IHVzZXIuc3BsaXQoJysnKVswXTsgLy8gRG90cyBhcmUgbm90IGluY2x1ZGVkIGluIGdtYWlsIGxlbmd0aCByZXN0cmljdGlvblxuXG4gICAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KSh1c2VybmFtZS5yZXBsYWNlKCcuJywgJycpLCB7XG4gICAgICBtaW46IDYsXG4gICAgICBtYXg6IDMwXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX3VzZXJfcGFydHMgPSB1c2VybmFtZS5zcGxpdCgnLicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdXNlcl9wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFnbWFpbFVzZXJQYXJ0LnRlc3QoX3VzZXJfcGFydHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoISgwLCBfaXNCeXRlTGVuZ3RoLmRlZmF1bHQpKHVzZXIsIHtcbiAgICBtYXg6IDY0XG4gIH0pIHx8ICEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KShkb21haW4sIHtcbiAgICBtYXg6IDI1NFxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKDAsIF9pc0ZRRE4uZGVmYXVsdCkoZG9tYWluLCB7XG4gICAgcmVxdWlyZV90bGQ6IG9wdGlvbnMucmVxdWlyZV90bGRcbiAgfSkpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dfaXBfZG9tYWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoMCwgX2lzSVAuZGVmYXVsdCkoZG9tYWluKSkge1xuICAgICAgaWYgKCFkb21haW4uc3RhcnRzV2l0aCgnWycpIHx8ICFkb21haW4uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBub0JyYWNrZXRkb21haW4gPSBkb21haW4uc3Vic3RyKDEsIGRvbWFpbi5sZW5ndGggLSAyKTtcblxuICAgICAgaWYgKG5vQnJhY2tldGRvbWFpbi5sZW5ndGggPT09IDAgfHwgISgwLCBfaXNJUC5kZWZhdWx0KShub0JyYWNrZXRkb21haW4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodXNlclswXSA9PT0gJ1wiJykge1xuICAgIHVzZXIgPSB1c2VyLnNsaWNlKDEsIHVzZXIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gcXVvdGVkRW1haWxVc2VyVXRmOC50ZXN0KHVzZXIpIDogcXVvdGVkRW1haWxVc2VyLnRlc3QodXNlcik7XG4gIH1cblxuICB2YXIgcGF0dGVybiA9IG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gZW1haWxVc2VyVXRmOFBhcnQgOiBlbWFpbFVzZXJQYXJ0O1xuICB2YXIgdXNlcl9wYXJ0cyA9IHVzZXIuc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXNlcl9wYXJ0cy5sZW5ndGg7IF9pKyspIHtcbiAgICBpZiAoIXBhdHRlcm4udGVzdCh1c2VyX3BhcnRzW19pXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc0VtYWlsID0gdW53cmFwRXhwb3J0cyhpc0VtYWlsXzEpO1xuXG52YXIgaXNJU084NjAxXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTTzg2MDE7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbi8vIGZyb20gaHR0cDovL2dvby5nbC8wZWpISFdcbnZhciBpc284NjAxID0gL14oW1xcKy1dP1xcZHs0fSg/IVxcZHsyfVxcYikpKCgtPykoKDBbMS05XXwxWzAtMl0pKFxcMyhbMTJdXFxkfDBbMS05XXwzWzAxXSkpP3xXKFswLTRdXFxkfDVbMC0zXSkoLT9bMS03XSk/fCgwMFsxLTldfDBbMS05XVxcZHxbMTJdXFxkezJ9fDMoWzAtNV1cXGR8NlsxLTZdKSkpKFtUXFxzXSgoKFswMV1cXGR8MlswLTNdKSgoOj8pWzAtNV1cXGQpP3wyNDo/MDApKFtcXC4sXVxcZCsoPyE6KSk/KT8oXFwxN1swLTVdXFxkKFtcXC4sXVxcZCspPyk/KFt6Wl18KFtcXCstXSkoWzAxXVxcZHwyWzAtM10pOj8oWzAtNV1cXGQpPyk/KT8pPyQvO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc1ZhbGlkRGF0ZSA9IGZ1bmN0aW9uIGlzVmFsaWREYXRlKHN0cikge1xuICAvLyBzdHIgbXVzdCBoYXZlIHBhc3NlZCB0aGUgSVNPODYwMSBjaGVja1xuICAvLyB0aGlzIGNoZWNrIGlzIG1lYW50IHRvIGNhdGNoIGludmFsaWQgZGF0ZXNcbiAgLy8gbGlrZSAyMDA5LTAyLTMxXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBvcmRpbmFsIGRhdGVzXG4gIHZhciBvcmRpbmFsTWF0Y2ggPSBzdHIubWF0Y2goL14oXFxkezR9KS0/KFxcZHszfSkoWyBUXXsxfVxcLip8JCkvKTtcblxuICBpZiAob3JkaW5hbE1hdGNoKSB7XG4gICAgdmFyIG9ZZWFyID0gTnVtYmVyKG9yZGluYWxNYXRjaFsxXSk7XG4gICAgdmFyIG9EYXkgPSBOdW1iZXIob3JkaW5hbE1hdGNoWzJdKTsgLy8gaWYgaXMgbGVhcCB5ZWFyXG5cbiAgICBpZiAob1llYXIgJSA0ID09PSAwICYmIG9ZZWFyICUgMTAwICE9PSAwKSByZXR1cm4gb0RheSA8PSAzNjY7XG4gICAgcmV0dXJuIG9EYXkgPD0gMzY1O1xuICB9XG5cbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKC8oXFxkezR9KS0/KFxcZHswLDJ9KS0/KFxcZCopLykubWFwKE51bWJlcik7XG4gIHZhciB5ZWFyID0gbWF0Y2hbMV07XG4gIHZhciBtb250aCA9IG1hdGNoWzJdO1xuICB2YXIgZGF5ID0gbWF0Y2hbM107XG4gIHZhciBtb250aFN0cmluZyA9IG1vbnRoID8gXCIwXCIuY29uY2F0KG1vbnRoKS5zbGljZSgtMikgOiBtb250aDtcbiAgdmFyIGRheVN0cmluZyA9IGRheSA/IFwiMFwiLmNvbmNhdChkYXkpLnNsaWNlKC0yKSA6IGRheTsgLy8gY3JlYXRlIGEgZGF0ZSBvYmplY3QgYW5kIGNvbXBhcmVcblxuICB2YXIgZCA9IG5ldyBEYXRlKFwiXCIuY29uY2F0KHllYXIsIFwiLVwiKS5jb25jYXQobW9udGhTdHJpbmcgfHwgJzAxJywgXCItXCIpLmNvbmNhdChkYXlTdHJpbmcgfHwgJzAxJykpO1xuICBpZiAoaXNOYU4oZC5nZXRVVENGdWxsWWVhcigpKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChtb250aCAmJiBkYXkpIHtcbiAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyICYmIGQuZ2V0VVRDTW9udGgoKSArIDEgPT09IG1vbnRoICYmIGQuZ2V0VVRDRGF0ZSgpID09PSBkYXk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGlzSVNPODYwMShzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGNoZWNrID0gaXNvODYwMS50ZXN0KHN0cik7XG4gIGlmICghb3B0aW9ucykgcmV0dXJuIGNoZWNrO1xuICBpZiAoY2hlY2sgJiYgb3B0aW9ucy5zdHJpY3QpIHJldHVybiBpc1ZhbGlkRGF0ZShzdHIpO1xuICByZXR1cm4gY2hlY2s7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNJU084NjAxID0gdW53cmFwRXhwb3J0cyhpc0lTTzg2MDFfMSk7XG5cbnZhciBpc0pTT05fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSlNPTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gaXNKU09OKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG9iaiA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICByZXR1cm4gISFvYmogJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JztcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlnbm9yZSAqL1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzSlNPTiA9IHVud3JhcEV4cG9ydHMoaXNKU09OXzEpO1xuXG52YXIgaXNVUkxfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVVJMO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG52YXIgX2lzRlFETiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNGUUROXzEpO1xuXG52YXIgX2lzSVAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzSVBfMSk7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF91cmxfb3B0aW9ucyA9IHtcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZnRwJ10sXG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICByZXF1aXJlX3Byb3RvY29sOiBmYWxzZSxcbiAgcmVxdWlyZV9ob3N0OiB0cnVlLFxuICByZXF1aXJlX3ZhbGlkX3Byb3RvY29sOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXG4gIGFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHM6IGZhbHNlXG59O1xudmFyIHdyYXBwZWRfaXB2NiA9IC9eXFxbKFteXFxdXSspXFxdKD86OihbMC05XSspKT8kLztcblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0LCBtYXRjaGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV07XG5cbiAgICBpZiAoaG9zdCA9PT0gbWF0Y2ggfHwgaXNSZWdFeHAobWF0Y2gpICYmIG1hdGNoLnRlc3QoaG9zdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVUkwodXJsLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHVybCk7XG5cbiAgaWYgKCF1cmwgfHwgdXJsLmxlbmd0aCA+PSAyMDgzIHx8IC9bXFxzPD5dLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodXJsLmluZGV4T2YoJ21haWx0bzonKSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfdXJsX29wdGlvbnMpO1xuICB2YXIgcHJvdG9jb2wsIGF1dGgsIGhvc3QsIGhvc3RuYW1lLCBwb3J0LCBwb3J0X3N0ciwgc3BsaXQsIGlwdjY7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcjJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc/Jyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc6Ly8nKTtcblxuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIHByb3RvY29sID0gc3BsaXQuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZV92YWxpZF9wcm90b2NvbCAmJiBvcHRpb25zLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX3Byb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dfcHJvdG9jb2xfcmVsYXRpdmVfdXJscykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNwbGl0WzBdID0gdXJsLnN1YnN0cigyKTtcbiAgfVxuXG4gIHVybCA9IHNwbGl0LmpvaW4oJzovLycpO1xuXG4gIGlmICh1cmwgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJy8nKTtcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcblxuICBpZiAodXJsID09PSAnJyAmJiAhb3B0aW9ucy5yZXF1aXJlX2hvc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCdAJyk7XG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhbGxvd19hdXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXV0aCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgICBpZiAoYXV0aC5pbmRleE9mKCc6JykgPj0gMCAmJiBhdXRoLnNwbGl0KCc6JykubGVuZ3RoID4gMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGhvc3RuYW1lID0gc3BsaXQuam9pbignQCcpO1xuICBwb3J0X3N0ciA9IG51bGw7XG4gIGlwdjYgPSBudWxsO1xuICB2YXIgaXB2Nl9tYXRjaCA9IGhvc3RuYW1lLm1hdGNoKHdyYXBwZWRfaXB2Nik7XG5cbiAgaWYgKGlwdjZfbWF0Y2gpIHtcbiAgICBob3N0ID0gJyc7XG4gICAgaXB2NiA9IGlwdjZfbWF0Y2hbMV07XG4gICAgcG9ydF9zdHIgPSBpcHY2X21hdGNoWzJdIHx8IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3BsaXQgPSBob3N0bmFtZS5zcGxpdCgnOicpO1xuICAgIGhvc3QgPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgaWYgKHNwbGl0Lmxlbmd0aCkge1xuICAgICAgcG9ydF9zdHIgPSBzcGxpdC5qb2luKCc6Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcnRfc3RyICE9PSBudWxsKSB7XG4gICAgcG9ydCA9IHBhcnNlSW50KHBvcnRfc3RyLCAxMCk7XG5cbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChwb3J0X3N0cikgfHwgcG9ydCA8PSAwIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKDAsIF9pc0lQLmRlZmF1bHQpKGhvc3QpICYmICEoMCwgX2lzRlFETi5kZWZhdWx0KShob3N0LCBvcHRpb25zKSAmJiAoIWlwdjYgfHwgISgwLCBfaXNJUC5kZWZhdWx0KShpcHY2LCA2KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBob3N0ID0gaG9zdCB8fCBpcHY2O1xuXG4gIGlmIChvcHRpb25zLmhvc3Rfd2hpdGVsaXN0ICYmICFjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X3doaXRlbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ob3N0X2JsYWNrbGlzdCAmJiBjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X2JsYWNrbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc1VSTCA9IHVud3JhcEV4cG9ydHMoaXNVUkxfMSk7XG5cbnZhciBpc1VVSURfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVVVJRDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHV1aWQgPSB7XG4gIDM6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tM1swLTlBLUZdezN9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaSxcbiAgNDogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS00WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pLFxuICA1OiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTVbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksXG4gIGFsbDogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2lcbn07XG5cbmZ1bmN0aW9uIGlzVVVJRChzdHIpIHtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdhbGwnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgcGF0dGVybiA9IHV1aWRbdmVyc2lvbl07XG4gIHJldHVybiBwYXR0ZXJuICYmIHBhdHRlcm4udGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzVVVJRCA9IHVud3JhcEV4cG9ydHMoaXNVVUlEXzEpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbnZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IF9mcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBfcm9vdCA9IHJvb3Q7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCQxID0gX3Jvb3QuU3ltYm9sO1xuXG52YXIgX1N5bWJvbCA9IFN5bWJvbCQxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9nZXRSYXdUYWcgPSBnZXRSYXdUYWc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90byQxLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG59XG5cbnZhciBfb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RUb1N0cmluZztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyQxICYmIHN5bVRvU3RyaW5nVGFnJDEgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IF9nZXRSYXdUYWcodmFsdWUpXG4gICAgOiBfb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG52YXIgX2Jhc2VHZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxudmFyIGlzT2JqZWN0XzEgPSBpc09iamVjdDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IF9iYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxudmFyIGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb247XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gX3Jvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG52YXIgX2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKF9jb3JlSnNEYXRhICYmIF9jb3JlSnNEYXRhLmtleXMgJiYgX2NvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG52YXIgX2lzTWFza2VkID0gaXNNYXNrZWQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIF90b1NvdXJjZSA9IHRvU291cmNlO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nJDEgPSBmdW5jUHJvdG8kMS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMSA9IG9iamVjdFByb3RvJDIuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmckMS5jYWxsKGhhc093blByb3BlcnR5JDEpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpIHx8IF9pc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uXzEodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdChfdG9Tb3VyY2UodmFsdWUpKTtcbn1cblxudmFyIF9iYXNlSXNOYXRpdmUgPSBiYXNlSXNOYXRpdmU7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG52YXIgX2dldFZhbHVlID0gZ2V0VmFsdWU7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBfZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gX2Jhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIF9nZXROYXRpdmUgPSBnZXROYXRpdmU7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IF9nZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIF9kZWZpbmVQcm9wZXJ0eSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbnZhciBfYmFzZUFzc2lnblZhbHVlID0gYmFzZUFzc2lnblZhbHVlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxudmFyIGVxXzEgPSBlcTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iamVjdCwga2V5KSAmJiBlcV8xKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIF9iYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgX2Fzc2lnblZhbHVlID0gYXNzaWduVmFsdWU7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIF9iYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2Fzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBfY29weU9iamVjdCA9IGNvcHlPYmplY3Q7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBpZGVudGl0eV8xID0gaWRlbnRpdHk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxudmFyIF9hcHBseSA9IGFwcGx5O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBfYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxudmFyIF9vdmVyUmVzdCA9IG92ZXJSZXN0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxudmFyIGNvbnN0YW50XzEgPSBjb25zdGFudDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIV9kZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5XzEgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudF8xKHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbnZhciBfYmFzZVNldFRvU3RyaW5nID0gYmFzZVNldFRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfc2hvcnRPdXQgPSBzaG9ydE91dDtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gX3Nob3J0T3V0KF9iYXNlU2V0VG9TdHJpbmcpO1xuXG52YXIgX3NldFRvU3RyaW5nID0gc2V0VG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBfc2V0VG9TdHJpbmcoX292ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eV8xKSwgZnVuYyArICcnKTtcbn1cblxudmFyIF9iYXNlUmVzdCA9IGJhc2VSZXN0O1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbnZhciBpc0xlbmd0aF8xID0gaXNMZW5ndGg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoXzEodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl8xKHZhbHVlKTtcbn1cblxudmFyIGlzQXJyYXlMaWtlXzEgPSBpc0FycmF5TGlrZTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiQxIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxudmFyIF9pc0luZGV4ID0gaXNJbmRleDtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdF8xKG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlXzEob2JqZWN0KSAmJiBfaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxXzEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9pc0l0ZXJhdGVlQ2FsbCA9IGlzSXRlcmF0ZWVDYWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBfYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgX2lzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbnZhciBfY3JlYXRlQXNzaWduZXIgPSBjcmVhdGVBc3NpZ25lcjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDQgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvJDQ7XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxudmFyIF9pc1Byb3RvdHlwZSA9IGlzUHJvdG90eXBlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VUaW1lcyA9IGJhc2VUaW1lcztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbnZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxudmFyIF9iYXNlSXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDUuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kNS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gX2Jhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IF9iYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIGhhc093blByb3BlcnR5JDMuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbnZhciBpc0FyZ3VtZW50c18xID0gaXNBcmd1bWVudHM7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaXNBcnJheV8xID0gaXNBcnJheTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc3R1YkZhbHNlXzEgPSBzdHViRmFsc2U7XG5cbnZhciBpc0J1ZmZlcl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBfcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlXzE7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG59KTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMSA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWckMSA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWckMV0gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmXG4gICAgaXNMZW5ndGhfMSh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbX2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxudmFyIF9iYXNlSXNUeXBlZEFycmF5ID0gYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG52YXIgX2Jhc2VVbmFyeSA9IGJhc2VVbmFyeTtcblxudmFyIF9ub2RlVXRpbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgX2ZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG59KTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gX25vZGVVdGlsICYmIF9ub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gX2Jhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IF9iYXNlSXNUeXBlZEFycmF5O1xuXG52YXIgaXNUeXBlZEFycmF5XzEgPSBpc1R5cGVkQXJyYXk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ2ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNCA9IG9iamVjdFByb3RvJDYuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5XzEodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHNfMSh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyXzEodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheV8xKHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gX2Jhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkNC5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIF9pc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheUxpa2VLZXlzID0gYXJyYXlMaWtlS2V5cztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbnZhciBfb3ZlckFyZyA9IG92ZXJBcmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gX292ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbnZhciBfbmF0aXZlS2V5cyA9IG5hdGl2ZUtleXM7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ3ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNSA9IG9iamVjdFByb3RvJDcuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFfaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBfbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDUuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZUtleXMgPSBiYXNlS2V5cztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2VfMShvYmplY3QpID8gX2FycmF5TGlrZUtleXMob2JqZWN0KSA6IF9iYXNlS2V5cyhvYmplY3QpO1xufVxuXG52YXIga2V5c18xID0ga2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDggPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ2ID0gb2JqZWN0UHJvdG8kOC5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduSW5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgYXNzaWduID0gX2NyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGlmIChfaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZV8xKHNvdXJjZSkpIHtcbiAgICBfY29weU9iamVjdChzb3VyY2UsIGtleXNfMShzb3VyY2UpLCBvYmplY3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDYuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIF9hc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciBhc3NpZ25fMSA9IGFzc2lnbjtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX2FycmF5UHVzaCA9IGFycmF5UHVzaDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IF9TeW1ib2wgPyBfU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5XzEodmFsdWUpIHx8IGlzQXJndW1lbnRzXzEodmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbnZhciBfaXNGbGF0dGVuYWJsZSA9IGlzRmxhdHRlbmFibGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZUZsYXR0ZW4gPSBiYXNlRmxhdHRlbjtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfY29weUFycmF5ID0gY29weUFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gKiBhbmQvb3IgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXkgPSBbMV07XG4gKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gKlxuICogY29uc29sZS5sb2cob3RoZXIpO1xuICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gKiAvLyA9PiBbMV1cbiAqL1xuZnVuY3Rpb24gY29uY2F0KCkge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBfYXJyYXlQdXNoKGlzQXJyYXlfMShhcnJheSkgPyBfY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIF9iYXNlRmxhdHRlbihhcmdzLCAxKSk7XG59XG5cbnZhciBjb25jYXRfMSA9IGNvbmNhdDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG52YXIgX2Jhc2VQcm9wZXJ0eU9mID0gYmFzZVByb3BlcnR5T2Y7XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IF9iYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG52YXIgX2RlYnVyckxldHRlciA9IGRlYnVyckxldHRlcjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheU1hcCA9IGFycmF5TWFwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbnZhciBpc1N5bWJvbF8xID0gaXNTeW1ib2w7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gX1N5bWJvbCA/IF9TeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIF9hcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VUb1N0cmluZyA9IGJhc2VUb1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBfYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIHRvU3RyaW5nXzEgPSB0b1N0cmluZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nXzEoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBfZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbnZhciBkZWJ1cnJfMSA9IGRlYnVycjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX2FycmF5RWFjaCA9IGFycmF5RWFjaDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQmFzZUZvciA9IGNyZWF0ZUJhc2VGb3I7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IF9jcmVhdGVCYXNlRm9yKCk7XG5cbnZhciBfYmFzZUZvciA9IGJhc2VGb3I7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgX2Jhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c18xKTtcbn1cblxudmFyIF9iYXNlRm9yT3duID0gYmFzZUZvck93bjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlXzEoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG52YXIgX2NyZWF0ZUJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2g7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IF9jcmVhdGVCYXNlRWFjaChfYmFzZUZvck93bik7XG5cbnZhciBfYmFzZUVhY2ggPSBiYXNlRWFjaDtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eV8xO1xufVxuXG52YXIgX2Nhc3RGdW5jdGlvbiA9IGNhc3RGdW5jdGlvbjtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXlfMShjb2xsZWN0aW9uKSA/IF9hcnJheUVhY2ggOiBfYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIF9jYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxudmFyIGZvckVhY2hfMSA9IGZvckVhY2g7XG5cbnZhciBlYWNoID0gZm9yRWFjaF8xO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG52YXIgX2lzS2V5ID0gaXNLZXk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG52YXIgX25hdGl2ZUNyZWF0ZSA9IG5hdGl2ZUNyZWF0ZTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gX25hdGl2ZUNyZWF0ZSA/IF9uYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9oYXNoQ2xlYXIgPSBoYXNoQ2xlYXI7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfaGFzaERlbGV0ZSA9IGhhc2hEZWxldGU7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDkgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ3ID0gb2JqZWN0UHJvdG8kOS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKF9uYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSQ3LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIF9oYXNoR2V0ID0gaGFzaEdldDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ4ID0gb2JqZWN0UHJvdG8kYS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBfbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5JDguY2FsbChkYXRhLCBrZXkpO1xufVxuXG52YXIgX2hhc2hIYXMgPSBoYXNoSGFzO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMSA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKF9uYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCQxIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX2hhc2hTZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gX2hhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IF9oYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gX2hhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBfaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IF9oYXNoU2V0O1xuXG52YXIgX0hhc2ggPSBIYXNoO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfbGlzdENhY2hlQ2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxXzEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9hc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gX2xpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG52YXIgX0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IF9nZXROYXRpdmUoX3Jvb3QsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgX0hhc2gsXG4gICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IF9IYXNoXG4gIH07XG59XG5cbnZhciBfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxudmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBfaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG52YXIgX21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9tYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gX21hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IF9NYXBDYWNoZTtcblxudmFyIG1lbW9pemVfMSA9IG1lbW9pemU7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemVfMShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX21lbW9pemVDYXBwZWQgPSBtZW1vaXplQ2FwcGVkO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IF9tZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgX3N0cmluZ1RvUGF0aCA9IHN0cmluZ1RvUGF0aDtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIF9pc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBfc3RyaW5nVG9QYXRoKHRvU3RyaW5nXzEodmFsdWUpKTtcbn1cblxudmFyIF9jYXN0UGF0aCA9IGNhc3RQYXRoO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSQxID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZJDEpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxudmFyIF90b0tleSA9IHRvS2V5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IF9jYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbX3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBfYmFzZUdldCA9IGJhc2VHZXQ7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBfYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbnZhciBnZXRfMSA9IGdldDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxudmFyIF9iYXNlR3QgPSBiYXNlR3Q7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3RfMShvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxudmFyIHRvTnVtYmVyXzEgPSB0b051bWJlcjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgIHZhbHVlID0gdG9OdW1iZXJfMSh2YWx1ZSk7XG4gICAgICBvdGhlciA9IHRvTnVtYmVyXzEob3RoZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgfTtcbn1cblxudmFyIF9jcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuOS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAc2VlIF8ubHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5ndCgzLCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmd0KDMsIDMpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmd0KDEsIDMpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGd0ID0gX2NyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oX2Jhc2VHdCk7XG5cbnZhciBndF8xID0gZ3Q7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjkuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICogQHNlZSBfLmx0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmd0ZSgzLCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmd0ZSgzLCAzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmd0ZSgxLCAzKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBndGUgPSBfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xufSk7XG5cbnZhciBndGVfMSA9IGd0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBfYmFzZUZpbmRJbmRleCA9IGJhc2VGaW5kSW5kZXg7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbnZhciBfYmFzZUlzTmFOID0gYmFzZUlzTmFOO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBfc3RyaWN0SW5kZXhPZiA9IHN0cmljdEluZGV4T2Y7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IF9zdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogX2Jhc2VGaW5kSW5kZXgoYXJyYXksIF9iYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbnZhciBfYmFzZUluZGV4T2YgPSBiYXNlSW5kZXhPZjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyQxID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXlfMSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWckMSk7XG59XG5cbnZhciBpc1N0cmluZ18xID0gaXNTdHJpbmc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDIgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyXzEodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZJDIgfHwgdmFsdWUgPT09IC1JTkZJTklUWSQyKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbnZhciB0b0Zpbml0ZV8xID0gdG9GaW5pdGU7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGVfMSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxudmFyIHRvSW50ZWdlcl8xID0gdG9JbnRlZ2VyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBfYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbnZhciBfYmFzZVZhbHVlcyA9IGJhc2VWYWx1ZXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IF9iYXNlVmFsdWVzKG9iamVjdCwga2V5c18xKG9iamVjdCkpO1xufVxuXG52YXIgdmFsdWVzXzEgPSB2YWx1ZXM7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXgkMSA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlXzEoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzXzEoY29sbGVjdGlvbik7XG4gIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcl8xKGZyb21JbmRleCkgOiAwO1xuXG4gIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgkMShsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBpc1N0cmluZ18xKGNvbGxlY3Rpb24pXG4gICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICA6ICghIWxlbmd0aCAmJiBfYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG59XG5cbnZhciBpbmNsdWRlc18xID0gaW5jbHVkZXM7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnJDEgPSAnW29iamVjdCBCb29sZWFuXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnJDEpO1xufVxuXG52YXIgaXNCb29sZWFuXzEgPSBpc0Jvb2xlYW47XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IF9nZXROYXRpdmUoX3Jvb3QsICdEYXRhVmlldycpO1xuXG52YXIgX0RhdGFWaWV3ID0gRGF0YVZpZXc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gX2dldE5hdGl2ZShfcm9vdCwgJ1Byb21pc2UnKTtcblxudmFyIF9Qcm9taXNlID0gUHJvbWlzZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IF9nZXROYXRpdmUoX3Jvb3QsICdTZXQnKTtcblxudmFyIF9TZXQgPSBTZXQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gX2dldE5hdGl2ZShfcm9vdCwgJ1dlYWtNYXAnKTtcblxudmFyIF9XZWFrTWFwID0gV2Vha01hcDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyQxID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnJDEgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyQxID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyQxID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWckMSA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gX3RvU291cmNlKF9EYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IF90b1NvdXJjZShfTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IF90b1NvdXJjZShfUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IF90b1NvdXJjZShfU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IF90b1NvdXJjZShfV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBfYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChfRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBfRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWckMSkgfHxcbiAgICAoX01hcCAmJiBnZXRUYWcobmV3IF9NYXApICE9IG1hcFRhZyQxKSB8fFxuICAgIChfUHJvbWlzZSAmJiBnZXRUYWcoX1Byb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChfU2V0ICYmIGdldFRhZyhuZXcgX1NldCkgIT0gc2V0VGFnJDEpIHx8XG4gICAgKF9XZWFrTWFwICYmIGdldFRhZyhuZXcgX1dlYWtNYXApICE9IHdlYWtNYXBUYWckMSkpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gX2Jhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyQxID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gX3RvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWckMTtcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnJDE7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWckMTtcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWckMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxudmFyIF9nZXRUYWcgPSBnZXRUYWc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWckMiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyQyID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRiID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkOSA9IG9iamVjdFByb3RvJGIuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZV8xKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXlfMSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcl8xKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXlfMSh2YWx1ZSkgfHwgaXNBcmd1bWVudHNfMSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IF9nZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyQyIHx8IHRhZyA9PSBzZXRUYWckMikge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoX2lzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhX2Jhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGlzRW1wdHlfMSA9IGlzRW1wdHk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBfTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX3N0YWNrQ2xlYXIgPSBzdGFja0NsZWFyO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc3RhY2tEZWxldGUgPSBzdGFja0RlbGV0ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG52YXIgX3N0YWNrR2V0ID0gc3RhY2tHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbnZhciBfc3RhY2tIYXMgPSBzdGFja0hhcztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgX0xpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFfTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IF9NYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfc3RhY2tTZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgX0xpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gX3N0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX3N0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IF9zdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBfc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gX3N0YWNrU2V0O1xuXG52YXIgX1N0YWNrID0gU3RhY2s7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCQyID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEJDIpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9zZXRDYWNoZUFkZCA9IHNldENhY2hlQWRkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbnZhciBfc2V0Q2FjaGVIYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgX01hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBfc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gX3NldENhY2hlSGFzO1xuXG52YXIgX1NldENhY2hlID0gU2V0Q2FjaGU7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfYXJyYXlTb21lID0gYXJyYXlTb21lO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxudmFyIF9jYWNoZUhhcyA9IGNhY2hlSGFzO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgX1NldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghX2FycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIV9jYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2VxdWFsQXJyYXlzID0gZXF1YWxBcnJheXM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSBfcm9vdC5VaW50OEFycmF5O1xuXG52YXIgX1VpbnQ4QXJyYXkgPSBVaW50OEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX21hcFRvQXJyYXkgPSBtYXBUb0FycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX3NldFRvQXJyYXkgPSBzZXRUb0FycmF5O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQxID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyQyID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWckMSA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyQxID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWckMyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyQxID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnJDEgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWckMyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyQyID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnJDEgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnJDEgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnJDIgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byQxID0gX1N5bWJvbCA/IF9TeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byQxID8gc3ltYm9sUHJvdG8kMS52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWckMjpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZyQxOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IF9VaW50OEFycmF5KG9iamVjdCksIG5ldyBfVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnJDI6XG4gICAgY2FzZSBkYXRlVGFnJDE6XG4gICAgY2FzZSBudW1iZXJUYWckMTpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxXzEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWckMTpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZyQxOlxuICAgIGNhc2Ugc3RyaW5nVGFnJDI6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWckMzpcbiAgICAgIHZhciBjb252ZXJ0ID0gX21hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZyQzOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQxO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IF9zZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMTtcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gX2VxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWckMTpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9lcXVhbEJ5VGFnID0gZXF1YWxCeVRhZztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXlfMShvYmplY3QpID8gcmVzdWx0IDogX2FycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG52YXIgX2Jhc2VHZXRBbGxLZXlzID0gYmFzZUdldEFsbEtleXM7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheUZpbHRlciA9IGFycmF5RmlsdGVyO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgc3R1YkFycmF5XzEgPSBzdHViQXJyYXk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRjID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUkMSA9IG9iamVjdFByb3RvJGMucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXlfMSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBfYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUkMS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG52YXIgX2dldFN5bWJvbHMgPSBnZXRTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBfYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzXzEsIF9nZXRTeW1ib2xzKTtcbn1cblxudmFyIF9nZXRBbGxLZXlzID0gZ2V0QWxsS2V5cztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMiA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRkID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYSA9IG9iamVjdFByb3RvJGQuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMixcbiAgICAgIG9ialByb3BzID0gX2dldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gX2dldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkkYS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbE9iamVjdHMgPSBlcXVhbE9iamVjdHM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDMgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyQyID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWckMSA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnJDIgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRiID0gb2JqZWN0UHJvdG8kZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5XzEob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheV8xKG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWckMSA6IF9nZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWckMSA6IF9nZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnJDIgPyBvYmplY3RUYWckMiA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWckMiA/IG9iamVjdFRhZyQyIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWckMixcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyQyLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyXzEob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXJfMShvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgX1N0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheV8xKG9iamVjdCkpXG4gICAgICA/IF9lcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBfZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQzKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSRiLmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkkYi5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgX1N0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IF9TdGFjayk7XG4gIHJldHVybiBfZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG52YXIgX2Jhc2VJc0VxdWFsRGVlcCA9IGJhc2VJc0VxdWFsRGVlcDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlXzEob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBfYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbCA9IGJhc2VJc0VxdWFsO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gX2Jhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbnZhciBpc0VxdWFsXzEgPSBpc0VxdWFsO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNGaW5pdGUgPSBfcm9vdC5pc0Zpbml0ZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRmluaXRlKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNGaW5pdGUoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xufVxuXG52YXIgX2lzRmluaXRlID0gaXNGaW5pdGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0ludGVnZXIoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0ludGVnZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcl8xKHZhbHVlKTtcbn1cblxudmFyIGlzSW50ZWdlcl8xID0gaXNJbnRlZ2VyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnJDIgPSAnW29iamVjdCBOdW1iZXJdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOdW1iZXIoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgKGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnJDIpO1xufVxuXG52YXIgaXNOdW1iZXJfMSA9IGlzTnVtYmVyO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYU4oTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogaXNOYU4odW5kZWZpbmVkKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hTiQxKHZhbHVlKSB7XG4gIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gIHJldHVybiBpc051bWJlcl8xKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG59XG5cbnZhciBfaXNOYU4gPSBpc05hTiQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOaWwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05pbCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOaWwoTmFOKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsO1xufVxuXG52YXIgaXNOaWxfMSA9IGlzTmlsO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbnZhciBpc051bGxfMSA9IGlzTnVsbDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG52YXIgaXNVbmRlZmluZWRfMSA9IGlzVW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA8IG90aGVyO1xufVxuXG52YXIgX2Jhc2VMdCA9IGJhc2VMdDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuOS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAc2VlIF8uZ3RcbiAqIEBleGFtcGxlXG4gKlxuICogXy5sdCgxLCAzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmx0KDMsIDMpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmx0KDMsIDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGx0ID0gX2NyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oX2Jhc2VMdCk7XG5cbnZhciBsdF8xID0gbHQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjkuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICogQHNlZSBfLmd0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmx0ZSgxLCAzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmx0ZSgzLCAzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmx0ZSgzLCAxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBsdGUgPSBfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xufSk7XG5cbnZhciBsdGVfMSA9IGx0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdF8xKG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBfdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0XzEob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKF9pc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2Fzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxudmFyIF9iYXNlU2V0ID0gYmFzZVNldDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gX2Jhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBfYmFzZVNldChyZXN1bHQsIF9jYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVBpY2tCeSA9IGJhc2VQaWNrQnk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG52YXIgX2Jhc2VIYXNJbiA9IGJhc2VIYXNJbjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IF9jYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBfdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aF8xKGxlbmd0aCkgJiYgX2lzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXlfMShvYmplY3QpIHx8IGlzQXJndW1lbnRzXzEob2JqZWN0KSk7XG59XG5cbnZhciBfaGFzUGF0aCA9IGhhc1BhdGg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBfaGFzUGF0aChvYmplY3QsIHBhdGgsIF9iYXNlSGFzSW4pO1xufVxuXG52YXIgaGFzSW5fMSA9IGhhc0luO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIF9iYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luXzEob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbnZhciBfYmFzZVBpY2sgPSBiYXNlUGljaztcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gX2Jhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG52YXIgZmxhdHRlbl8xID0gZmxhdHRlbjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBfc2V0VG9TdHJpbmcoX292ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbl8xKSwgZnVuYyArICcnKTtcbn1cblxudmFyIF9mbGF0UmVzdCA9IGZsYXRSZXN0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gX2ZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBfYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxudmFyIHBpY2tfMSA9IHBpY2s7XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gKiBgcGF0aGAgY3JlYXRpb24uXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICogLy8gPT4gNFxuICpcbiAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAqIC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogX2Jhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG59XG5cbnZhciBzZXRfMSA9IHNldDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxudmFyIF9iYXNlUHJvcGVydHkgPSBiYXNlUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IF9iYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG52YXIgX2FzY2lpU2l6ZSA9IGFzY2lpU2l6ZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UkMSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlJDEgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlJDEgPSByc0NvbWJvTWFya3NSYW5nZSQxICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgKyByc0NvbWJvU3ltYm9sc1JhbmdlJDEsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UkMSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgX2hhc1VuaWNvZGUgPSBoYXNVbmljb2RlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSQxID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlJDIgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDIgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSQyID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSQyID0gcnNDb21ib01hcmtzUmFuZ2UkMiArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQyICsgcnNDb21ib1N5bWJvbHNSYW5nZSQyLFxuICAgIHJzVmFyUmFuZ2UkMSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlJDEgKyAnXScsXG4gICAgcnNDb21ibyQxID0gJ1snICsgcnNDb21ib1JhbmdlJDIgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyQxICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiQxID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UkMSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyQxICsgJz8nLCByc0NvbWJvJDEsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF91bmljb2RlU2l6ZSA9IHVuaWNvZGVTaXplO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gX2hhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gX3VuaWNvZGVTaXplKHN0cmluZylcbiAgICA6IF9hc2NpaVNpemUoc3RyaW5nKTtcbn1cblxudmFyIF9zdHJpbmdTaXplID0gc3RyaW5nU2l6ZTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyQ0ID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnJDQgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAqIC8vID0+IDdcbiAqL1xuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2VfMShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKGNvbGxlY3Rpb24pID8gX3N0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gX2dldFRhZyhjb2xsZWN0aW9uKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWckNCB8fCB0YWcgPT0gc2V0VGFnJDQpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICB9XG4gIHJldHVybiBfYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG52YXIgc2l6ZV8xID0gc2l6ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VTbGljZSA9IGJhc2VTbGljZTtcblxuLyoqXG4gKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAqL1xuZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogX2Jhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbnZhciBfY2FzdFNsaWNlID0gY2FzdFNsaWNlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgcmVnZXhwVGFnJDIgPSAnW29iamVjdCBSZWdFeHBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZyQyO1xufVxuXG52YXIgX2Jhc2VJc1JlZ0V4cCA9IGJhc2VJc1JlZ0V4cDtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNSZWdFeHAgPSBfbm9kZVV0aWwgJiYgX25vZGVVdGlsLmlzUmVnRXhwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IF9iYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IF9iYXNlSXNSZWdFeHA7XG5cbnZhciBpc1JlZ0V4cF8xID0gaXNSZWdFeHA7XG5cbi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbnZhciBfYXNjaWlUb0FycmF5ID0gYXNjaWlUb0FycmF5O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSQyID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlJDMgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDMgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSQzID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSQzID0gcnNDb21ib01hcmtzUmFuZ2UkMyArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQzICsgcnNDb21ib1N5bWJvbHNSYW5nZSQzLFxuICAgIHJzVmFyUmFuZ2UkMiA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwkMSA9ICdbJyArIHJzQXN0cmFsUmFuZ2UkMiArICddJyxcbiAgICByc0NvbWJvJDIgPSAnWycgKyByc0NvbWJvUmFuZ2UkMyArICddJyxcbiAgICByc0ZpdHokMSA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIkMSA9ICcoPzonICsgcnNDb21ibyQyICsgJ3wnICsgcnNGaXR6JDEgKyAnKScsXG4gICAgcnNOb25Bc3RyYWwkMSA9ICdbXicgKyByc0FzdHJhbFJhbmdlJDIgKyAnXScsXG4gICAgcnNSZWdpb25hbCQxID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIkMSA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKJDIgPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QkMSA9IHJzTW9kaWZpZXIkMSArICc/JyxcbiAgICByc09wdFZhciQxID0gJ1snICsgcnNWYXJSYW5nZSQyICsgJ10/JyxcbiAgICByc09wdEpvaW4kMSA9ICcoPzonICsgcnNaV0okMiArICcoPzonICsgW3JzTm9uQXN0cmFsJDEsIHJzUmVnaW9uYWwkMSwgcnNTdXJyUGFpciQxXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciQxICsgcmVPcHRNb2QkMSArICcpKicsXG4gICAgcnNTZXEkMSA9IHJzT3B0VmFyJDEgKyByZU9wdE1vZCQxICsgcnNPcHRKb2luJDEsXG4gICAgcnNTeW1ib2wkMSA9ICcoPzonICsgW3JzTm9uQXN0cmFsJDEgKyByc0NvbWJvJDIgKyAnPycsIHJzQ29tYm8kMiwgcnNSZWdpb25hbCQxLCByc1N1cnJQYWlyJDEsIHJzQXN0cmFsJDFdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUkMSA9IFJlZ0V4cChyc0ZpdHokMSArICcoPz0nICsgcnNGaXR6JDEgKyAnKXwnICsgcnNTeW1ib2wkMSArIHJzU2VxJDEsICdnJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUkMSkgfHwgW107XG59XG5cbnZhciBfdW5pY29kZVRvQXJyYXkgPSB1bmljb2RlVG9BcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIF9oYXNVbmljb2RlKHN0cmluZylcbiAgICA/IF91bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBfYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbnZhciBfc3RyaW5nVG9BcnJheSA9IHN0cmluZ1RvQXJyYXk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG52YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTU7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqL1xuZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgX2lzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gIGlmICghbGltaXQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmdfMShzdHJpbmcpO1xuICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwXzEoc2VwYXJhdG9yKSlcbiAgICAgICkpIHtcbiAgICBzZXBhcmF0b3IgPSBfYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgaWYgKCFzZXBhcmF0b3IgJiYgX2hhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIF9jYXN0U2xpY2UoX3N0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xufVxuXG52YXIgc3BsaXRfMSA9IHNwbGl0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICogLy8gPT4gW3RydWUsIHRydWVdXG4gKi9cbmZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHN0dWJUcnVlXzEgPSBzdHViVHJ1ZTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbmF0aXZlS2V5c0luID0gbmF0aXZlS2V5c0luO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kZiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JGMgPSBvYmplY3RQcm90byRmLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0XzEob2JqZWN0KSkge1xuICAgIHJldHVybiBfbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBfaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkkYy5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzSW4gPSBiYXNlS2V5c0luO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2VfMShvYmplY3QpID8gX2FycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IF9iYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbnZhciBrZXlzSW5fMSA9IGtleXNJbjtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBfY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIF9jb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luXzEoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG52YXIgYXNzaWduSW5XaXRoXzEgPSBhc3NpZ25JbldpdGg7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IF9vdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxudmFyIF9nZXRQcm90b3R5cGUgPSBnZXRQcm90b3R5cGU7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWckMyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDIgPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kZyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMiA9IGZ1bmNQcm90byQyLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRkID0gb2JqZWN0UHJvdG8kZy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmckMi5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2VfMSh2YWx1ZSkgfHwgX2Jhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZyQzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IF9nZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5JGQuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nJDIuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG52YXIgaXNQbGFpbk9iamVjdF8xID0gaXNQbGFpbk9iamVjdDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnJDIgPSAnW29iamVjdCBFcnJvcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0YWcgPSBfYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWckMiB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0XzEodmFsdWUpKTtcbn1cblxudmFyIGlzRXJyb3JfMSA9IGlzRXJyb3I7XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gKiB9LCAnPl8+Jyk7XG4gKlxuICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAqICAgZWxlbWVudHMgPSBbXTtcbiAqIH1cbiAqL1xudmFyIGF0dGVtcHQgPSBfYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBfYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yXzEoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxudmFyIGF0dGVtcHRfMSA9IGF0dGVtcHQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRoID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkZSA9IG9iamVjdFByb3RvJGguaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoZXFfMShvYmpWYWx1ZSwgb2JqZWN0UHJvdG8kaFtrZXldKSAmJiAhaGFzT3duUHJvcGVydHkkZS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICByZXR1cm4gc3JjVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG52YXIgX2N1c3RvbURlZmF1bHRzQXNzaWduSW4gPSBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuXG4vKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbnZhciBfZXNjYXBlU3RyaW5nQ2hhciA9IGVzY2FwZVN0cmluZ0NoYXI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG52YXIgX3JlSW50ZXJwb2xhdGUgPSByZUludGVycG9sYXRlO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IF9iYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbnZhciBfZXNjYXBlSHRtbENoYXIgPSBlc2NhcGVIdG1sQ2hhcjtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICogWFNTIHZlY3RvcnMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZ18xKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIF9lc2NhcGVIdG1sQ2hhcilcbiAgICA6IHN0cmluZztcbn1cblxudmFyIF9lc2NhcGUgPSBlc2NhcGU7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxudmFyIF9yZUVzY2FwZSA9IHJlRXNjYXBlO1xuXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG52YXIgX3JlRXZhbHVhdGUgPSByZUV2YWx1YXRlO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXNjYXBlJzogX3JlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogX3JlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiBfcmVJbnRlcnBvbGF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAndmFyaWFibGUnOiAnJyxcblxuICAvKipcbiAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICAnaW1wb3J0cyc6IHtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICAnXyc6IHsgJ2VzY2FwZSc6IF9lc2NhcGUgfVxuICB9XG59O1xuXG52YXIgdGVtcGxhdGVTZXR0aW5nc18xID0gdGVtcGxhdGVTZXR0aW5ncztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRpID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkZiA9IG9iamVjdFByb3RvJGkuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzXzEuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5nc18xO1xuXG4gIGlmIChndWFyZCAmJiBfaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nXzEoc3RyaW5nKTtcbiAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aF8xKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgX2N1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoXzEoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgX2N1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgaW1wb3J0c0tleXMgPSBrZXlzXzEoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gX2Jhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gIHZhciBpc0VzY2FwaW5nLFxuICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgIChpbnRlcnBvbGF0ZSA9PT0gX3JlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgLy8gd2l0aCBsb29rdXAgKGluIGNhc2Ugb2YgZS5nLiBwcm90b3R5cGUgcG9sbHV0aW9uKSwgYW5kIHN0cmlwIG5ld2xpbmVzIGlmIGFueS5cbiAgLy8gQSBuZXdsaW5lIHdvdWxkbid0IGJlIGEgdmFsaWQgc291cmNlVVJMIGFueXdheSwgYW5kIGl0J2QgZW5hYmxlIGNvZGUgaW5qZWN0aW9uLlxuICB2YXIgc291cmNlVVJMID0gaGFzT3duUHJvcGVydHkkZi5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgID8gKCcvLyMgc291cmNlVVJMPScgK1xuICAgICAgIChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnICcpICtcbiAgICAgICAnXFxuJylcbiAgICA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBfZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgfVxuICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICB9XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG5cbiAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgLy8gTGlrZSB3aXRoIHNvdXJjZVVSTCwgd2UgdGFrZSBjYXJlIHRvIG5vdCBjaGVjayB0aGUgb3B0aW9uJ3MgcHJvdG90eXBlLFxuICAvLyBhcyB0aGlzIGNvbmZpZ3VyYXRpb24gaXMgYSBjb2RlIGluamVjdGlvbiB2ZWN0b3IuXG4gIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5JGYuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gIH1cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHRfMShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3JfMShyZXN1bHQpKSB7XG4gICAgdGhyb3cgcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciB0ZW1wbGF0ZV8xID0gdGVtcGxhdGU7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICpcbiAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gKiAvLyA9PiAnZm9vYmFyJ1xuICpcbiAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAqL1xuZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdfMSh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbn1cblxudmFyIHRvTG93ZXJfMSA9IHRvTG93ZXI7XG5cbi8qKlxuICogQG5hbWUgdG9EYXRlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpdCBpcyB0cmVhdGVkIGFzIGEgdGltZXN0YW1wLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBub25lIG9mIHRoZSBhYm92ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgSW52YWxpZCBEYXRlLlxuICpcbiAqICoqTm90ZSoqOiAqYWxsKiBEYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYW55ICpkYXRlLWZucyogZnVuY3Rpb24gaXMgcHJvY2Vzc2VkIGJ5IGB0b0RhdGVgLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENsb25lIHRoZSBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKG5ldyBEYXRlKDIwMTQsIDEsIDExLCAxMSwgMzAsIDMwKSlcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgdGhlIHRpbWVzdGFtcCB0byBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKDEzOTIwOTg0MzAwMDApXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICovXG5mdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpOyAvLyBDbG9uZSB0aGUgZGF0ZVxuXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJiBhcmdTdHIgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHwgYXJnU3RyID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgU3RyaW5nXScpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGFyZ3VtZW50cy4gUGxlYXNlIHVzZSBgcGFyc2VJU09gIHRvIHBhcnNlIHN0cmluZ3MuIFNlZTogaHR0cHM6Ly9naXQuaW8vZmp1bGVcIik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9JbnRlZ2VyJDEoZGlydHlOdW1iZXIpIHtcbiAgaWYgKGRpcnR5TnVtYmVyID09PSBudWxsIHx8IGRpcnR5TnVtYmVyID09PSB0cnVlIHx8IGRpcnR5TnVtYmVyID09PSBmYWxzZSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcblxuICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICByZXR1cm4gbnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpO1xufVxuXG4vKipcbiAqIEBuYW1lIGFkZE1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBhZGRlZFxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgYWRkZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDc1MCBtaWxsaXNlY29uZHMgdG8gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIHZhciByZXN1bHQgPSBhZGRNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NTozMC43NTBcbiAqL1xuXG5mdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciB0aW1lc3RhbXAgPSB0b0RhdGUoZGlydHlEYXRlKS5nZXRUaW1lKCk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIkMShkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyBhbW91bnQpO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSA9IDYwMDAwO1xuLyoqXG4gKiBHb29nbGUgQ2hyb21lIGFzIG9mIDY3LjAuMzM5Ni44NyBpbnRyb2R1Y2VkIHRpbWV6b25lcyB3aXRoIG9mZnNldCB0aGF0IGluY2x1ZGVzIHNlY29uZHMuXG4gKiBUaGV5IHVzdWFsbHkgYXBwZWFyIGZvciBkYXRlcyB0aGF0IGRlbm90ZSB0aW1lIGJlZm9yZSB0aGUgdGltZXpvbmVzIHdlcmUgaW50cm9kdWNlZFxuICogKGUuZy4gZm9yICdFdXJvcGUvUHJhZ3VlJyB0aW1lem9uZSB0aGUgb2Zmc2V0IGlzIEdNVCswMDo1Nzo0NCBiZWZvcmUgMSBPY3RvYmVyIDE4OTFcbiAqIGFuZCBHTVQrMDE6MDA6MDAgYWZ0ZXIgdGhhdCBkYXRlKVxuICpcbiAqIERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgYW5kIHdvdWxkIHJldHVybiA1NyBmb3IgdGhlIGV4YW1wbGUgYWJvdmUsXG4gKiB3aGljaCB3b3VsZCBsZWFkIHRvIGluY29ycmVjdCBjYWxjdWxhdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSB0aW1lem9uZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzIHRoYXQgdGFrZXMgc2Vjb25kcyBpbiBhY2NvdW50LlxuICovXG5cbmZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoZGlydHlEYXRlLmdldFRpbWUoKSk7XG4gIHZhciBiYXNlVGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGRhdGUuc2V0U2Vjb25kcygwLCAwKTtcbiAgdmFyIG1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lKCkgJSBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFO1xuICByZXR1cm4gYmFzZVRpbWV6b25lT2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArIG1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBuYW1lIGlzVmFsaWRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdmFsaWQ/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGFyZ3VtZW50IGlzIEludmFsaWQgRGF0ZSBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKiBBcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gRGF0ZSB1c2luZyBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIE5vdyBgaXNWYWxpZGAgZG9lc24ndCB0aHJvdyBhbiBleGNlcHRpb25cbiAqICAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICogICBJbnN0ZWFkLCBhcmd1bWVudCBpcyBjb252ZXJ0ZWQgYmVmb3JlaGFuZCB1c2luZyBgdG9EYXRlYC5cbiAqXG4gKiAgIEV4YW1wbGVzOlxuICpcbiAqICAgfCBgaXNWYWxpZGAgYXJndW1lbnQgICAgICAgIHwgQmVmb3JlIHYyLjAuMCB8IHYyLjAuMCBvbndhcmQgfFxuICogICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS18XG4gKiAgIHwgYG5ldyBEYXRlKClgICAgICAgICAgICAgICB8IGB0cnVlYCAgICAgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoJzIwMTYtMDEtMDEnKWAgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZSgnJylgICAgICAgICAgICAgfCBgZmFsc2VgICAgICAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKDE0ODgzNzA4MzUwODEpYCB8IGB0cnVlYCAgICAgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoTmFOKWAgICAgICAgICAgIHwgYGZhbHNlYCAgICAgICB8IGBmYWxzZWAgICAgICAgfFxuICogICB8IGAnMjAxNi0wMS0wMSdgICAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYCcnYCAgICAgICAgICAgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgMTQ4ODM3MDgzNTA4MWAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBOYU5gICAgICAgICAgICAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYGZhbHNlYCAgICAgICB8XG4gKlxuICogICBXZSBpbnRyb2R1Y2UgdGhpcyBjaGFuZ2UgdG8gbWFrZSAqZGF0ZS1mbnMqIGNvbnNpc3RlbnQgd2l0aCBFQ01BU2NyaXB0IGJlaGF2aW9yXG4gKiAgIHRoYXQgdHJ5IHRvIGNvZXJjZSBhcmd1bWVudHMgdG8gdGhlIGV4cGVjdGVkIHR5cGVcbiAqICAgKHdoaWNoIGlzIGFsc28gdGhlIGNhc2Ugd2l0aCBvdGhlciAqZGF0ZS1mbnMqIGZ1bmN0aW9ucykuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRlIC0gdGhlIGRhdGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZSBpcyB2YWxpZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsaWQgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKDIwMTQsIDEsIDMxKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbHVlLCBjb252ZXJ0YWJsZSBpbnRvIGEgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKDEzOTM4MDQ4MDAwMDApXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSBpbnZhbGlkIGRhdGU6XG4gKiB2YXIgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgnJykpXG4gKiAvLz0+IGZhbHNlXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZChkaXJ0eURhdGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHJldHVybiAhaXNOYU4oZGF0ZSk7XG59XG5cbnZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcbiAgbGVzc1RoYW5YU2Vjb25kczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIHNlY29uZCcsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IHNlY29uZHMnXG4gIH0sXG4gIHhTZWNvbmRzOiB7XG4gICAgb25lOiAnMSBzZWNvbmQnLFxuICAgIG90aGVyOiAne3tjb3VudH19IHNlY29uZHMnXG4gIH0sXG4gIGhhbGZBTWludXRlOiAnaGFsZiBhIG1pbnV0ZScsXG4gIGxlc3NUaGFuWE1pbnV0ZXM6IHtcbiAgICBvbmU6ICdsZXNzIHRoYW4gYSBtaW51dGUnLFxuICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzJ1xuICB9LFxuICB4TWludXRlczoge1xuICAgIG9uZTogJzEgbWludXRlJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBtaW51dGVzJ1xuICB9LFxuICBhYm91dFhIb3Vyczoge1xuICAgIG9uZTogJ2Fib3V0IDEgaG91cicsXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0gaG91cnMnXG4gIH0sXG4gIHhIb3Vyczoge1xuICAgIG9uZTogJzEgaG91cicsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gaG91cnMnXG4gIH0sXG4gIHhEYXlzOiB7XG4gICAgb25lOiAnMSBkYXknLFxuICAgIG90aGVyOiAne3tjb3VudH19IGRheXMnXG4gIH0sXG4gIGFib3V0WE1vbnRoczoge1xuICAgIG9uZTogJ2Fib3V0IDEgbW9udGgnLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IG1vbnRocydcbiAgfSxcbiAgeE1vbnRoczoge1xuICAgIG9uZTogJzEgbW9udGgnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcbiAgfSxcbiAgYWJvdXRYWWVhcnM6IHtcbiAgICBvbmU6ICdhYm91dCAxIHllYXInLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IHllYXJzJ1xuICB9LFxuICB4WWVhcnM6IHtcbiAgICBvbmU6ICcxIHllYXInLFxuICAgIG90aGVyOiAne3tjb3VudH19IHllYXJzJ1xuICB9LFxuICBvdmVyWFllYXJzOiB7XG4gICAgb25lOiAnb3ZlciAxIHllYXInLFxuICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG4gIGFsbW9zdFhZZWFyczoge1xuICAgIG9uZTogJ2FsbW9zdCAxIHllYXInLFxuICAgIG90aGVyOiAnYWxtb3N0IHt7Y291bnR9fSB5ZWFycydcbiAgfVxufTtcbmZ1bmN0aW9uIGZvcm1hdERpc3RhbmNlKHRva2VuLCBjb3VudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodHlwZW9mIGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0ub25lO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXS5vdGhlci5yZXBsYWNlKCd7e2NvdW50fX0nLCBjb3VudCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hZGRTdWZmaXgpIHtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJpc29uID4gMCkge1xuICAgICAgcmV0dXJuICdpbiAnICsgcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgJyBhZ28nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0TG9uZ0ZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgdmFyIGZvcm1hdCA9IGFyZ3MuZm9ybWF0c1t3aWR0aF0gfHwgYXJncy5mb3JtYXRzW2FyZ3MuZGVmYXVsdFdpZHRoXTtcbiAgICByZXR1cm4gZm9ybWF0O1xuICB9O1xufVxuXG52YXIgZGF0ZUZvcm1hdHMgPSB7XG4gIGZ1bGw6ICdFRUVFLCBNTU1NIGRvLCB5JyxcbiAgbG9uZzogJ01NTU0gZG8sIHknLFxuICBtZWRpdW06ICdNTU0gZCwgeScsXG4gIHNob3J0OiAnTU0vZGQveXl5eSdcbn07XG52YXIgdGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6ICdoOm1tOnNzIGEgenp6eicsXG4gIGxvbmc6ICdoOm1tOnNzIGEgeicsXG4gIG1lZGl1bTogJ2g6bW06c3MgYScsXG4gIHNob3J0OiAnaDptbSBhJ1xufTtcbnZhciBkYXRlVGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVwiLFxuICBsb25nOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbWVkaXVtOiAne3tkYXRlfX0sIHt7dGltZX19JyxcbiAgc2hvcnQ6ICd7e2RhdGV9fSwge3t0aW1lfX0nXG59O1xudmFyIGZvcm1hdExvbmcgPSB7XG4gIGRhdGU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgdGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IHRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICBkYXRlVGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KVxufTtcblxudmFyIGZvcm1hdFJlbGF0aXZlTG9jYWxlID0ge1xuICBsYXN0V2VlazogXCInbGFzdCcgZWVlZSAnYXQnIHBcIixcbiAgeWVzdGVyZGF5OiBcIid5ZXN0ZXJkYXkgYXQnIHBcIixcbiAgdG9kYXk6IFwiJ3RvZGF5IGF0JyBwXCIsXG4gIHRvbW9ycm93OiBcIid0b21vcnJvdyBhdCcgcFwiLFxuICBuZXh0V2VlazogXCJlZWVlICdhdCcgcFwiLFxuICBvdGhlcjogJ1AnXG59O1xuZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUodG9rZW4sIF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zKSB7XG4gIHJldHVybiBmb3JtYXRSZWxhdGl2ZUxvY2FsZVt0b2tlbl07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlJbmRleCwgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgPyBTdHJpbmcob3B0aW9ucy5jb250ZXh0KSA6ICdzdGFuZGFsb25lJztcbiAgICB2YXIgdmFsdWVzQXJyYXk7XG5cbiAgICBpZiAoY29udGV4dCA9PT0gJ2Zvcm1hdHRpbmcnICYmIGFyZ3MuZm9ybWF0dGluZ1ZhbHVlcykge1xuICAgICAgdmFyIGRlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdEZvcm1hdHRpbmdXaWR0aCB8fCBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBkZWZhdWx0V2lkdGg7XG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1t3aWR0aF0gfHwgYXJncy5mb3JtYXR0aW5nVmFsdWVzW2RlZmF1bHRXaWR0aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZGVmYXVsdFdpZHRoID0gYXJncy5kZWZhdWx0V2lkdGg7XG5cbiAgICAgIHZhciBfd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XG5cbiAgICAgIHZhbHVlc0FycmF5ID0gYXJncy52YWx1ZXNbX3dpZHRoXSB8fCBhcmdzLnZhbHVlc1tfZGVmYXVsdFdpZHRoXTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBhcmdzLmFyZ3VtZW50Q2FsbGJhY2sgPyBhcmdzLmFyZ3VtZW50Q2FsbGJhY2soZGlydHlJbmRleCkgOiBkaXJ0eUluZGV4O1xuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF07XG4gIH07XG59XG5cbnZhciBlcmFWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydCJywgJ0EnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnQkMnLCAnQUQnXSxcbiAgd2lkZTogWydCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJ11cbn07XG52YXIgcXVhcnRlclZhbHVlcyA9IHtcbiAgbmFycm93OiBbJzEnLCAnMicsICczJywgJzQnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnUTEnLCAnUTInLCAnUTMnLCAnUTQnXSxcbiAgd2lkZTogWycxc3QgcXVhcnRlcicsICcybmQgcXVhcnRlcicsICczcmQgcXVhcnRlcicsICc0dGggcXVhcnRlciddIC8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuICAvLyBJZiB5b3UgYXJlIG1ha2luZyBhIG5ldyBsb2NhbGUgYmFzZWQgb24gdGhpcyBvbmUsIGNoZWNrIGlmIHRoZSBzYW1lIGlzIHRydWUgZm9yIHRoZSBsYW5ndWFnZSB5b3UncmUgd29ya2luZyBvbi5cbiAgLy8gR2VuZXJhbGx5LCBmb3JtYXR0ZWQgZGF0ZXMgc2hvdWxkIGxvb2sgbGlrZSB0aGV5IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VudGVuY2UsXG4gIC8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cblxufTtcbnZhciBtb250aFZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gIHdpZGU6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddXG59O1xudmFyIGRheVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcbiAgc2hvcnQ6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHdpZGU6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxufTtcbnZhciBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAnYScsXG4gICAgcG06ICdwJyxcbiAgICBtaWRuaWdodDogJ21pJyxcbiAgICBub29uOiAnbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICdBTScsXG4gICAgcG06ICdQTScsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICdhLm0uJyxcbiAgICBwbTogJ3AubS4nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfVxufTtcbnZhciBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ2EnLFxuICAgIHBtOiAncCcsXG4gICAgbWlkbmlnaHQ6ICdtaScsXG4gICAgbm9vbjogJ24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAnQU0nLFxuICAgIHBtOiAnUE0nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAnYS5tLicsXG4gICAgcG06ICdwLm0uJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9yZGluYWxOdW1iZXIoZGlydHlOdW1iZXIsIF9kaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7IC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXG4gIC8vIGlmIHRoZXkgYXJlIGRpZmZlcmVudCBmb3IgZGlmZmVyZW50IGdyYW1tYXRpY2FsIGdlbmRlcnMsXG4gIC8vIHVzZSBgb3B0aW9ucy51bml0YDpcbiAgLy9cbiAgLy8gICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fVxuICAvLyAgIHZhciB1bml0ID0gU3RyaW5nKG9wdGlvbnMudW5pdClcbiAgLy9cbiAgLy8gd2hlcmUgYHVuaXRgIGNhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF0ZScsICdkYXlPZlllYXInLFxuICAvLyAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCdcblxuICB2YXIgcmVtMTAwID0gbnVtYmVyICUgMTAwO1xuXG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xuICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdzdCc7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICduZCc7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdyZCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bWJlciArICd0aCc7XG59XG5cbnZhciBsb2NhbGl6ZSA9IHtcbiAgb3JkaW5hbE51bWJlcjogb3JkaW5hbE51bWJlcixcbiAgZXJhOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZXJhVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBxdWFydGVyOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogcXVhcnRlclZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBhcmd1bWVudENhbGxiYWNrOiBmdW5jdGlvbiAocXVhcnRlcikge1xuICAgICAgcmV0dXJuIE51bWJlcihxdWFydGVyKSAtIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBtb250aFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgZGF5OiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5VmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXlQZXJpb2Q6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZScsXG4gICAgZm9ybWF0dGluZ1ZhbHVlczogZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0Rm9ybWF0dGluZ1dpZHRoOiAnd2lkZSdcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5U3RyaW5nLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGRpcnR5U3RyaW5nKTtcbiAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2goYXJncy5tYXRjaFBhdHRlcm4pO1xuXG4gICAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcbiAgICB2YXIgcGFyc2VSZXN1bHQgPSBzdHJpbmcubWF0Y2goYXJncy5wYXJzZVBhdHRlcm4pO1xuXG4gICAgaWYgKCFwYXJzZVJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrID8gYXJncy52YWx1ZUNhbGxiYWNrKHBhcnNlUmVzdWx0WzBdKSA6IHBhcnNlUmVzdWx0WzBdO1xuICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZUNhbGxiYWNrID8gb3B0aW9ucy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICByZXN0OiBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpXG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNYXRjaEZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eVN0cmluZywgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhkaXJ0eVN0cmluZyk7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICB2YXIgbWF0Y2hQYXR0ZXJuID0gd2lkdGggJiYgYXJncy5tYXRjaFBhdHRlcm5zW3dpZHRoXSB8fCBhcmdzLm1hdGNoUGF0dGVybnNbYXJncy5kZWZhdWx0TWF0Y2hXaWR0aF07XG4gICAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKG1hdGNoUGF0dGVybik7XG5cbiAgICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZFN0cmluZyA9IG1hdGNoUmVzdWx0WzBdO1xuICAgIHZhciBwYXJzZVBhdHRlcm5zID0gd2lkdGggJiYgYXJncy5wYXJzZVBhdHRlcm5zW3dpZHRoXSB8fCBhcmdzLnBhcnNlUGF0dGVybnNbYXJncy5kZWZhdWx0UGFyc2VXaWR0aF07XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXJzZVBhdHRlcm5zKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFsdWUgPSBwYXJzZVBhdHRlcm5zLmZpbmRJbmRleChmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHN0cmluZyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBmaW5kS2V5KHBhcnNlUGF0dGVybnMsIGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyaW5nKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrID8gYXJncy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZUNhbGxiYWNrID8gb3B0aW9ucy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICByZXN0OiBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpXG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHByZWRpY2F0ZShvYmplY3Rba2V5XSkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG59XG5cbnZhciBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14oXFxkKykodGh8c3R8bmR8cmQpPy9pO1xudmFyIHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXFxkKy9pO1xudmFyIG1hdGNoRXJhUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYnxhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oYlxcLj9cXHM/Y1xcLj98YlxcLj9cXHM/Y1xcLj9cXHM/ZVxcLj98YVxcLj9cXHM/ZFxcLj98Y1xcLj9cXHM/ZVxcLj8pL2ksXG4gIHdpZGU6IC9eKGJlZm9yZSBjaHJpc3R8YmVmb3JlIGNvbW1vbiBlcmF8YW5ubyBkb21pbml8Y29tbW9uIGVyYSkvaVxufTtcbnZhciBwYXJzZUVyYVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXmIvaSwgL14oYXxjKS9pXVxufTtcbnZhciBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXlsxMjM0XS9pLFxuICBhYmJyZXZpYXRlZDogL15xWzEyMzRdL2ksXG4gIHdpZGU6IC9eWzEyMzRdKHRofHN0fG5kfHJkKT8gcXVhcnRlci9pXG59O1xudmFyIHBhcnNlUXVhcnRlclBhdHRlcm5zID0ge1xuICBhbnk6IFsvMS9pLCAvMi9pLCAvMy9pLCAvNC9pXVxufTtcbnZhciBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgd2lkZTogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaVxufTtcbnZhciBwYXJzZU1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9eai9pLCAvXmYvaSwgL15tL2ksIC9eYS9pLCAvXm0vaSwgL15qL2ksIC9eai9pLCAvXmEvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldLFxuICBhbnk6IFsvXmphL2ksIC9eZi9pLCAvXm1hci9pLCAvXmFwL2ksIC9ebWF5L2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYXUvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldXG59O1xudmFyIG1hdGNoRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bc210d2ZdL2ksXG4gIHNob3J0OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAgd2lkZTogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbn07XG52YXIgcGFyc2VEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15zL2ksIC9ebS9pLCAvXnQvaSwgL153L2ksIC9edC9pLCAvXmYvaSwgL15zL2ldLFxuICBhbnk6IFsvXnN1L2ksIC9ebS9pLCAvXnR1L2ksIC9edy9pLCAvXnRoL2ksIC9eZi9pLCAvXnNhL2ldXG59O1xudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1pfG58KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxuICBhbnk6IC9eKFthcF1cXC4/XFxzP21cXC4/fG1pZG5pZ2h0fG5vb258KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pXG59O1xudmFyIHBhcnNlRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueToge1xuICAgIGFtOiAvXmEvaSxcbiAgICBwbTogL15wL2ksXG4gICAgbWlkbmlnaHQ6IC9ebWkvaSxcbiAgICBub29uOiAvXm5vL2ksXG4gICAgbW9ybmluZzogL21vcm5pbmcvaSxcbiAgICBhZnRlcm5vb246IC9hZnRlcm5vb24vaSxcbiAgICBldmVuaW5nOiAvZXZlbmluZy9pLFxuICAgIG5pZ2h0OiAvbmlnaHQvaVxuICB9XG59O1xudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyOiBidWlsZE1hdGNoUGF0dGVybkZuKHtcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgcGFyc2VQYXR0ZXJuOiBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9KSxcbiAgZXJhOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZUVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55JyxcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5OiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICdhbnknLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pXG59O1xuXG4vKipcbiAqIEB0eXBlIHtMb2NhbGV9XG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgRW5nbGlzaCBsb2NhbGUgKFVuaXRlZCBTdGF0ZXMpLlxuICogQGxhbmd1YWdlIEVuZ2xpc2hcbiAqIEBpc28tNjM5LTIgZW5nXG4gKiBAYXV0aG9yIFNhc2hhIEtvc3MgW0Brb3Nzbm9jb3JwXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20va29zc25vY29ycH1cbiAqIEBhdXRob3IgTGVzaGEgS29zcyBbQGxlc2hha29zc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xlc2hha29zc31cbiAqL1xuXG52YXIgbG9jYWxlID0ge1xuICBmb3JtYXREaXN0YW5jZTogZm9ybWF0RGlzdGFuY2UsXG4gIGZvcm1hdExvbmc6IGZvcm1hdExvbmcsXG4gIGZvcm1hdFJlbGF0aXZlOiBmb3JtYXRSZWxhdGl2ZSxcbiAgbG9jYWxpemU6IGxvY2FsaXplLFxuICBtYXRjaDogbWF0Y2gsXG4gIG9wdGlvbnM6IHtcbiAgICB3ZWVrU3RhcnRzT246IDBcbiAgICAvKiBTdW5kYXkgKi9cbiAgICAsXG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiAxXG4gIH1cbn07XG5cbi8qKlxuICogQG5hbWUgc3ViTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgc3VidHJhY3RlZFxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgc3VidHJhY3RlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCA3NTAgbWlsbGlzZWNvbmRzIGZyb20gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIHZhciByZXN1bHQgPSBzdWJNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NToyOS4yNTBcbiAqL1xuXG5mdW5jdGlvbiBzdWJNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIkMShkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCAtYW1vdW50KTtcbn1cblxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm9zKG51bWJlciwgdGFyZ2V0TGVuZ3RoKSB7XG4gIHZhciBzaWduID0gbnVtYmVyIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKS50b1N0cmluZygpO1xuXG4gIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgb3V0cHV0ID0gJzAnICsgb3V0cHV0O1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKyBvdXRwdXQ7XG59XG5cbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICovXG5cbnZhciBmb3JtYXR0ZXJzID0ge1xuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIC8vIEZyb20gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zMS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfdG9rZW5zXG4gICAgLy8gfCBZZWFyICAgICB8ICAgICB5IHwgeXkgfCAgIHl5eSB8ICB5eXl5IHwgeXl5eXkgfFxuICAgIC8vIHwtLS0tLS0tLS0tfC0tLS0tLS18LS0tLXwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLXxcbiAgICAvLyB8IEFEIDEgICAgIHwgICAgIDEgfCAwMSB8ICAgMDAxIHwgIDAwMDEgfCAwMDAwMSB8XG4gICAgLy8gfCBBRCAxMiAgICB8ICAgIDEyIHwgMTIgfCAgIDAxMiB8ICAwMDEyIHwgMDAwMTIgfFxuICAgIC8vIHwgQUQgMTIzICAgfCAgIDEyMyB8IDIzIHwgICAxMjMgfCAgMDEyMyB8IDAwMTIzIHxcbiAgICAvLyB8IEFEIDEyMzQgIHwgIDEyMzQgfCAzNCB8ICAxMjM0IHwgIDEyMzQgfCAwMTIzNCB8XG4gICAgLy8gfCBBRCAxMjM0NSB8IDEyMzQ1IHwgNDUgfCAxMjM0NSB8IDEyMzQ1IHwgMTIzNDUgfFxuICAgIHZhciBzaWduZWRZZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpOyAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuXG4gICAgdmFyIHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRva2VuID09PSAneXknID8geWVhciAlIDEwMCA6IHllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1vbnRoXG4gIE06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICByZXR1cm4gdG9rZW4gPT09ICdNJyA/IFN0cmluZyhtb250aCArIDEpIDogYWRkTGVhZGluZ1plcm9zKG1vbnRoICsgMSwgMik7XG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZDogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0RhdGUoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRhdGUuZ2V0VVRDSG91cnMoKSAvIDEyID49IDEgPyAncG0nIDogJ2FtJztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnYWEnOlxuICAgICAgY2FzZSAnYWFhJzpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICBjYXNlICdhYWFhYSc6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWVbMF07XG5cbiAgICAgIGNhc2UgJ2FhYWEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZSA9PT0gJ2FtJyA/ICdhLm0uJyA6ICdwLm0uJztcbiAgICB9XG4gIH0sXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENIb3VycygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gU2Vjb25kXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENTZWNvbmRzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgbnVtYmVyT2ZEaWdpdHMgPSB0b2tlbi5sZW5ndGg7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgdmFyIGZyYWN0aW9uYWxTZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgKiBNYXRoLnBvdygxMCwgbnVtYmVyT2ZEaWdpdHMgLSAzKSk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmcmFjdGlvbmFsU2Vjb25kcywgdG9rZW4ubGVuZ3RoKTtcbiAgfVxufTtcblxudmFyIE1JTExJU0VDT05EU19JTl9EQVkgPSA4NjQwMDAwMDsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIGdldFVUQ0RheU9mWWVhcihkaXJ0eURhdGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZZZWFyVGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gIHZhciBkaWZmZXJlbmNlID0gdGltZXN0YW1wIC0gc3RhcnRPZlllYXJUaW1lc3RhbXA7XG4gIHJldHVybiBNYXRoLmZsb29yKGRpZmZlcmVuY2UgLyBNSUxMSVNFQ09ORFNfSU5fREFZKSArIDE7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc3RhcnRPZlVUQ0lTT1dlZWsoZGlydHlEYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgd2Vla1N0YXJ0c09uID0gMTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciBkaWZmID0gKGRheSA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIHdlZWtTdGFydHNPbjtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZik7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkYXRlO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZk5leHRZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhcik7XG4gIHZhciBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyKTtcblxuICBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHllYXIgLSAxO1xuICB9XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIHllYXIgPSBnZXRVVENJU09XZWVrWWVhcihkaXJ0eURhdGUpO1xuICB2YXIgZm91cnRoT2ZKYW51YXJ5ID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeSk7XG4gIHJldHVybiBkYXRlO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUsgPSA2MDQ4MDAwMDA7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBnZXRVVENJU09XZWVrKGRpcnR5RGF0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRpZmYgPSBzdGFydE9mVVRDSVNPV2VlayhkYXRlKS5nZXRUaW1lKCkgLSBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGF0ZSkuZ2V0VGltZSgpOyAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuICAvLyBiZWNhdXNlIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnRcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBNSUxMSVNFQ09ORFNfSU5fV0VFSykgKyAxO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHN0YXJ0T2ZVVENXZWVrKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLndlZWtTdGFydHNPbjtcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIkMShsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIkMShvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciBkaWZmID0gKGRheSA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIHdlZWtTdGFydHNPbjtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZik7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkYXRlO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIGdldFVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIkMShsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIkMShvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMSBhbmQgNyBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEoZmlyc3RXZWVrQ29udGFpbnNEYXRlID49IDEgJiYgZmlyc3RXZWVrQ29udGFpbnNEYXRlIDw9IDcpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZpcnN0V2Vla0NvbnRhaW5zRGF0ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNyBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGZpcnN0V2Vla09mTmV4dFllYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRVVENGdWxsWWVhcih5ZWFyICsgMSwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZVVENXZWVrKGZpcnN0V2Vla09mTmV4dFllYXIsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmaXJzdFdlZWtPZlRoaXNZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrT2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENXZWVrKGZpcnN0V2Vla09mVGhpc1llYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDE7XG4gIH0gZWxzZSBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB5ZWFyIC0gMTtcbiAgfVxufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHN0YXJ0T2ZVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU7XG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyAxIDogdG9JbnRlZ2VyJDEobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyJDEob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgeWVhciA9IGdldFVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIGZpcnN0V2VlayA9IG5ldyBEYXRlKDApO1xuICBmaXJzdFdlZWsuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgZGF0ZSA9IHN0YXJ0T2ZVVENXZWVrKGZpcnN0V2VlaywgZGlydHlPcHRpb25zKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fV0VFSyQxID0gNjA0ODAwMDAwOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gZ2V0VVRDV2VlayhkaXJ0eURhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkaWZmID0gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucykuZ2V0VGltZSgpIC0gc3RhcnRPZlVUQ1dlZWtZZWFyKGRhdGUsIG9wdGlvbnMpLmdldFRpbWUoKTsgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gIC8vIChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdClcblxuICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gTUlMTElTRUNPTkRTX0lOX1dFRUskMSkgKyAxO1xufVxuXG52YXIgZGF5UGVyaW9kRW51bSA9IHtcbiAgYW06ICdhbScsXG4gIHBtOiAncG0nLFxuICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgbm9vbjogJ25vb24nLFxuICBtb3JuaW5nOiAnbW9ybmluZycsXG4gIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgbmlnaHQ6ICduaWdodCdcbiAgLypcbiAgICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcbiAgICogfCAgYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgfCAgQiAgfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgfFxuICAgKiB8ICBjICB8IFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrICB8ICBDKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8XG4gICAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgZSAgfCBMb2NhbCBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgfCAgRSAgfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBmICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBGKiB8IERheSBvZiB3ZWVrIGluIG1vbnRoICAgICAgICAgICB8XG4gICAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBpISB8IElTTyBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgICB8ICBJISB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICB8XG4gICAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcbiAgICogfCAgayAgfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgfCAgSyAgfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBsKiB8IChkZXByZWNhdGVkKSAgICAgICAgICAgICAgICAgICB8ICBMICB8IFN0YW5kLWFsb25lIG1vbnRoICAgICAgICAgICAgICB8XG4gICAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgbiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBvISB8IE9yZGluYWwgbnVtYmVyIG1vZGlmaWVyICAgICAgICB8ICBPICB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIHAhIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgIHwgIFAhIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgIHxcbiAgICogfCAgcSAgfCBTdGFuZC1hbG9uZSBxdWFydGVyICAgICAgICAgICAgfCAgUSAgfCBRdWFydGVyICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICByKiB8IFJlbGF0ZWQgR3JlZ29yaWFuIHllYXIgICAgICAgICB8ICBSISB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICB8XG4gICAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAgICogfCAgdCEgfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgfCAgVCEgfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgfFxuICAgKiB8ICB1ICB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICB8ICBVKiB8IEN5Y2xpYyB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcbiAgICogfCAgdyAgfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgfCAgVyogfCBXZWVrIG9mIG1vbnRoICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICB4ICB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICB8ICBYICB8IFRpbWV6b25lIChJU08tODYwMSkgICAgICAgICAgICB8XG4gICAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcbiAgICogfCAgeiAgfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgfCAgWiogfCBUaW1lem9uZSAoYWxpYXNlcykgICAgICAgICAgICAgfFxuICAgKlxuICAgKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gICAqXG4gICAqIExldHRlcnMgbWFya2VkIGJ5ICEgYXJlIG5vbi1zdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IGRhdGUtZm5zOlxuICAgKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgZm9ybWF0YCBkb2NzKVxuICAgKiAtIGBpYCBpcyBJU08gZGF5IG9mIHdlZWsuIEZvciBgaWAgYW5kIGBpaWAgaXMgcmV0dXJucyBudW1lcmljIElTTyB3ZWVrIGRheXMsXG4gICAqICAgaS5lLiA3IGZvciBTdW5kYXksIDEgZm9yIE1vbmRheSwgZXRjLlxuICAgKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXG4gICAqIC0gYFJgIGlzIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLCBhcyBvcHBvc2VkIHRvIGBZYCB3aGljaCBpcyBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyLlxuICAgKiAgIGBSYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYElgIGFuZCBgaWBcbiAgICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXG4gICAqICAgYFlgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgd2AgYW5kIGBlYFxuICAgKiAgIGZvciB3ZWVrLW51bWJlcmluZyBkYXRlIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUuXG4gICAqIC0gYFBgIGlzIGxvbmcgbG9jYWxpemVkIGRhdGUgZm9ybWF0XG4gICAqIC0gYHBgIGlzIGxvbmcgbG9jYWxpemVkIHRpbWUgZm9ybWF0XG4gICAqL1xuXG59O1xudmFyIGZvcm1hdHRlcnMkMSA9IHtcbiAgLy8gRXJhXG4gIEc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZXJhID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpID4gMCA/IDEgOiAwO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gQUQsIEJDXG4gICAgICBjYXNlICdHJzpcbiAgICAgIGNhc2UgJ0dHJzpcbiAgICAgIGNhc2UgJ0dHRyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCdcbiAgICAgICAgfSk7XG4gICAgICAvLyBBLCBCXG5cbiAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdydcbiAgICAgICAgfSk7XG4gICAgICAvLyBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdFxuXG4gICAgICBjYXNlICdHR0dHJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFllYXJcbiAgeTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIC8vIE9yZGluYWwgbnVtYmVyXG4gICAgaWYgKHRva2VuID09PSAneW8nKSB7XG4gICAgICB2YXIgc2lnbmVkWWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTsgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcblxuICAgICAgdmFyIHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHllYXIsIHtcbiAgICAgICAgdW5pdDogJ3llYXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycy55KGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhclxuICBZOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIHNpZ25lZFdlZWtZZWFyID0gZ2V0VVRDV2Vla1llYXIoZGF0ZSwgb3B0aW9ucyk7IC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG5cbiAgICB2YXIgd2Vla1llYXIgPSBzaWduZWRXZWVrWWVhciA+IDAgPyBzaWduZWRXZWVrWWVhciA6IDEgLSBzaWduZWRXZWVrWWVhcjsgLy8gVHdvIGRpZ2l0IHllYXJcblxuICAgIGlmICh0b2tlbiA9PT0gJ1lZJykge1xuICAgICAgdmFyIHR3b0RpZ2l0WWVhciA9IHdlZWtZZWFyICUgMTAwO1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0d29EaWdpdFllYXIsIDIpO1xuICAgIH0gLy8gT3JkaW5hbCBudW1iZXJcblxuXG4gICAgaWYgKHRva2VuID09PSAnWW8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrWWVhciwge1xuICAgICAgICB1bml0OiAneWVhcidcbiAgICAgIH0pO1xuICAgIH0gLy8gUGFkZGluZ1xuXG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICBSOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgaXNvV2Vla1llYXIgPSBnZXRVVENJU09XZWVrWWVhcihkYXRlKTsgLy8gUGFkZGluZ1xuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRXh0ZW5kZWQgeWVhci4gVGhpcyBpcyBhIHNpbmdsZSBudW1iZXIgZGVzaWduYXRpbmcgdGhlIHllYXIgb2YgdGhpcyBjYWxlbmRhciBzeXN0ZW0uXG4gIC8vIFRoZSBtYWluIGRpZmZlcmVuY2UgYmV0d2VlbiBgeWAgYW5kIGB1YCBsb2NhbGl6ZXJzIGFyZSBCLkMuIHllYXJzOlxuICAvLyB8IFllYXIgfCBgeWAgfCBgdWAgfFxuICAvLyB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICAvLyB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICAvLyB8IEJDIDEgfCAgIDEgfCAgIDAgfFxuICAvLyB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICAvLyBBbHNvIGB5eWAgYWx3YXlzIHJldHVybnMgdGhlIGxhc3QgdHdvIGRpZ2l0cyBvZiBhIHllYXIsXG4gIC8vIHdoaWxlIGB1dWAgcGFkcyBzaW5nbGUgZGlnaXQgeWVhcnMgdG8gMiBjaGFyYWN0ZXJzIGFuZCByZXR1cm5zIG90aGVyIHllYXJzIHVuY2hhbmdlZC5cbiAgdTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh5ZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBRdWFydGVyXG4gIFE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgcXVhcnRlciA9IE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHF1YXJ0ZXIpO1xuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcblxuICAgICAgY2FzZSAnUVEnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHF1YXJ0ZXIsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG5cbiAgICAgIGNhc2UgJ1FvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwge1xuICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG5cbiAgICAgIGNhc2UgJ1FRUSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcblxuICAgICAgY2FzZSAnUVFRUVEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgIGNhc2UgJ1FRUVEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgcXVhcnRlclxuICBxOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMyk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlICdxJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKTtcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG5cbiAgICAgIGNhc2UgJ3FxJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICBjYXNlICdxbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICBjYXNlICdxcXEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgIGNhc2UgJ3FxcXFxJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICBjYXNlICdxcXFxJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIE1vbnRoXG4gIE06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdNJzpcbiAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuTShkYXRlLCB0b2tlbik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgIGNhc2UgJ01vJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobW9udGggKyAxLCB7XG4gICAgICAgICAgdW5pdDogJ21vbnRoJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuXG4gICAgICBjYXNlICdNTU0nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBKLCBGLCAuLi4sIERcblxuICAgICAgY2FzZSAnTU1NTU0nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgY2FzZSAnTU1NTSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIG1vbnRoXG4gIEw6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhtb250aCArIDEpO1xuICAgICAgLy8gMDEsIDAyLCAuLi4sIDEyXG5cbiAgICAgIGNhc2UgJ0xMJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhtb250aCArIDEsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuXG4gICAgICBjYXNlICdMbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoICsgMSwge1xuICAgICAgICAgIHVuaXQ6ICdtb250aCdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgY2FzZSAnTExMJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgIGNhc2UgJ0xMTExMJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG5cbiAgICAgIGNhc2UgJ0xMTEwnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBMb2NhbCB3ZWVrIG9mIHllYXJcbiAgdzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciB3ZWVrID0gZ2V0VVRDV2VlayhkYXRlLCBvcHRpb25zKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ3dvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIod2Vlaywge1xuICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3Mod2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSVNPIHdlZWsgb2YgeWVhclxuICBJOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGlzb1dlZWsgPSBnZXRVVENJU09XZWVrKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSAnSW8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihpc29XZWVrLCB7XG4gICAgICAgIHVuaXQ6ICd3ZWVrJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdkbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDRGF0ZSgpLCB7XG4gICAgICAgIHVuaXQ6ICdkYXRlJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMuZChkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIERheSBvZiB5ZWFyXG4gIEQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gZ2V0VVRDRGF5T2ZZZWFyKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSAnRG8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXlPZlllYXIsIHtcbiAgICAgICAgdW5pdDogJ2RheU9mWWVhcidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF5T2ZZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBEYXkgb2Ygd2Vla1xuICBFOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBUdWVcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgY2FzZSAnRUUnOlxuICAgICAgY2FzZSAnRUVFJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ0VFRUVFJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnRUVFRUVFJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ0VFRUUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgbG9jYWxEYXlPZldlZWsgPSAoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIE51bWVyaWNhbCB2YWx1ZSAoTnRoIGRheSBvZiB3ZWVrIHdpdGggY3VycmVudCBsb2NhbGUgb3Igd2Vla1N0YXJ0c09uKVxuICAgICAgY2FzZSAnZSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcobG9jYWxEYXlPZldlZWspO1xuICAgICAgLy8gUGFkZGVkIG51bWVyaWNhbCB2YWx1ZVxuXG4gICAgICBjYXNlICdlZSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobG9jYWxEYXlPZldlZWssIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgN3RoXG5cbiAgICAgIGNhc2UgJ2VvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobG9jYWxEYXlPZldlZWssIHtcbiAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnZWVlJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ2VlZWVlJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnZWVlZWVlJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ2VlZWUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrXG4gIGM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgbG9jYWxEYXlPZldlZWsgPSAoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIE51bWVyaWNhbCB2YWx1ZSAoc2FtZSBhcyBpbiBgZWApXG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2Vlayk7XG4gICAgICAvLyBQYWRkZWQgbnVtZXJpY2FsIHZhbHVlXG5cbiAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhsb2NhbERheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuXG4gICAgICBjYXNlICdjbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7XG4gICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2NjYyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdjY2NjYyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ2NjY2NjYyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdjY2NjJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBJU08gZGF5IG9mIHdlZWtcbiAgaTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBpc29EYXlPZldlZWsgPSBkYXlPZldlZWsgPT09IDAgPyA3IDogZGF5T2ZXZWVrO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMlxuICAgICAgY2FzZSAnaSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcoaXNvRGF5T2ZXZWVrKTtcbiAgICAgIC8vIDAyXG5cbiAgICAgIGNhc2UgJ2lpJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29EYXlPZldlZWssIHRva2VuLmxlbmd0aCk7XG4gICAgICAvLyAybmRcblxuICAgICAgY2FzZSAnaW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihpc29EYXlPZldlZWssIHtcbiAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZVxuXG4gICAgICBjYXNlICdpaWknOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnaWlpaWknOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdpaWlpaWknOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnaWlpaSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gJ3BtJyA6ICdhbSc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdhJzpcbiAgICAgIGNhc2UgJ2FhJzpcbiAgICAgIGNhc2UgJ2FhYSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdhYWFhYSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYWFhYSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxuICBiOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWU7XG5cbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5taWRuaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gJ3BtJyA6ICdhbSc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnYic6XG4gICAgICBjYXNlICdiYic6XG4gICAgICBjYXNlICdiYmInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYmJiYmInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2JiYmInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIGluIHRoZSBtb3JuaW5nLCBpbiB0aGUgYWZ0ZXJub29uLCBpbiB0aGUgZXZlbmluZywgYXQgbmlnaHRcbiAgQjogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlO1xuXG4gICAgaWYgKGhvdXJzID49IDE3KSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmV2ZW5pbmc7XG4gICAgfSBlbHNlIGlmIChob3VycyA+PSAxMikge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5hZnRlcm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA+PSA0KSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm1vcm5pbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubmlnaHQ7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnQic6XG4gICAgICBjYXNlICdCQic6XG4gICAgICBjYXNlICdCQkInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnQkJCQkInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ0JCQkInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdobycpIHtcbiAgICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyO1xuICAgICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDEyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycy5oKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gSG91ciBbMC0yM11cbiAgSDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ0hvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENIb3VycygpLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMuSChkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIEhvdXIgWzAtMTFdXG4gIEs6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMjtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0tvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGhvdXJzLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBIb3VyIFsxLTI0XVxuICBrOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGlmIChob3VycyA9PT0gMCkgaG91cnMgPSAyNDtcblxuICAgIGlmICh0b2tlbiA9PT0gJ2tvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGhvdXJzLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ21vJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENNaW51dGVzKCksIHtcbiAgICAgICAgdW5pdDogJ21pbnV0ZSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLm0oZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBTZWNvbmRcbiAgczogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ3NvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENTZWNvbmRzKCksIHtcbiAgICAgICAgdW5pdDogJ3NlY29uZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLnMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUzogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcnMuUyhkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXG4gIFg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgaWYgKHRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1onO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEhvdXJzIGFuZCBvcHRpb25hbCBtaW51dGVzXG4gICAgICBjYXNlICdYJzpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGBYWGBcblxuICAgICAgY2FzZSAnWFhYWCc6XG4gICAgICBjYXNlICdYWCc6XG4gICAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhYYFxuXG4gICAgICBjYXNlICdYWFhYWCc6XG4gICAgICBjYXNlICdYWFgnOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRoIGA6YCBkZWxpbWl0ZXJcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxLiBJZiBvZmZzZXQgaXMgMCwgb3V0cHV0IGlzIGAnKzAwOjAwJ2Agb3IgZXF1aXZhbGVudClcbiAgeDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSAneCc6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXModGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHhgXG5cbiAgICAgIGNhc2UgJ3h4eHgnOlxuICAgICAgY2FzZSAneHgnOlxuICAgICAgICAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4eGBcblxuICAgICAgY2FzZSAneHh4eHgnOlxuICAgICAgY2FzZSAneHh4JzogLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aCBgOmAgZGVsaW1pdGVyXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChHTVQpXG4gIE86IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gU2hvcnRcbiAgICAgIGNhc2UgJ08nOlxuICAgICAgY2FzZSAnT08nOlxuICAgICAgY2FzZSAnT09PJzpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmVTaG9ydCh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICAgIC8vIExvbmdcblxuICAgICAgY2FzZSAnT09PTyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXRpb24pXG4gIHo6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gU2hvcnRcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnenonOlxuICAgICAgY2FzZSAnenp6JzpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmVTaG9ydCh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICAgIC8vIExvbmdcblxuICAgICAgY2FzZSAnenp6eic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFNlY29uZHMgdGltZXN0YW1wXG4gIHQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICBUOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXN0YW1wID0gb3JpZ2luYWxEYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVTaG9ydChvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKSB7XG4gIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApO1xuICB2YXIgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuXG4gIGlmIChtaW51dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24gKyBTdHJpbmcoaG91cnMpO1xuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGRpcnR5RGVsaW1pdGVyIHx8ICcnO1xuICByZXR1cm4gc2lnbiArIFN0cmluZyhob3VycykgKyBkZWxpbWl0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyhvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKSB7XG4gIGlmIChvZmZzZXQgJSA2MCA9PT0gMCkge1xuICAgIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgICByZXR1cm4gc2lnbiArIGFkZExlYWRpbmdaZXJvcyhNYXRoLmFicyhvZmZzZXQpIC8gNjAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKSB7XG4gIHZhciBkZWxpbWl0ZXIgPSBkaXJ0eURlbGltaXRlciB8fCAnJztcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xuICB2YXIgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgdmFyIGhvdXJzID0gYWRkTGVhZGluZ1plcm9zKE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApLCAyKTtcbiAgdmFyIG1pbnV0ZXMgPSBhZGRMZWFkaW5nWmVyb3MoYWJzT2Zmc2V0ICUgNjAsIDIpO1xuICByZXR1cm4gc2lnbiArIGhvdXJzICsgZGVsaW1pdGVyICsgbWludXRlcztcbn1cblxuZnVuY3Rpb24gZGF0ZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZykge1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlICdQJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ3Nob3J0J1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdQUCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdtZWRpdW0nXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1BQUCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdsb25nJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdQUFBQJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnZnVsbCdcbiAgICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpbWVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpIHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSAncCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdzaG9ydCdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAncHAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnbWVkaXVtJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdwcHAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnbG9uZydcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAncHBwcCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ2Z1bGwnXG4gICAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZykge1xuICB2YXIgbWF0Y2hSZXN1bHQgPSBwYXR0ZXJuLm1hdGNoKC8oUCspKHArKT8vKTtcbiAgdmFyIGRhdGVQYXR0ZXJuID0gbWF0Y2hSZXN1bHRbMV07XG4gIHZhciB0aW1lUGF0dGVybiA9IG1hdGNoUmVzdWx0WzJdO1xuXG4gIGlmICghdGltZVBhdHRlcm4pIHtcbiAgICByZXR1cm4gZGF0ZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZyk7XG4gIH1cblxuICB2YXIgZGF0ZVRpbWVGb3JtYXQ7XG5cbiAgc3dpdGNoIChkYXRlUGF0dGVybikge1xuICAgIGNhc2UgJ1AnOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdzaG9ydCdcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQUCc6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ21lZGl1bSdcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQUFAnOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdsb25nJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BQUFAnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ2Z1bGwnXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGRhdGVUaW1lRm9ybWF0LnJlcGxhY2UoJ3t7ZGF0ZX19JywgZGF0ZUxvbmdGb3JtYXR0ZXIoZGF0ZVBhdHRlcm4sIGZvcm1hdExvbmcpKS5yZXBsYWNlKCd7e3RpbWV9fScsIHRpbWVMb25nRm9ybWF0dGVyKHRpbWVQYXR0ZXJuLCBmb3JtYXRMb25nKSk7XG59XG5cbnZhciBsb25nRm9ybWF0dGVycyA9IHtcbiAgcDogdGltZUxvbmdGb3JtYXR0ZXIsXG4gIFA6IGRhdGVUaW1lTG9uZ0Zvcm1hdHRlclxufTtcblxudmFyIHByb3RlY3RlZERheU9mWWVhclRva2VucyA9IFsnRCcsICdERCddO1xudmFyIHByb3RlY3RlZFdlZWtZZWFyVG9rZW5zID0gWydZWScsICdZWVlZJ107XG5mdW5jdGlvbiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMuaW5kZXhPZih0b2tlbikgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBwcm90ZWN0ZWRXZWVrWWVhclRva2Vucy5pbmRleE9mKHRva2VuKSAhPT0gLTE7XG59XG5mdW5jdGlvbiB0aHJvd1Byb3RlY3RlZEVycm9yKHRva2VuKSB7XG4gIGlmICh0b2tlbiA9PT0gJ1lZWVknKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnM7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXInKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ1lZJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdVc2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnM7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXInKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ0QnKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VzZSBgZGAgaW5zdGVhZCBvZiBgRGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGg7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXInKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ0REJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdVc2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGg7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXInKTtcbiAgfVxufVxuXG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuXG52YXIgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZzsgLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcbnZhciBlc2NhcGVkU3RyaW5nUmVnRXhwID0gL14nKC4qPyknPyQvO1xudmFyIGRvdWJsZVF1b3RlUmVnRXhwID0gLycnL2c7XG52YXIgdW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAgPSAvW2EtekEtWl0vO1xuLyoqXG4gKiBAbmFtZSBmb3JtYXRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgRm9ybWF0IHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdC4gVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgYGZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogVGhlIGNoYXJhY3RlcnMgd3JhcHBlZCBiZXR3ZWVuIHR3byBzaW5nbGUgcXVvdGVzIGNoYXJhY3RlcnMgKCcpIGFyZSBlc2NhcGVkLlxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXG4gKiAoc2VlIHRoZSBsYXN0IGV4YW1wbGUpXG4gKlxuICogRm9ybWF0IG9mIHRoZSBzdHJpbmcgaXMgYmFzZWQgb24gVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0ZpZWxkX1N5bWJvbF9UYWJsZVxuICogd2l0aCBhIGZldyBhZGRpdGlvbnMgKHNlZSBub3RlIDcgYmVsb3cgdGhlIHRhYmxlKS5cbiAqXG4gKiBBY2NlcHRlZCBwYXR0ZXJuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBhdHRlcm4gfCBSZXN1bHQgZXhhbXBsZXMgICAgICAgICAgICAgICAgICAgfCBOb3RlcyB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfFxuICogfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRy4uR0dHICB8IEFELCBCQyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0cgICAgfCBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHRyAgIHwgQSwgQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHlvICAgICAgfCA0NHRoLCAxc3QsIDB0aCwgMTd0aCAgICAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5ICAgICB8IDA0NCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXl5eSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgIHwgWSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgMjAxN3RoICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZICAgICB8IDA0NCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZWSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgIHwgUiAgICAgICB8IC00MywgMCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSICAgICAgfCAtNDMsIDAwLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlIgICAgIHwgLTA0MywgMDAwLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUiAgICB8IC0wMDQzLCAwMDAwLCAwMDAxLCAxOTAwLCAyMDE3ICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUlJSICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUsNyB8XG4gKiB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICAgfCB1ICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXUgICAgICB8IC00MywgMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dSAgICAgfCAtMDQzLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1ICAgIHwgLTAwNDMsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1dXUgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSAgIHxcbiAqIHwgUXVhcnRlciAoZm9ybWF0dGluZykgICAgICAgICAgICB8IFEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRUVEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgUXVhcnRlciAoc3RhbmQtYWxvbmUpICAgICAgICAgICB8IHEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxcXEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgTW9udGggKGZvcm1hdHRpbmcpICAgICAgICAgICAgICB8IE0gICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU0gICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTSAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NTU0gICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTW9udGggKHN0YW5kLWFsb25lKSAgICAgICAgICAgICB8IEwgICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTEwgICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTCAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMTEwgICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgICB8IHcgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3byAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgd3cgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgICB8IEkgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSUkgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgICB8IGQgICAgICAgfCAxLCAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZGQgICAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgICB8IEQgICAgICAgfCAxLCAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgICAgfCA5ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzY1dGgsIDM2NnRoICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREQgICAgICB8IDAxLCAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERERCAgICAgfCAwMDEsIDAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBEYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgICAgIHwgRS4uRUVFICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRUVFICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICB8IGkgICAgICAgfCAxLCAyLCAzLCAuLi4sIDcgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgN3RoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWkgICAgICB8IDAxLCAwMiwgLi4uLCAwNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWkgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWlpaSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCA3ICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgfCBlICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZW8gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWUgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlZWUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoc3RhbmQtYWxvbmUpIHwgYyAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjYyAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2MgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjYyAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjY2NjICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICB8IGEuLmFhYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8IGIuLmJiYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmJiICAgIHwgYS5tLiwgcC5tLiwgbm9vbiwgbWlkbmlnaHQgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiYmIgICB8IGEsIHAsIG4sIG1pICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgICB8IEIuLkJCQiAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBCQkJCICAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQkJCQkIgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgICB8IGggICAgICAgfCAxLCAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBobyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMTJ0aCAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaGggICAgICB8IDAxLCAwMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgICB8IEggICAgICAgfCAwLCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBIbyAgICAgIHwgMHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSEggICAgICB8IDAwLCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgICB8IEsgICAgICAgfCAxLCAyLCAuLi4sIDExLCAwICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBLbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMHRoICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgS0sgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgICB8IGsgICAgICAgfCAyNCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBrbyAgICAgIHwgMjR0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwga2sgICAgICB8IDI0LCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgICB8IG0gICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbW0gICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgICB8IHMgICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc3MgICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgICB8IFMgICAgICAgfCAwLCAxLCAuLi4sIDkgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTUyAgICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1NTICAgICB8IDAwMCwgMDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTU1MgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3LyBaKSAgICAgICAgfCBYICAgICAgIHwgLTA4LCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFggICAgICB8IC0wODAwLCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWCAgICAgfCAtMDg6MDAsICswNTozMCwgWiAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFhYICAgIHwgLTA4MDAsICswNTMwLCBaLCArMTIzNDU2ICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWFggICB8IC0wODowMCwgKzA1OjMwLCBaLCArMTI6MzQ6NTYgICAgICB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgICB8IHggICAgICAgfCAtMDgsICswNTMwLCArMDAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eCAgICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4ICAgICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eHggICAgfCAtMDgwMCwgKzA1MzAsICswMDAwLCArMTIzNDU2ICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4eCAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCwgKzEyOjM0OjU2IHwgICAgICAgfFxuICogfCBUaW1lem9uZSAoR01UKSAgICAgICAgICAgICAgICAgIHwgTy4uLk9PTyB8IEdNVC04LCBHTVQrNTozMCwgR01UKzAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE9PT08gICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyICAgICB8XG4gKiB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSAgfCB6Li4uenp6IHwgR01ULTgsIEdNVCs1OjMwLCBHTVQrMCAgICAgICAgICAgIHwgNiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgenp6eiAgICB8IEdNVC0wODowMCwgR01UKzA1OjMwLCBHTVQrMDA6MDAgICB8IDIsNiAgIHxcbiAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgICB8IHQgICAgICAgfCA1MTI5Njk1MjAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0dCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxuICogfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgIHwgVCAgICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFRUICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDcgICB8XG4gKiB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICAgfCBQICAgICAgIHwgMDUvMjkvMTQ1MyAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFAgICAgICB8IE1heSAyOSwgMTQ1MyAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUCAgICAgfCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQICAgIHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgIHwgMiw3ICAgfFxuICogfCBMb25nIGxvY2FsaXplZCB0aW1lICAgICAgICAgICAgIHwgcCAgICAgICB8IDEyOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwICAgICAgfCAxMjowMDowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcHAgICAgIHwgMTI6MDA6MDAgQU0gR01UKzIgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHBwcCAgICB8IDEyOjAwOjAwIEFNIEdNVCswMjowMCAgICAgICAgICAgICB8IDIsNyAgIHxcbiAqIHwgQ29tYmluYXRpb24gb2YgZGF0ZSBhbmQgdGltZSAgICB8IFBwICAgICAgfCAwNS8yOS8xNDUzLCAxMjowMCBBTSAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUHBwICAgIHwgTWF5IDI5LCAxNDUzLCAxMjowMDowMCBBTSAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQcHBwICB8IE1heSAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUFBwcHBwfCBTdW5kYXksIE1heSAyOXRoLCAxNDUzIGF0IC4uLiAgICAgfCAyLDcgICB8XG4gKiBOb3RlczpcbiAqIDEuIFwiRm9ybWF0dGluZ1wiIHVuaXRzIChlLmcuIGZvcm1hdHRpbmcgcXVhcnRlcikgaW4gdGhlIGRlZmF1bHQgZW4tVVMgbG9jYWxlXG4gKiAgICBhcmUgdGhlIHNhbWUgYXMgXCJzdGFuZC1hbG9uZVwiIHVuaXRzLCBidXQgYXJlIGRpZmZlcmVudCBpbiBzb21lIGxhbmd1YWdlcy5cbiAqICAgIFwiRm9ybWF0dGluZ1wiIHVuaXRzIGFyZSBkZWNsaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIG9mIHRoZSBsYW5ndWFnZVxuICogICAgaW4gdGhlIGNvbnRleHQgb2YgYSBkYXRlLiBcIlN0YW5kLWFsb25lXCIgdW5pdHMgYXJlIGFsd2F5cyBub21pbmF0aXZlIHNpbmd1bGFyOlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTExMTCcsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWQnYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTU1NTScsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWR1J2BcbiAqXG4gKiAyLiBBbnkgc2VxdWVuY2Ugb2YgdGhlIGlkZW50aWNhbCBsZXR0ZXJzIGlzIGEgcGF0dGVybiwgdW5sZXNzIGl0IGlzIGVzY2FwZWQgYnlcbiAqICAgIHRoZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyAoc2VlIGJlbG93KS5cbiAqICAgIElmIHRoZSBzZXF1ZW5jZSBpcyBsb25nZXIgdGhhbiBsaXN0ZWQgaW4gdGFibGUgKGUuZy4gYEVFRUVFRUVFRUVFYClcbiAqICAgIHRoZSBvdXRwdXQgd2lsbCBiZSB0aGUgc2FtZSBhcyBkZWZhdWx0IHBhdHRlcm4gZm9yIHRoaXMgdW5pdCwgdXN1YWxseVxuICogICAgdGhlIGxvbmdlc3Qgb25lIChpbiBjYXNlIG9mIElTTyB3ZWVrZGF5cywgYEVFRUVgKS4gRGVmYXVsdCBwYXR0ZXJucyBmb3IgdW5pdHNcbiAqICAgIGFyZSBtYXJrZWQgd2l0aCBcIjJcIiBpbiB0aGUgbGFzdCBjb2x1bW4gb2YgdGhlIHRhYmxlLlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NJykgLy89PiAnTm92J2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTScpIC8vPT4gJ04nYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAzLiBTb21lIHBhdHRlcm5zIGNvdWxkIGJlIHVubGltaXRlZCBsZW5ndGggKHN1Y2ggYXMgYHl5eXl5eXl5YCkuXG4gKiAgICBUaGUgb3V0cHV0IHdpbGwgYmUgcGFkZGVkIHdpdGggemVyb3MgdG8gbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ3l5eXl5eXl5JykgLy89PiAnMDAwMDIwMTcnYFxuICpcbiAqIDQuIGBRUVFRUWAgYW5kIGBxcXFxcWAgY291bGQgYmUgbm90IHN0cmljdGx5IG51bWVyaWNhbCBpbiBzb21lIGxvY2FsZXMuXG4gKiAgICBUaGVzZSB0b2tlbnMgcmVwcmVzZW50IHRoZSBzaG9ydGVzdCBmb3JtIG9mIHRoZSBxdWFydGVyLlxuICpcbiAqIDUuIFRoZSBtYWluIGRpZmZlcmVuY2UgYmV0d2VlbiBgeWAgYW5kIGB1YCBwYXR0ZXJucyBhcmUgQi5DLiB5ZWFyczpcbiAqXG4gKiAgICB8IFllYXIgfCBgeWAgfCBgdWAgfFxuICogICAgfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAqICAgIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gKiAgICB8IEJDIDEgfCAgIDEgfCAgIDAgfFxuICogICAgfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAqXG4gKiAgICBBbHNvIGB5eWAgYWx3YXlzIHJldHVybnMgdGhlIGxhc3QgdHdvIGRpZ2l0cyBvZiBhIHllYXIsXG4gKiAgICB3aGlsZSBgdXVgIHBhZHMgc2luZ2xlIGRpZ2l0IHllYXJzIHRvIDIgY2hhcmFjdGVycyBhbmQgcmV0dXJucyBvdGhlciB5ZWFycyB1bmNoYW5nZWQ6XG4gKlxuICogICAgfCBZZWFyIHwgYHl5YCB8IGB1dWAgfFxuICogICAgfC0tLS0tLXwtLS0tLS18LS0tLS0tfFxuICogICAgfCAxICAgIHwgICAwMSB8ICAgMDEgfFxuICogICAgfCAxNCAgIHwgICAxNCB8ICAgMTQgfFxuICogICAgfCAzNzYgIHwgICA3NiB8ICAzNzYgfFxuICogICAgfCAxNDUzIHwgICA1MyB8IDE0NTMgfFxuICpcbiAqICAgIFRoZSBzYW1lIGRpZmZlcmVuY2UgaXMgdHJ1ZSBmb3IgbG9jYWwgYW5kIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyAoYFlgIGFuZCBgUmApLFxuICogICAgZXhjZXB0IGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJzIGFyZSBkZXBlbmRlbnQgb24gYG9wdGlvbnMud2Vla1N0YXJ0c09uYFxuICogICAgYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKGNvbXBhcmUgW2dldElTT1dlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL2dldElTT1dlZWtZZWFyfVxuICogICAgYW5kIFtnZXRXZWVrWWVhcl17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9nZXRXZWVrWWVhcn0pLlxuICpcbiAqIDYuIFNwZWNpZmljIG5vbi1sb2NhdGlvbiB0aW1lem9uZXMgYXJlIGN1cnJlbnRseSB1bmF2YWlsYWJsZSBpbiBgZGF0ZS1mbnNgLFxuICogICAgc28gcmlnaHQgbm93IHRoZXNlIHRva2VucyBmYWxsIGJhY2sgdG8gR01UIHRpbWV6b25lcy5cbiAqXG4gKiA3LiBUaGVzZSBwYXR0ZXJucyBhcmUgbm90IGluIHRoZSBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiAgICAtIGBpYDogSVNPIGRheSBvZiB3ZWVrXG4gKiAgICAtIGBJYDogSVNPIHdlZWsgb2YgeWVhclxuICogICAgLSBgUmA6IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKiAgICAtIGB0YDogc2Vjb25kcyB0aW1lc3RhbXBcbiAqICAgIC0gYFRgOiBtaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gKiAgICAtIGBvYDogb3JkaW5hbCBudW1iZXIgbW9kaWZpZXJcbiAqICAgIC0gYFBgOiBsb25nIGxvY2FsaXplZCBkYXRlXG4gKiAgICAtIGBwYDogbG9uZyBsb2NhbGl6ZWQgdGltZVxuICpcbiAqIDguIGBZWWAgYW5kIGBZWVlZYCB0b2tlbnMgcmVwcmVzZW50IHdlZWstbnVtYmVyaW5nIHllYXJzIGJ1dCB0aGV5IGFyZSBvZnRlbiBjb25mdXNlZCB3aXRoIHllYXJzLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICpcbiAqIDkuIGBEYCBhbmQgYEREYCB0b2tlbnMgcmVwcmVzZW50IGRheXMgb2YgdGhlIHllYXIgYnV0IHRoZXkgYXJlIG9mdGhlbiBjb25mdXNlZCB3aXRoIGRheXMgb2YgdGhlIG1vbnRoLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gVGhlIHNlY29uZCBhcmd1bWVudCBpcyBub3cgcmVxdWlyZWQgZm9yIHRoZSBzYWtlIG9mIGV4cGxpY2l0bmVzcy5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICogICBmb3JtYXQobmV3IERhdGUoMjAxNiwgMCwgMSkpXG4gKlxuICogICAvLyB2Mi4wLjAgb253YXJkXG4gKiAgIGZvcm1hdChuZXcgRGF0ZSgyMDE2LCAwLCAxKSwgXCJ5eXl5LU1NLWRkJ1QnSEg6bW06c3MuU1NTeHh4XCIpXG4gKiAgIGBgYFxuICpcbiAqIC0gTmV3IGZvcm1hdCBzdHJpbmcgQVBJIGZvciBgZm9ybWF0YCBmdW5jdGlvblxuICogICB3aGljaCBpcyBiYXNlZCBvbiBbVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1XShodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlKS5cbiAqICAgU2VlIFt0aGlzIHBvc3RdKGh0dHBzOi8vYmxvZy5kYXRlLWZucy5vcmcvcG9zdC91bmljb2RlLXRva2Vucy1pbi1kYXRlLWZucy12Mi1zcmVhdHlraTkxamcpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogLSBDaGFyYWN0ZXJzIGFyZSBub3cgZXNjYXBlZCB1c2luZyBzaW5nbGUgcXVvdGUgc3ltYm9scyAoYCdgKSBpbnN0ZWFkIG9mIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlPTFdIC0gdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyIHRva2VucyBgWVlgIGFuZCBgWVlZWWA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgdGhlIGRheSBvZiB5ZWFyIHRva2VucyBgRGAgYW5kIGBERGA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBsb2NhbGl6ZWAgcHJvcGVydHlcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXRMb25nYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMud2Vla1N0YXJ0c09uYCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgN1xuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCBmb3IgZm9ybWF0dGluZyB5ZWFyczsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGg7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTEgRmVicnVhcnkgMjAxNCBpbiBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQobmV3IERhdGUoMjAxNCwgMSwgMTEpLCAnTU0vZGQveXl5eScpXG4gKiAvLz0+ICcwMi8xMS8yMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMiBKdWx5IDIwMTQgaW4gRXNwZXJhbnRvOlxuICogaW1wb3J0IHsgZW9Mb2NhbGUgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIpLCBcImRvICdkZScgTU1NTSB5eXl5XCIsIHtcbiAqICAgbG9jYWxlOiBlb0xvY2FsZVxuICogfSlcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFc2NhcGUgc3RyaW5nIGJ5IHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzOlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyLCAxNSksIFwiaCAnbycnY2xvY2snXCIpXG4gKiAvLz0+IFwiMyBvJ2Nsb2NrXCJcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXQoZGlydHlEYXRlLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGZvcm1hdFN0ciA9IFN0cmluZyhkaXJ0eUZvcm1hdFN0cik7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlJDEgPSBvcHRpb25zLmxvY2FsZSB8fCBsb2NhbGU7XG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUkMS5vcHRpb25zICYmIGxvY2FsZSQxLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlciQxKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA6IHRvSW50ZWdlciQxKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAxIGFuZCA3IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoIShmaXJzdFdlZWtDb250YWluc0RhdGUgPj0gMSAmJiBmaXJzdFdlZWtDb250YWluc0RhdGUgPD0gNykpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZmlyc3RXZWVrQ29udGFpbnNEYXRlIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlJDEub3B0aW9ucyAmJiBsb2NhbGUkMS5vcHRpb25zLndlZWtTdGFydHNPbjtcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIkMShsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIkMShvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgaWYgKCFsb2NhbGUkMS5sb2NhbGl6ZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGxvY2FsaXplIHByb3BlcnR5Jyk7XG4gIH1cblxuICBpZiAoIWxvY2FsZSQxLmZvcm1hdExvbmcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5Jyk7XG4gIH1cblxuICB2YXIgb3JpZ2luYWxEYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG5cbiAgaWYgKCFpc1ZhbGlkKG9yaWdpbmFsRGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIH0gLy8gQ29udmVydCB0aGUgZGF0ZSBpbiBzeXN0ZW0gdGltZXpvbmUgdG8gdGhlIHNhbWUgZGF0ZSBpbiBVVEMrMDA6MDAgdGltZXpvbmUuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gVVRDIGZ1bmN0aW9ucyB3aWxsIGJlIGltcGxlbWVudGVkLCBsb2NhbGVzIHdpbGwgYmUgY29tcGF0aWJsZSB3aXRoIHRoZW0uXG4gIC8vIFNlZSBhbiBpc3N1ZSBhYm91dCBVVEMgZnVuY3Rpb25zOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5cbiAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhvcmlnaW5hbERhdGUpO1xuICB2YXIgdXRjRGF0ZSA9IHN1Yk1pbGxpc2Vjb25kcyhvcmlnaW5hbERhdGUsIHRpbWV6b25lT2Zmc2V0KTtcbiAgdmFyIGZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiBmaXJzdFdlZWtDb250YWluc0RhdGUsXG4gICAgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24sXG4gICAgbG9jYWxlOiBsb2NhbGUkMSxcbiAgICBfb3JpZ2luYWxEYXRlOiBvcmlnaW5hbERhdGVcbiAgfTtcbiAgdmFyIHJlc3VsdCA9IGZvcm1hdFN0ci5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCkubWFwKGZ1bmN0aW9uIChzdWJzdHJpbmcpIHtcbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09ICdwJyB8fCBmaXJzdENoYXJhY3RlciA9PT0gJ1AnKSB7XG4gICAgICB2YXIgbG9uZ0Zvcm1hdHRlciA9IGxvbmdGb3JtYXR0ZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcbiAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlJDEuZm9ybWF0TG9uZywgZm9ybWF0dGVyT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnN0cmluZztcbiAgfSkuam9pbignJykubWF0Y2goZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCkubWFwKGZ1bmN0aW9uIChzdWJzdHJpbmcpIHtcbiAgICAvLyBSZXBsYWNlIHR3byBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyB3aXRoIG9uZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyXG4gICAgaWYgKHN1YnN0cmluZyA9PT0gXCInJ1wiKSB7XG4gICAgICByZXR1cm4gXCInXCI7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gc3Vic3RyaW5nWzBdO1xuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSBcIidcIikge1xuICAgICAgcmV0dXJuIGNsZWFuRXNjYXBlZFN0cmluZyhzdWJzdHJpbmcpO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJzJDFbZmlyc3RDaGFyYWN0ZXJdO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VucyAmJiBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4oc3Vic3RyaW5nKSkge1xuICAgICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHN1YnN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4oc3Vic3RyaW5nKSkge1xuICAgICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHN1YnN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JtYXR0ZXIodXRjRGF0ZSwgc3Vic3RyaW5nLCBsb2NhbGUkMS5sb2NhbGl6ZSwgZm9ybWF0dGVyT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyLm1hdGNoKHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Zvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlciBgJyArIGZpcnN0Q2hhcmFjdGVyICsgJ2AnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic3RyaW5nO1xuICB9KS5qb2luKCcnKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xlYW5Fc2NhcGVkU3RyaW5nKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5tYXRjaChlc2NhcGVkU3RyaW5nUmVnRXhwKVsxXS5yZXBsYWNlKGRvdWJsZVF1b3RlUmVnRXhwLCBcIidcIik7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiQxKHRhcmdldCwgZGlydHlPYmplY3QpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXNzaWduIHJlcXVpcmVzIHRoYXQgaW5wdXQgcGFyYW1ldGVyIG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgZGlydHlPYmplY3QgPSBkaXJ0eU9iamVjdCB8fCB7fTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBkaXJ0eU9iamVjdCkge1xuICAgIGlmIChkaXJ0eU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBkaXJ0eU9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAbmFtZSBpc0FmdGVyXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBmaXJzdCBkYXRlIGFmdGVyIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYWZ0ZXIgdGhlIG90aGVyIG9uZSB0byByZXR1cm4gdHJ1ZVxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZVRvQ29tcGFyZSAtIHRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBmaXJzdCBkYXRlIGlzIGFmdGVyIHRoZSBzZWNvbmQgZGF0ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJcyAxMCBKdWx5IDE5ODkgYWZ0ZXIgMTEgRmVicnVhcnkgMTk4Nz9cbiAqIHZhciByZXN1bHQgPSBpc0FmdGVyKG5ldyBEYXRlKDE5ODksIDYsIDEwKSwgbmV3IERhdGUoMTk4NywgMSwgMTEpKVxuICogLy89PiB0cnVlXG4gKi9cblxuZnVuY3Rpb24gaXNBZnRlcihkaXJ0eURhdGUsIGRpcnR5RGF0ZVRvQ29tcGFyZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXRlVG9Db21wYXJlID0gdG9EYXRlKGRpcnR5RGF0ZVRvQ29tcGFyZSk7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSA+IGRhdGVUb0NvbXBhcmUuZ2V0VGltZSgpO1xufVxuXG4vKipcbiAqIEBuYW1lIGlzQmVmb3JlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0aGF0IHNob3VsZCBiZSBiZWZvcmUgdGhlIG90aGVyIG9uZSB0byByZXR1cm4gdHJ1ZVxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZVRvQ29tcGFyZSAtIHRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMTAgSnVseSAxOTg5IGJlZm9yZSAxMSBGZWJydWFyeSAxOTg3P1xuICogdmFyIHJlc3VsdCA9IGlzQmVmb3JlKG5ldyBEYXRlKDE5ODksIDYsIDEwKSwgbmV3IERhdGUoMTk4NywgMSwgMTEpKVxuICogLy89PiBmYWxzZVxuICovXG5cbmZ1bmN0aW9uIGlzQmVmb3JlKGRpcnR5RGF0ZSwgZGlydHlEYXRlVG9Db21wYXJlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRhdGVUb0NvbXBhcmUgPSB0b0RhdGUoZGlydHlEYXRlVG9Db21wYXJlKTtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIDwgZGF0ZVRvQ29tcGFyZS5nZXRUaW1lKCk7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc2V0VVRDRGF5KGRpcnR5RGF0ZSwgZGlydHlEYXksIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlciQxKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlciQxKG9wdGlvbnMud2Vla1N0YXJ0c09uKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gdG9JbnRlZ2VyJDEoZGlydHlEYXkpO1xuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciByZW1haW5kZXIgPSBkYXkgJSA3O1xuICB2YXIgZGF5SW5kZXggPSAocmVtYWluZGVyICsgNykgJSA3O1xuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzZXRVVENJU09EYXkoZGlydHlEYXRlLCBkaXJ0eURheSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXkgPSB0b0ludGVnZXIkMShkaXJ0eURheSk7XG5cbiAgaWYgKGRheSAlIDcgPT09IDApIHtcbiAgICBkYXkgPSBkYXkgLSA3O1xuICB9XG5cbiAgdmFyIHdlZWtTdGFydHNPbiA9IDE7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBjdXJyZW50RGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIHJlbWFpbmRlciA9IGRheSAlIDc7XG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XG4gIHZhciBkaWZmID0gKGRheUluZGV4IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gY3VycmVudERheTtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHNldFVUQ0lTT1dlZWsoZGlydHlEYXRlLCBkaXJ0eUlTT1dlZWspIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgaXNvV2VlayA9IHRvSW50ZWdlciQxKGRpcnR5SVNPV2Vlayk7XG4gIHZhciBkaWZmID0gZ2V0VVRDSVNPV2VlayhkYXRlKSAtIGlzb1dlZWs7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYgKiA3KTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc2V0VVRDV2VlayhkaXJ0eURhdGUsIGRpcnR5V2Vlaywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciB3ZWVrID0gdG9JbnRlZ2VyJDEoZGlydHlXZWVrKTtcbiAgdmFyIGRpZmYgPSBnZXRVVENXZWVrKGRhdGUsIG9wdGlvbnMpIC0gd2VlaztcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZiAqIDcpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMDtcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDEgPSA2MDAwMDtcbnZhciBNSUxMSVNFQ09ORFNfSU5fU0VDT05EID0gMTAwMDtcbnZhciBudW1lcmljUGF0dGVybnMgPSB7XG4gIG1vbnRoOiAvXigxWzAtMl18MD9cXGQpLyxcbiAgLy8gMCB0byAxMlxuICBkYXRlOiAvXigzWzAtMV18WzAtMl0/XFxkKS8sXG4gIC8vIDAgdG8gMzFcbiAgZGF5T2ZZZWFyOiAvXigzNlswLTZdfDNbMC01XVxcZHxbMC0yXT9cXGQ/XFxkKS8sXG4gIC8vIDAgdG8gMzY2XG4gIHdlZWs6IC9eKDVbMC0zXXxbMC00XT9cXGQpLyxcbiAgLy8gMCB0byA1M1xuICBob3VyMjNoOiAvXigyWzAtM118WzAtMV0/XFxkKS8sXG4gIC8vIDAgdG8gMjNcbiAgaG91cjI0aDogL14oMlswLTRdfFswLTFdP1xcZCkvLFxuICAvLyAwIHRvIDI0XG4gIGhvdXIxMWg6IC9eKDFbMC0xXXwwP1xcZCkvLFxuICAvLyAwIHRvIDExXG4gIGhvdXIxMmg6IC9eKDFbMC0yXXwwP1xcZCkvLFxuICAvLyAwIHRvIDEyXG4gIG1pbnV0ZTogL15bMC01XT9cXGQvLFxuICAvLyAwIHRvIDU5XG4gIHNlY29uZDogL15bMC01XT9cXGQvLFxuICAvLyAwIHRvIDU5XG4gIHNpbmdsZURpZ2l0OiAvXlxcZC8sXG4gIC8vIDAgdG8gOVxuICB0d29EaWdpdHM6IC9eXFxkezEsMn0vLFxuICAvLyAwIHRvIDk5XG4gIHRocmVlRGlnaXRzOiAvXlxcZHsxLDN9LyxcbiAgLy8gMCB0byA5OTlcbiAgZm91ckRpZ2l0czogL15cXGR7MSw0fS8sXG4gIC8vIDAgdG8gOTk5OVxuICBhbnlEaWdpdHNTaWduZWQ6IC9eLT9cXGQrLyxcbiAgc2luZ2xlRGlnaXRTaWduZWQ6IC9eLT9cXGQvLFxuICAvLyAwIHRvIDksIC0wIHRvIC05XG4gIHR3b0RpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDJ9LyxcbiAgLy8gMCB0byA5OSwgLTAgdG8gLTk5XG4gIHRocmVlRGlnaXRzU2lnbmVkOiAvXi0/XFxkezEsM30vLFxuICAvLyAwIHRvIDk5OSwgLTAgdG8gLTk5OVxuICBmb3VyRGlnaXRzU2lnbmVkOiAvXi0/XFxkezEsNH0vIC8vIDAgdG8gOTk5OSwgLTAgdG8gLTk5OTlcblxufTtcbnZhciB0aW1lem9uZVBhdHRlcm5zID0ge1xuICBiYXNpY09wdGlvbmFsTWludXRlczogL14oWystXSkoXFxkezJ9KShcXGR7Mn0pP3xaLyxcbiAgYmFzaWM6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KXxaLyxcbiAgYmFzaWNPcHRpb25hbFNlY29uZHM6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KSgoXFxkezJ9KSk/fFovLFxuICBleHRlbmRlZDogL14oWystXSkoXFxkezJ9KTooXFxkezJ9KXxaLyxcbiAgZXh0ZW5kZWRPcHRpb25hbFNlY29uZHM6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSkoOihcXGR7Mn0pKT98Wi9cbn07XG5cbmZ1bmN0aW9uIHBhcnNlTnVtZXJpY1BhdHRlcm4ocGF0dGVybiwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKSB7XG4gIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChwYXR0ZXJuKTtcblxuICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwYXJzZUludChtYXRjaFJlc3VsdFswXSwgMTApO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZUNhbGxiYWNrID8gdmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZSxcbiAgICByZXN0OiBzdHJpbmcuc2xpY2UobWF0Y2hSZXN1bHRbMF0ubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWV6b25lUGF0dGVybihwYXR0ZXJuLCBzdHJpbmcpIHtcbiAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKHBhdHRlcm4pO1xuXG4gIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBJbnB1dCBpcyAnWidcblxuXG4gIGlmIChtYXRjaFJlc3VsdFswXSA9PT0gJ1onKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgcmVzdDogc3RyaW5nLnNsaWNlKDEpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBzaWduID0gbWF0Y2hSZXN1bHRbMV0gPT09ICcrJyA/IDEgOiAtMTtcbiAgdmFyIGhvdXJzID0gbWF0Y2hSZXN1bHRbMl0gPyBwYXJzZUludChtYXRjaFJlc3VsdFsyXSwgMTApIDogMDtcbiAgdmFyIG1pbnV0ZXMgPSBtYXRjaFJlc3VsdFszXSA/IHBhcnNlSW50KG1hdGNoUmVzdWx0WzNdLCAxMCkgOiAwO1xuICB2YXIgc2Vjb25kcyA9IG1hdGNoUmVzdWx0WzVdID8gcGFyc2VJbnQobWF0Y2hSZXN1bHRbNV0sIDEwKSA6IDA7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHNpZ24gKiAoaG91cnMgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDEgKyBzZWNvbmRzICogTUlMTElTRUNPTkRTX0lOX1NFQ09ORCksXG4gICAgcmVzdDogc3RyaW5nLnNsaWNlKG1hdGNoUmVzdWx0WzBdLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBbnlEaWdpdHNTaWduZWQoc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKSB7XG4gIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5hbnlEaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTkRpZ2l0cyhuLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnNpbmdsZURpZ2l0LCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnR3b0RpZ2l0cywgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50aHJlZURpZ2l0cywgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5mb3VyRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG5ldyBSZWdFeHAoJ15cXFxcZHsxLCcgKyBuICsgJ30nKSwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5EaWdpdHNTaWduZWQobiwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKSB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5zaW5nbGVEaWdpdFNpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50d29EaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudGhyZWVEaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuZm91ckRpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihuZXcgUmVnRXhwKCdeLT9cXFxcZHsxLCcgKyBuICsgJ30nKSwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXlQZXJpb2RFbnVtVG9Ib3VycyhlbnVtVmFsdWUpIHtcbiAgc3dpdGNoIChlbnVtVmFsdWUpIHtcbiAgICBjYXNlICdtb3JuaW5nJzpcbiAgICAgIHJldHVybiA0O1xuXG4gICAgY2FzZSAnZXZlbmluZyc6XG4gICAgICByZXR1cm4gMTc7XG5cbiAgICBjYXNlICdwbSc6XG4gICAgY2FzZSAnbm9vbic6XG4gICAgY2FzZSAnYWZ0ZXJub29uJzpcbiAgICAgIHJldHVybiAxMjtcblxuICAgIGNhc2UgJ2FtJzpcbiAgICBjYXNlICdtaWRuaWdodCc6XG4gICAgY2FzZSAnbmlnaHQnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUd29EaWdpdFllYXIodHdvRGlnaXRZZWFyLCBjdXJyZW50WWVhcikge1xuICB2YXIgaXNDb21tb25FcmEgPSBjdXJyZW50WWVhciA+IDA7IC8vIEFic29sdXRlIG51bWJlciBvZiB0aGUgY3VycmVudCB5ZWFyOlxuICAvLyAxIC0+IDEgQUNcbiAgLy8gMCAtPiAxIEJDXG4gIC8vIC0xIC0+IDIgQkNcblxuICB2YXIgYWJzQ3VycmVudFllYXIgPSBpc0NvbW1vbkVyYSA/IGN1cnJlbnRZZWFyIDogMSAtIGN1cnJlbnRZZWFyO1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmIChhYnNDdXJyZW50WWVhciA8PSA1MCkge1xuICAgIHJlc3VsdCA9IHR3b0RpZ2l0WWVhciB8fCAxMDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJhbmdlRW5kID0gYWJzQ3VycmVudFllYXIgKyA1MDtcbiAgICB2YXIgcmFuZ2VFbmRDZW50dXJ5ID0gTWF0aC5mbG9vcihyYW5nZUVuZCAvIDEwMCkgKiAxMDA7XG4gICAgdmFyIGlzUHJldmlvdXNDZW50dXJ5ID0gdHdvRGlnaXRZZWFyID49IHJhbmdlRW5kICUgMTAwO1xuICAgIHJlc3VsdCA9IHR3b0RpZ2l0WWVhciArIHJhbmdlRW5kQ2VudHVyeSAtIChpc1ByZXZpb3VzQ2VudHVyeSA/IDEwMCA6IDApO1xuICB9XG5cbiAgcmV0dXJuIGlzQ29tbW9uRXJhID8gcmVzdWx0IDogMSAtIHJlc3VsdDtcbn1cblxudmFyIERBWVNfSU5fTU9OVEggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG52YXIgREFZU19JTl9NT05USF9MRUFQX1lFQVIgPSBbMzEsIDI5LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07IC8vIFVzZXIgZm9yIHZhbGlkYXRpb25cblxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4KHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMDtcbn1cbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8IE1pbGxpc2Vjb25kcyBpbiBkYXkgICAgICAgICAgICB8XG4gKiB8ICBiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICB8ICBCICB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICB8XG4gKiB8ICBjICB8IFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrICB8ICBDKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBlICB8IExvY2FsIGRheSBvZiB3ZWVrICAgICAgICAgICAgICB8ICBFICB8IERheSBvZiB3ZWVrICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBmICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBGKiB8IERheSBvZiB3ZWVrIGluIG1vbnRoICAgICAgICAgICB8XG4gKiB8ICBnKiB8IE1vZGlmaWVkIEp1bGlhbiBkYXkgICAgICAgICAgICB8ICBHICB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBpISB8IElTTyBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgICB8ICBJISB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICB8XG4gKiB8ICBqKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8ICBKKiB8IExvY2FsaXplZCBob3VyIHcvbyBkYXkgcGVyaW9kICB8XG4gKiB8ICBrICB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICB8ICBLICB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBsKiB8IChkZXByZWNhdGVkKSAgICAgICAgICAgICAgICAgICB8ICBMICB8IFN0YW5kLWFsb25lIG1vbnRoICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBuICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBOICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBvISB8IE9yZGluYWwgbnVtYmVyIG1vZGlmaWVyICAgICAgICB8ICBPKiB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICB8XG4gKiB8ICBwICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBQICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBxICB8IFN0YW5kLWFsb25lIHF1YXJ0ZXIgICAgICAgICAgICB8ICBRICB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICByKiB8IFJlbGF0ZWQgR3JlZ29yaWFuIHllYXIgICAgICAgICB8ICBSISB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB0ISB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICB8ICBUISB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICB8XG4gKiB8ICB1ICB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICB8ICBVKiB8IEN5Y2xpYyB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICB2KiB8IFRpbWV6b25lIChnZW5lcmljIG5vbi1sb2NhdC4pICB8ICBWKiB8IFRpbWV6b25lIChsb2NhdGlvbikgICAgICAgICAgICB8XG4gKiB8ICB3ICB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICB8ICBXKiB8IFdlZWsgb2YgbW9udGggICAgICAgICAgICAgICAgICB8XG4gKiB8ICB4ICB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICB8ICBYICB8IFRpbWV6b25lIChJU08tODYwMSkgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICB8XG4gKiB8ICB6KiB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSB8ICBaKiB8IFRpbWV6b25lIChhbGlhc2VzKSAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICEgYXJlIG5vbi1zdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IGRhdGUtZm5zOlxuICogLSBgb2AgbW9kaWZpZXMgdGhlIHByZXZpb3VzIHRva2VuIHRvIHR1cm4gaXQgaW50byBhbiBvcmRpbmFsIChzZWUgYHBhcnNlYCBkb2NzKVxuICogLSBgaWAgaXMgSVNPIGRheSBvZiB3ZWVrLiBGb3IgYGlgIGFuZCBgaWlgIGlzIHJldHVybnMgbnVtZXJpYyBJU08gd2VlayBkYXlzLFxuICogICBpLmUuIDcgZm9yIFN1bmRheSwgMSBmb3IgTW9uZGF5LCBldGMuXG4gKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXG4gKiAtIGBSYCBpcyBJU08gd2Vlay1udW1iZXJpbmcgeWVhciwgYXMgb3Bwb3NlZCB0byBgWWAgd2hpY2ggaXMgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAqICAgYFJgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgSWAgYW5kIGBpYFxuICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXG4gKiAgIGBZYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdgIGFuZCBgZWBcbiAqICAgZm9yIHdlZWstbnVtYmVyaW5nIGRhdGUgc3BlY2lmaWMgdG8gdGhlIGxvY2FsZS5cbiAqL1xuXG5cbnZhciBwYXJzZXJzID0ge1xuICAvLyBFcmFcbiAgRzoge1xuICAgIHByaW9yaXR5OiAxNDAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gQUQsIEJDXG4gICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgIGNhc2UgJ0dHRyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEEsIEJcblxuICAgICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93J1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdFxuXG4gICAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIGZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGZsYWdzLmVyYSA9IHZhbHVlO1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih2YWx1ZSwgMCwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnUicsICd1JywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFllYXJcbiAgeToge1xuICAgIC8vIEZyb20gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zMS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcbiAgICAvLyB8IFllYXIgICAgIHwgICAgIHkgfCB5eSB8ICAgeXl5IHwgIHl5eXkgfCB5eXl5eSB8XG4gICAgLy8gfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxuICAgIC8vIHwgQUQgMSAgICAgfCAgICAgMSB8IDAxIHwgICAwMDEgfCAgMDAwMSB8IDAwMDAxIHxcbiAgICAvLyB8IEFEIDEyICAgIHwgICAgMTIgfCAxMiB8ICAgMDEyIHwgIDAwMTIgfCAwMDAxMiB8XG4gICAgLy8gfCBBRCAxMjMgICB8ICAgMTIzIHwgMjMgfCAgIDEyMyB8ICAwMTIzIHwgMDAxMjMgfFxuICAgIC8vIHwgQUQgMTIzNCAgfCAgMTIzNCB8IDM0IHwgIDEyMzQgfCAgMTIzNCB8IDAxMjM0IHxcbiAgICAvLyB8IEFEIDEyMzQ1IHwgMTIzNDUgfCA0NSB8IDEyMzQ1IHwgMTIzNDUgfCAxMjM0NSB8XG4gICAgcHJpb3JpdHk6IDEzMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgaXNUd29EaWdpdFllYXI6IHRva2VuID09PSAneXknXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHMoNCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgICAgICBjYXNlICd5byc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAneWVhcicsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlLmlzVHdvRGlnaXRZZWFyIHx8IHZhbHVlLnllYXIgPiAwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuXG4gICAgICBpZiAodmFsdWUuaXNUd29EaWdpdFllYXIpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRUd29EaWdpdFllYXIgPSBub3JtYWxpemVUd29EaWdpdFllYXIodmFsdWUueWVhciwgY3VycmVudFllYXIpO1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKG5vcm1hbGl6ZWRUd29EaWdpdFllYXIsIDAsIDEpO1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHllYXIgPSAhKCdlcmEnIGluIGZsYWdzKSB8fCBmbGFncy5lcmEgPT09IDEgPyB2YWx1ZS55ZWFyIDogMSAtIHZhbHVlLnllYXI7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICd1JywgJ3cnLCAnSScsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IHtcbiAgICBwcmlvcml0eTogMTMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBpc1R3b0RpZ2l0WWVhcjogdG9rZW4gPT09ICdZWSdcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyg0LCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgICAgIGNhc2UgJ1lvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd5ZWFyJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaXNUd29EaWdpdFllYXIgfHwgdmFsdWUueWVhciA+IDA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IGdldFVUQ1dlZWtZZWFyKGRhdGUsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAodmFsdWUuaXNUd29EaWdpdFllYXIpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRUd29EaWdpdFllYXIgPSBub3JtYWxpemVUd29EaWdpdFllYXIodmFsdWUueWVhciwgY3VycmVudFllYXIpO1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKG5vcm1hbGl6ZWRUd29EaWdpdFllYXIsIDAsIG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0T2ZVVENXZWVrKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeWVhciA9ICEoJ2VyYScgaW4gZmxhZ3MpIHx8IGZsYWdzLmVyYSA9PT0gMSA/IHZhbHVlLnllYXIgOiAxIC0gdmFsdWUueWVhcjtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBzdGFydE9mVVRDV2VlayhkYXRlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1InLCAndScsICdRJywgJ3EnLCAnTScsICdMJywgJ0knLCAnZCcsICdEJywgJ2knLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgUjoge1xuICAgIHByaW9yaXR5OiAxMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBpZiAodG9rZW4gPT09ICdSJykge1xuICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzU2lnbmVkKDQsIHN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQodG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoX2RhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgZmlyc3RXZWVrT2ZZZWFyID0gbmV3IERhdGUoMCk7XG4gICAgICBmaXJzdFdlZWtPZlllYXIuc2V0VVRDRnVsbFllYXIodmFsdWUsIDAsIDQpO1xuICAgICAgZmlyc3RXZWVrT2ZZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZVVENJU09XZWVrKGZpcnN0V2Vla09mWWVhcik7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnRycsICd5JywgJ1knLCAndScsICdRJywgJ3EnLCAnTScsICdMJywgJ3cnLCAnZCcsICdEJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBFeHRlbmRlZCB5ZWFyXG4gIHU6IHtcbiAgICBwcmlvcml0eTogMTMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgaWYgKHRva2VuID09PSAndScpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCg0LCBzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VORGlnaXRzU2lnbmVkKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydHJywgJ3knLCAnWScsICdSJywgJ3cnLCAnSScsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBRdWFydGVyXG4gIFE6IHtcbiAgICBwcmlvcml0eTogMTIwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgIGNhc2UgJ1FRJzpcbiAgICAgICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgICBjYXNlICdRbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgICBjYXNlICdRUVEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICAgIGNhc2UgJ1FRUVFRJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICAgIGNhc2UgJ1FRUVEnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKCh2YWx1ZSAtIDEpICogMywgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnTScsICdMJywgJ3cnLCAnSScsICdkJywgJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgcXVhcnRlclxuICBxOiB7XG4gICAgcHJpb3JpdHk6IDEyMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICBjYXNlICdxcSc6XG4gICAgICAgICAgLy8gMDEsIDAyLCAwMywgMDRcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG5cbiAgICAgICAgY2FzZSAncW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3F1YXJ0ZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG5cbiAgICAgICAgY2FzZSAncXFxJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcblxuICAgICAgICBjYXNlICdxcXFxcSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cblxuICAgICAgICBjYXNlICdxcXFxJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNb250aCgodmFsdWUgLSAxKSAqIDMsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdRJywgJ00nLCAnTCcsICd3JywgJ0knLCAnZCcsICdEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIE1vbnRoXG4gIE06IHtcbiAgICBwcmlvcml0eTogMTEwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLSAxO1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5tb250aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgICAgLy8gMDEsIDAyLCAuLi4sIDEyXG5cbiAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHMoMiwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuXG4gICAgICAgIGNhc2UgJ01vJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdtb250aCcsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuXG4gICAgICAgIGNhc2UgJ01NTSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKLCBGLCAuLi4sIERcblxuICAgICAgICBjYXNlICdNTU1NTSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG5cbiAgICAgICAgY2FzZSAnTU1NTSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKHZhbHVlLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdRJywgJ0wnLCAndycsICdJJywgJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcbiAgTDoge1xuICAgIHByaW9yaXR5OiAxMTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIDE7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLm1vbnRoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcblxuICAgICAgICBjYXNlICdMTCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cygyLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgICAgY2FzZSAnTG8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ21vbnRoJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgICAgY2FzZSAnTExMJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICAgIGNhc2UgJ0xMTExMJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgICBjYXNlICdMTExMJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgodmFsdWUsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdxJywgJ1EnLCAnTScsICd3JywgJ0knLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBMb2NhbCB3ZWVrIG9mIHllYXJcbiAgdzoge1xuICAgIHByaW9yaXR5OiAxMDAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLndlZWssIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnd28nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNTM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ1dlZWsoc2V0VVRDV2VlayhkYXRlLCB2YWx1ZSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnUicsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAnSScsICdkJywgJ0QnLCAnaScsICd0JywgJ1QnXVxuICB9LFxuICAvLyBJU08gd2VlayBvZiB5ZWFyXG4gIEk6IHtcbiAgICBwcmlvcml0eTogMTAwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy53ZWVrLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ0lvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3ZWVrJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDUzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZVVENJU09XZWVrKHNldFVUQ0lTT1dlZWsoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1knLCAndScsICdxJywgJ1EnLCAnTScsICdMJywgJ3cnLCAnZCcsICdEJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmRhdGUsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnZG8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2RhdGUnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgIHZhciBpc0xlYXBZZWFyID0gaXNMZWFwWWVhckluZGV4KHllYXIpO1xuICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuXG4gICAgICBpZiAoaXNMZWFwWWVhcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUlttb250aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSBEQVlTX0lOX01PTlRIW21vbnRoXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUodmFsdWUpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdxJywgJ1EnLCAndycsICdJJywgJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gRGF5IG9mIHllYXJcbiAgRDoge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgY2FzZSAnREQnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5kYXlPZlllYXIsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnRG8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2RhdGUnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgIHZhciBpc0xlYXBZZWFyID0gaXNMZWFwWWVhckluZGV4KHllYXIpO1xuXG4gICAgICBpZiAoaXNMZWFwWWVhcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAzNjY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAzNjU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNb250aCgwLCB2YWx1ZSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnUScsICdNJywgJ0wnLCAndycsICdJJywgJ2QnLCAnRScsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBEYXkgb2Ygd2Vla1xuICBFOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIFR1ZVxuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgY2FzZSAnRUUnOlxuICAgICAgICBjYXNlICdFRUUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRcblxuICAgICAgICBjYXNlICdFRUVFRSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdVxuXG4gICAgICAgIGNhc2UgJ0VFRUVFRSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgICBjYXNlICdFRUVFJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSBzZXRVVENEYXkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTG9jYWwgZGF5IG9mIHdlZWtcbiAgZToge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgd2hvbGVXZWVrRGF5cyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gMSkgLyA3KSAqIDc7XG4gICAgICAgIHJldHVybiAodmFsdWUgKyBvcHRpb25zLndlZWtTdGFydHNPbiArIDYpICUgNyArIHdob2xlV2Vla0RheXM7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDNcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ2VlJzpcbiAgICAgICAgICAvLyAwM1xuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAzcmRcblxuICAgICAgICBjYXNlICdlbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF5JyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlXG5cbiAgICAgICAgY2FzZSAnZWVlJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUXG5cbiAgICAgICAgY2FzZSAnZWVlZWUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVcblxuICAgICAgICBjYXNlICdlZWVlZWUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVzZGF5XG5cbiAgICAgICAgY2FzZSAnZWVlZSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gc2V0VVRDRGF5KGRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1InLCAndScsICdxJywgJ1EnLCAnTScsICdMJywgJ0knLCAnZCcsICdEJywgJ0UnLCAnaScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrXG4gIGM6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdob2xlV2Vla0RheXMgPSBNYXRoLmZsb29yKCh2YWx1ZSAtIDEpIC8gNykgKiA3O1xuICAgICAgICByZXR1cm4gKHZhbHVlICsgb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA2KSAlIDcgKyB3aG9sZVdlZWtEYXlzO1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAzXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBjYXNlICdjYyc6XG4gICAgICAgICAgLy8gMDNcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgICAgLy8gM3JkXG5cbiAgICAgICAgY2FzZSAnY28nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2RheScsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZVxuXG4gICAgICAgIGNhc2UgJ2NjYyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVFxuXG4gICAgICAgIGNhc2UgJ2NjY2NjJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1XG5cbiAgICAgICAgY2FzZSAnY2NjY2NjJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlc2RheVxuXG4gICAgICAgIGNhc2UgJ2NjY2MnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdSJywgJ3UnLCAncScsICdRJywgJ00nLCAnTCcsICdJJywgJ2QnLCAnRCcsICdFJywgJ2knLCAnZScsICd0JywgJ1QnXVxuICB9LFxuICAvLyBJU08gZGF5IG9mIHdlZWtcbiAgaToge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDJcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ2lpJzpcbiAgICAgICAgICAvLyAwMlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgICAvLyAybmRcblxuICAgICAgICBjYXNlICdpbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVcblxuICAgICAgICBjYXNlICdpaWknOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRcblxuICAgICAgICBjYXNlICdpaWlpaSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVcblxuICAgICAgICBjYXNlICdpaWlpaWknOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgICBjYXNlICdpaWlpJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gc2V0VVRDSVNPRGF5KGRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1knLCAndScsICdxJywgJ1EnLCAnTScsICdMJywgJ3cnLCAnZCcsICdEJywgJ0UnLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGE6IHtcbiAgICBwcmlvcml0eTogODAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNhc2UgJ2FhJzpcbiAgICAgICAgY2FzZSAnYWFhJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdhYWFhYSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ2FhYWEnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGRheVBlcmlvZEVudW1Ub0hvdXJzKHZhbHVlKSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydiJywgJ0InLCAnSCcsICdLJywgJ2snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gQU0sIFBNLCBtaWRuaWdodFxuICBiOiB7XG4gICAgcHJpb3JpdHk6IDgwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2InOlxuICAgICAgICBjYXNlICdiYic6XG4gICAgICAgIGNhc2UgJ2JiYic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnYmJiYmInOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdiYmJiJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycyhkYXlQZXJpb2RFbnVtVG9Ib3Vycyh2YWx1ZSksIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdCJywgJ0gnLCAnSycsICdrJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIGluIHRoZSBtb3JuaW5nLCBpbiB0aGUgYWZ0ZXJub29uLCBpbiB0aGUgZXZlbmluZywgYXQgbmlnaHRcbiAgQjoge1xuICAgIHByaW9yaXR5OiA4MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgY2FzZSAnQkInOlxuICAgICAgICBjYXNlICdCQkInOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ0JCQkJCJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnQkJCQic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoZGF5UGVyaW9kRW51bVRvSG91cnModmFsdWUpLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2EnLCAnYicsICd0JywgJ1QnXVxuICB9LFxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiB7XG4gICAgcHJpb3JpdHk6IDcwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMTJoLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ2hvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDEyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBpc1BNID0gZGF0ZS5nZXRVVENIb3VycygpID49IDEyO1xuXG4gICAgICBpZiAoaXNQTSAmJiB2YWx1ZSA8IDEyKSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUgKyAxMiwgMCwgMCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc1BNICYmIHZhbHVlID09PSAxMikge1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ0gnLCAnSycsICdrJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEg6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIyM2gsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnSG8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMjM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ2InLCAnaCcsICdLJywgJ2snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSG91ciBbMC0xMV1cbiAgSzoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdLJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuaG91cjExaCwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdLbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnaG91cidcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgaXNQTSA9IGRhdGUuZ2V0VVRDSG91cnMoKSA+PSAxMjtcblxuICAgICAgaWYgKGlzUE0gJiYgdmFsdWUgPCAxMikge1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlICsgMTIsIDAsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2EnLCAnYicsICdoJywgJ0gnLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBIb3VyIFsxLTI0XVxuICBrOiB7XG4gICAgcHJpb3JpdHk6IDcwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMjRoLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ2tvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDI0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBob3VycyA9IHZhbHVlIDw9IDI0ID8gdmFsdWUgJSAyNCA6IHZhbHVlO1xuICAgICAgZGF0ZS5zZXRVVENIb3Vycyhob3VycywgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ2InLCAnaCcsICdIJywgJ0snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IHtcbiAgICBwcmlvcml0eTogNjAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLm1pbnV0ZSwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdtbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnbWludXRlJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDU5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTWludXRlcyh2YWx1ZSwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnXVxuICB9LFxuICAvLyBTZWNvbmRcbiAgczoge1xuICAgIHByaW9yaXR5OiA1MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuc2Vjb25kLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3NvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdzZWNvbmQnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNTk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENTZWNvbmRzKHZhbHVlLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiB7XG4gICAgcHJpb3JpdHk6IDMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBNYXRoLnBvdygxMCwgLXRva2VuLmxlbmd0aCArIDMpKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKHZhbHVlKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gKzAwOjAwIGlzIGAnWidgKVxuICBYOiB7XG4gICAgcHJpb3JpdHk6IDEwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsTWludXRlcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdYWCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnWFhYWCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbFNlY29uZHMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnWFhYWFgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ1hYWCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWQsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBpZiAoZmxhZ3MudGltZXN0YW1wSXNTZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIHZhbHVlKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnLCAneCddXG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMSlcbiAgeDoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbE1pbnV0ZXMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAneHgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3h4eHgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxTZWNvbmRzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3h4eHh4JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZE9wdGlvbmFsU2Vjb25kcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd4eHgnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgaWYgKGZsYWdzLnRpbWVzdGFtcElzU2V0KSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgLSB2YWx1ZSk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsndCcsICdUJywgJ1gnXVxuICB9LFxuICAvLyBTZWNvbmRzIHRpbWVzdGFtcFxuICB0OiB7XG4gICAgcHJpb3JpdHk6IDQwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCBfdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBwYXJzZUFueURpZ2l0c1NpZ25lZChzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoX2RhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gW25ldyBEYXRlKHZhbHVlICogMTAwMCksIHtcbiAgICAgICAgdGltZXN0YW1wSXNTZXQ6IHRydWVcbiAgICAgIH1dO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiAnKidcbiAgfSxcbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICBUOiB7XG4gICAgcHJpb3JpdHk6IDIwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCBfdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBwYXJzZUFueURpZ2l0c1NpZ25lZChzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoX2RhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gW25ldyBEYXRlKHZhbHVlKSwge1xuICAgICAgICB0aW1lc3RhbXBJc1NldDogdHJ1ZVxuICAgICAgfV07XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6ICcqJ1xuICB9XG59O1xuXG52YXIgVElNRVpPTkVfVU5JVF9QUklPUklUWSA9IDEwOyAvLyBUaGlzIFJlZ0V4cCBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0cyBzZXBhcmF0ZWQgYnkgYHxgOlxuLy8gLSBbeVlRcU1Md0lkRGVjaWhIS2ttc11vIG1hdGNoZXMgYW55IGF2YWlsYWJsZSBvcmRpbmFsIG51bWJlciB0b2tlblxuLy8gICAob25lIG9mIHRoZSBjZXJ0YWluIGxldHRlcnMgZm9sbG93ZWQgYnkgYG9gKVxuLy8gLSAoXFx3KVxcMSogbWF0Y2hlcyBhbnkgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIGxldHRlclxuLy8gLSAnJyBtYXRjaGVzIHR3byBxdW90ZSBjaGFyYWN0ZXJzIGluIGEgcm93XG4vLyAtICcoJyd8W14nXSkrKCd8JCkgbWF0Y2hlcyBhbnl0aGluZyBzdXJyb3VuZGVkIGJ5IHR3byBxdW90ZSBjaGFyYWN0ZXJzICgnKSxcbi8vICAgZXhjZXB0IGEgc2luZ2xlIHF1b3RlIHN5bWJvbCwgd2hpY2ggZW5kcyB0aGUgc2VxdWVuY2UuXG4vLyAgIFR3byBxdW90ZSBjaGFyYWN0ZXJzIGRvIG5vdCBlbmQgdGhlIHNlcXVlbmNlLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBzaW5nbGUgcXVvdGVcbi8vICAgdGhlbiB0aGUgc2VxdWVuY2Ugd2lsbCBjb250aW51ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4vLyAtIC4gbWF0Y2hlcyBhbnkgc2luZ2xlIGNoYXJhY3RlciB1bm1hdGNoZWQgYnkgcHJldmlvdXMgcGFydHMgb2YgdGhlIFJlZ0V4cHNcblxudmFyIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSA9IC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZzsgLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSA9IC9QK3ArfFArfHArfCcnfCcoJyd8W14nXSkrKCd8JCl8Li9nO1xudmFyIGVzY2FwZWRTdHJpbmdSZWdFeHAkMSA9IC9eJyguKj8pJz8kLztcbnZhciBkb3VibGVRdW90ZVJlZ0V4cCQxID0gLycnL2c7XG52YXIgbm90V2hpdGVzcGFjZVJlZ0V4cCA9IC9cXFMvO1xudmFyIHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwJDEgPSAvW2EtekEtWl0vO1xuLyoqXG4gKiBAbmFtZSBwYXJzZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBQYXJzZSB0aGUgZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZGF0ZSBwYXJzZWQgZnJvbSBzdHJpbmcgdXNpbmcgdGhlIGdpdmVuIGZvcm1hdCBzdHJpbmcuXG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgYGZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogVGhlIGNoYXJhY3RlcnMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgd3JhcHBlZCBiZXR3ZWVuIHR3byBzaW5nbGUgcXVvdGVzIGNoYXJhY3RlcnMgKCcpIGFyZSBlc2NhcGVkLlxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXG4gKlxuICogRm9ybWF0IG9mIHRoZSBmb3JtYXQgc3RyaW5nIGlzIGJhc2VkIG9uIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIHdpdGggYSBmZXcgYWRkaXRpb25zIChzZWUgbm90ZSA1IGJlbG93IHRoZSB0YWJsZSkuXG4gKlxuICogTm90IGFsbCB0b2tlbnMgYXJlIGNvbXBhdGlibGUuIENvbWJpbmF0aW9ucyB0aGF0IGRvbid0IG1ha2Ugc2Vuc2Ugb3IgY291bGQgbGVhZCB0byBidWdzIGFyZSBwcm9oaWJpdGVkXG4gKiBhbmQgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAuIEZvciBleGFtcGxlIHVzYWdlIG9mIDI0LWhvdXIgZm9ybWF0IHRva2VuIHdpdGggQU0vUE0gdG9rZW4gd2lsbCB0aHJvdyBhbiBleGNlcHRpb246XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcGFyc2UoJzIzIEFNJywgJ0hIIGEnLCBuZXcgRGF0ZSgpKVxuICogLy89PiBSYW5nZUVycm9yOiBUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gYEhIYCBhbmQgYGFgIGF0IHRoZSBzYW1lIHRpbWVcbiAqIGBgYFxuICpcbiAqIFNlZSB0aGUgY29tcGF0aWJpbGl0eSB0YWJsZTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvZS8yUEFDWC0xdlFPUFUzeFVocGxsbDZkeW9NbVZVWEhLbF84Q1JEczZfdWVMbWV4M1NvcXdodW9sa3VOM08wNWw0cnF4NWgxZEtYOGViNDZVbC1DQ1NycS9wdWJodG1sP2dpZD0wJnNpbmdsZT10cnVlXG4gKlxuICogQWNjZXB0ZWQgZm9ybWF0IHN0cmluZyBwYXR0ZXJuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8UHJpb3J8IFBhdHRlcm4gfCBSZXN1bHQgZXhhbXBsZXMgICAgICAgICAgICAgICAgICAgfCBOb3RlcyB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfFxuICogfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMTQwIHwgRy4uR0dHICB8IEFELCBCQyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEdHR0cgICAgfCBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBHR0dHRyAgIHwgQSwgQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgMTMwIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3LCA5OTk5ICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgOTk5OTk5OXRoICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5ICAgICB8IDA0NCwgMDAxLCAxMjMsIDk5OSAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eXkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXl5eSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0ICAgfFxuICogfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgIHwgMTMwIHwgWSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3LCA5MDAwICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgOTk5OTk5OXRoICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNCw2ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZICAgICB8IDA0NCwgMDAxLCAxMjMsIDk5OSAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWVkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA0LDYgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVlZWSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0ICAgfFxuICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgIHwgMTMwIHwgUiAgICAgICB8IC00MywgMSwgMTkwMCwgMjAxNywgOTk5OSwgLTk5OTkgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSICAgICAgfCAtNDMsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlIgICAgIHwgLTA0MywgMDAxLCAxMjMsIDk5OSwgLTk5OSAgICAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSUiAgICB8IC0wMDQzLCAwMDAxLCAyMDE3LCA5OTk5LCAtOTk5OSAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUlJSICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQsNSB8XG4gKiB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICAgfCAxMzAgfCB1ICAgICAgIHwgLTQzLCAxLCAxOTAwLCAyMDE3LCA5OTk5LCAtOTk5ICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXUgICAgICB8IC00MywgMDEsIDk5LCAtOTkgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dSAgICAgfCAtMDQzLCAwMDEsIDEyMywgOTk5LCAtOTk5ICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXV1ICAgIHwgLTAwNDMsIDAwMDEsIDIwMTcsIDk5OTksIC05OTk5ICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1dXUgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcbiAqIHwgUXVhcnRlciAoZm9ybWF0dGluZykgICAgICAgICAgICB8IDEyMCB8IFEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVFRICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRUVEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgUXVhcnRlciAoc3RhbmQtYWxvbmUpICAgICAgICAgICB8IDEyMCB8IHEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXFxICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxcXEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcbiAqIHwgTW9udGggKGZvcm1hdHRpbmcpICAgICAgICAgICAgICB8IDExMCB8IE0gICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU0gICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTSAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU1NICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NTU0gICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTW9udGggKHN0YW5kLWFsb25lKSAgICAgICAgICAgICB8IDExMCB8IEwgICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTEwgICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTCAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTExMICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMTEwgICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgICB8IDEwMCB8IHcgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB3byAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgd3cgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgICB8IDEwMCB8IEkgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBJbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSUkgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgICB8ICA5MCB8IGQgICAgICAgfCAxLCAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBkbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZGQgICAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgICB8ICA5MCB8IEQgICAgICAgfCAxLCAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzY1dGgsIDM2NnRoICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgREQgICAgICB8IDAxLCAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IERERCAgICAgfCAwMDEsIDAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEREREICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBEYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgICAgIHwgIDkwIHwgRS4uRUVFICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFRSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRUVFICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICB8ICA5MCB8IGkgICAgICAgfCAxLCAyLCAzLCAuLi4sIDcgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgN3RoICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWkgICAgICB8IDAxLCAwMiwgLi4uLCAwNyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaWkgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWlpaSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCA1ICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgfCAgOTAgfCBlICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZW8gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWUgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWVlICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlZWUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoc3RhbmQtYWxvbmUpIHwgIDkwIHwgYyAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjYyAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2MgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjYyAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjY2NjICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICB8ICA4MCB8IGEuLmFhYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8ICA4MCB8IGIuLmJiYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBiYmJiICAgIHwgYS5tLiwgcC5tLiwgbm9vbiwgbWlkbmlnaHQgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYmJiYmIgICB8IGEsIHAsIG4sIG1pICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgICB8ICA4MCB8IEIuLkJCQiAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBCQkJCICAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgQkJCQkIgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IGggICAgICAgfCAxLCAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBobyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMTJ0aCAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaGggICAgICB8IDAxLCAwMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IEggICAgICAgfCAwLCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBIbyAgICAgIHwgMHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSEggICAgICB8IDAwLCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IEsgICAgICAgfCAxLCAyLCAuLi4sIDExLCAwICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBLbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMHRoICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgS0sgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IGsgICAgICAgfCAyNCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBrbyAgICAgIHwgMjR0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwga2sgICAgICB8IDI0LCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgICB8ICA2MCB8IG0gICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBtbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgbW0gICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgICB8ICA1MCB8IHMgICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBzbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgc3MgICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgICB8ICA0MCB8IHQgICAgICAgfCA1MTI5Njk1MjAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB0dCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgIHwgIDMwIHwgUyAgICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTU1MgICAgIHwgMDAwLCAwMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1NTUyAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8ICAyMCB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgIDEwIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCAgMTAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgICB8ICBOQSB8IFAgICAgICAgfCAwNS8yOS8xNDUzICAgICAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUCAgICAgIHwgTWF5IDI5LCAxNDUzICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQICAgICB8IE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUFAgICAgfCBTdW5kYXksIE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgfCAyLDUsOCB8XG4gKiB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICAgfCAgTkEgfCBwICAgICAgIHwgMTI6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcHAgICAgICB8IDEyOjAwOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQ29tYmluYXRpb24gb2YgZGF0ZSBhbmQgdGltZSAgICB8ICBOQSB8IFBwICAgICAgfCAwNS8yOS8xNDUzLCAxMjowMCBBTSAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUHBwICAgIHwgTWF5IDI5LCAxNDUzLCAxMjowMDowMCBBTSAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQcHAgICB8IE1heSAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUFBwcCAgfCBTdW5kYXksIE1heSAyOXRoLCAxNDUzIGF0IC4uLiAgICAgfCAyLDUsOCB8XG4gKiBOb3RlczpcbiAqIDEuIFwiRm9ybWF0dGluZ1wiIHVuaXRzIChlLmcuIGZvcm1hdHRpbmcgcXVhcnRlcikgaW4gdGhlIGRlZmF1bHQgZW4tVVMgbG9jYWxlXG4gKiAgICBhcmUgdGhlIHNhbWUgYXMgXCJzdGFuZC1hbG9uZVwiIHVuaXRzLCBidXQgYXJlIGRpZmZlcmVudCBpbiBzb21lIGxhbmd1YWdlcy5cbiAqICAgIFwiRm9ybWF0dGluZ1wiIHVuaXRzIGFyZSBkZWNsaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIG9mIHRoZSBsYW5ndWFnZVxuICogICAgaW4gdGhlIGNvbnRleHQgb2YgYSBkYXRlLiBcIlN0YW5kLWFsb25lXCIgdW5pdHMgYXJlIGFsd2F5cyBub21pbmF0aXZlIHNpbmd1bGFyLlxuICogICAgSW4gYGZvcm1hdGAgZnVuY3Rpb24sIHRoZXkgd2lsbCBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHQ6XG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBMTExMJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZCdgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBNTU1NJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZHUnYFxuICpcbiAqICAgIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggYm90aCBmb3JtYXR0aW5nIGFuZCBzdGFuZC1hbG9uZSB1bml0cyBpbnRlcmNoYW5nYWJseS5cbiAqXG4gKiAyLiBBbnkgc2VxdWVuY2Ugb2YgdGhlIGlkZW50aWNhbCBsZXR0ZXJzIGlzIGEgcGF0dGVybiwgdW5sZXNzIGl0IGlzIGVzY2FwZWQgYnlcbiAqICAgIHRoZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyAoc2VlIGJlbG93KS5cbiAqICAgIElmIHRoZSBzZXF1ZW5jZSBpcyBsb25nZXIgdGhhbiBsaXN0ZWQgaW4gdGFibGU6XG4gKiAgICAtIGZvciBudW1lcmljYWwgdW5pdHMgKGB5eXl5eXl5eWApIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggYSBudW1iZXJcbiAqICAgICAgYXMgd2lkZSBhcyB0aGUgc2VxdWVuY2VcbiAqICAgIC0gZm9yIHRleHQgdW5pdHMgKGBNTU1NTU1NTWApIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggdGhlIHdpZGVzdCB2YXJpYXRpb24gb2YgdGhlIHVuaXQuXG4gKiAgICAgIFRoZXNlIHZhcmlhdGlvbnMgYXJlIG1hcmtlZCB3aXRoIFwiMlwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXG4gKlxuICogMy4gYFFRUVFRYCBhbmQgYHFxcXFxYCBjb3VsZCBiZSBub3Qgc3RyaWN0bHkgbnVtZXJpY2FsIGluIHNvbWUgbG9jYWxlcy5cbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXG4gKlxuICogNC4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIHBhdHRlcm5zIGFyZSBCLkMuIHllYXJzOlxuICpcbiAqICAgIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcbiAqICAgIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gKiAgICB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICpcbiAqICAgIEFsc28gYHl5YCB3aWxsIHRyeSB0byBndWVzcyB0aGUgY2VudHVyeSBvZiB0d28gZGlnaXQgeWVhciBieSBwcm94aW1pdHkgd2l0aCBgYmFja3VwRGF0ZWA6XG4gKlxuICogICAgYHBhcnNlKCc1MCcsICd5eScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFNhdCBKYW4gMDEgMjA1MCAwMDowMDowMGBcbiAqXG4gKiAgICBgcGFyc2UoJzc1JywgJ3l5JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gV2VkIEphbiAwMSAxOTc1IDAwOjAwOjAwYFxuICpcbiAqICAgIHdoaWxlIGB1dWAgd2lsbCBqdXN0IGFzc2lnbiB0aGUgeWVhciBhcyBpczpcbiAqXG4gKiAgICBgcGFyc2UoJzUwJywgJ3V1JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gU2F0IEphbiAwMSAwMDUwIDAwOjAwOjAwYFxuICpcbiAqICAgIGBwYXJzZSgnNzUnLCAndXUnLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBUdWUgSmFuIDAxIDAwNzUgMDA6MDA6MDBgXG4gKlxuICogICAgVGhlIHNhbWUgZGlmZmVyZW5jZSBpcyB0cnVlIGZvciBsb2NhbCBhbmQgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIChgWWAgYW5kIGBSYCksXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXG4gKiAgICBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAoY29tcGFyZSBbc2V0SVNPV2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3Mvc2V0SVNPV2Vla1llYXJ9XG4gKiAgICBhbmQgW3NldFdlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3NldFdlZWtZZWFyfSkuXG4gKlxuICogNS4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA2LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiA3LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRoZW4gY29uZnVzZWQgd2l0aCBkYXlzIG9mIHRoZSBtb250aC5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogOC4gYFArYCB0b2tlbnMgZG8gbm90IGhhdmUgYSBkZWZpbmVkIHByaW9yaXR5IHNpbmNlIHRoZXkgYXJlIG1lcmVseSBhbGlhc2VzIHRvIG90aGVyIHRva2VucyBiYXNlZFxuICogICAgb24gdGhlIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiAgICB1c2luZyBgZW4tVVNgIGxvY2FsZTogYFBgID0+IGBNTS9kZC95eXl5YFxuICogICAgdXNpbmcgYGVuLVVTYCBsb2NhbGU6IGBwYCA9PiBgaGg6bW0gYWBcbiAqICAgIHVzaW5nIGBwdC1CUmAgbG9jYWxlOiBgUGAgPT4gYGRkL01NL3l5eXlgXG4gKiAgICB1c2luZyBgcHQtQlJgIGxvY2FsZTogYHBgID0+IGBISDptbWBcbiAqXG4gKiBWYWx1ZXMgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZGF0ZSBpbiB0aGUgZGVzY2VuZGluZyBvcmRlciBvZiBpdHMgdW5pdCdzIHByaW9yaXR5LlxuICogVW5pdHMgb2YgYW4gZXF1YWwgcHJpb3JpdHkgb3ZlcndyaXRlIGVhY2ggb3RoZXIgaW4gdGhlIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gKlxuICogSWYgbm8gdmFsdWVzIG9mIGhpZ2hlciBwcmlvcml0eSBhcmUgcGFyc2VkIChlLmcuIHdoZW4gcGFyc2luZyBzdHJpbmcgJ0phbnVhcnkgMXN0JyB3aXRob3V0IGEgeWVhciksXG4gKiB0aGUgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSAzcmQgYXJndW1lbnQgYGJhY2t1cERhdGVgIHdoaWNoIHdvcmtzIGFzIGEgY29udGV4dCBvZiBwYXJzaW5nLlxuICpcbiAqIGBiYWNrdXBEYXRlYCBtdXN0IGJlIHBhc3NlZCBmb3IgY29ycmVjdCB3b3JrIG9mIHRoZSBmdW5jdGlvbi5cbiAqIElmIHlvdSdyZSBub3Qgc3VyZSB3aGljaCBgYmFja3VwRGF0ZWAgdG8gc3VwcGx5LCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRGF0ZTpcbiAqIGBwYXJzZSgnMDIvMTEvMjAxNCcsICdNTS9kZC95eXl5JywgbmV3IERhdGUoKSlgXG4gKiBJbiB0aGlzIGNhc2UgcGFyc2luZyB3aWxsIGJlIGRvbmUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgZGF0ZS5cbiAqIElmIGBiYWNrdXBEYXRlYCBpcyBgSW52YWxpZCBEYXRlYCBvciBhIHZhbHVlIG5vdCBjb252ZXJ0aWJsZSB0byB2YWxpZCBgRGF0ZWAsXG4gKiB0aGVuIGBJbnZhbGlkIERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXG4gKlxuICogSWYgYGZvcm1hdFN0cmluZ2AgbWF0Y2hlcyB3aXRoIGBkYXRlU3RyaW5nYCBidXQgZG9lcyBub3QgcHJvdmlkZXMgdG9rZW5zLCBgYmFja3VwRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBJZiBwYXJzaW5nIGZhaWxlZCwgYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIE9sZCBgcGFyc2VgIHdhcyByZW5hbWVkIHRvIGB0b0RhdGVgLlxuICogICBOb3cgYHBhcnNlYCBpcyBhIG5ldyBmdW5jdGlvbiB3aGljaCBwYXJzZXMgYSBzdHJpbmcgdXNpbmcgYSBwcm92aWRlZCBmb3JtYXQuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgcGFyc2UoJzIwMTYtMDEtMDEnKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICogICB0b0RhdGUoJzIwMTYtMDEtMDEnKVxuICogICBwYXJzZSgnMjAxNi0wMS0wMScsICd5eXl5LU1NLWRkJywgbmV3IERhdGUoKSlcbiAqICAgYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGVTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0U3RyaW5nIC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGJhY2t1cERhdGUgLSBkZWZpbmVzIHZhbHVlcyBtaXNzaW5nIGZyb20gdGhlIHBhcnNlZCBkYXRlU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEBwYXJhbSB7MXwyfDN8NHw1fDZ8N30gW29wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlPTFdIC0gdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiB0aGUgd2Vlay1udW1iZXJpbmcgeWVhciB0b2tlbnMgYFlZYCBhbmQgYFlZWVlgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSBkYXkgb2YgeWVhciB0b2tlbnMgYERgIGFuZCBgRERgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDMgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbWF0Y2hgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYHl5eXlgIGluc3RlYWQgb2YgYFlZWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnM7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgZGAgaW5zdGVhZCBvZiBgRGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGg7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgZGRgIGluc3RlYWQgb2YgYEREYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gZm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFBhcnNlIDExIEZlYnJ1YXJ5IDIwMTQgZnJvbSBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIHZhciByZXN1bHQgPSBwYXJzZSgnMDIvMTEvMjAxNCcsICdNTS9kZC95eXl5JywgbmV3IERhdGUoKSlcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFBhcnNlIDI4dGggb2YgRmVicnVhcnkgaW4gRXNwZXJhbnRvIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XG4gKiBpbXBvcnQgZW8gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogdmFyIHJlc3VsdCA9IHBhcnNlKCcyOC1hIGRlIGZlYnJ1YXJvJywgXCJkbyAnZGUnIE1NTU1cIiwgbmV3IERhdGUoMjAxMCwgMCwgMSksIHtcbiAqICAgbG9jYWxlOiBlb1xuICogfSlcbiAqIC8vPT4gU3VuIEZlYiAyOCAyMDEwIDAwOjAwOjAwXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoZGlydHlEYXRlU3RyaW5nLCBkaXJ0eUZvcm1hdFN0cmluZywgZGlydHlCYWNrdXBEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMyBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZVN0cmluZyA9IFN0cmluZyhkaXJ0eURhdGVTdHJpbmcpO1xuICB2YXIgZm9ybWF0U3RyaW5nID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyaW5nKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUkMSA9IG9wdGlvbnMubG9jYWxlIHx8IGxvY2FsZTtcblxuICBpZiAoIWxvY2FsZSQxLm1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gbWF0Y2ggcHJvcGVydHknKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUkMS5vcHRpb25zICYmIGxvY2FsZSQxLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlciQxKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA6IHRvSW50ZWdlciQxKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAxIGFuZCA3IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoIShmaXJzdFdlZWtDb250YWluc0RhdGUgPj0gMSAmJiBmaXJzdFdlZWtDb250YWluc0RhdGUgPD0gNykpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZmlyc3RXZWVrQ29udGFpbnNEYXRlIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlJDEub3B0aW9ucyAmJiBsb2NhbGUkMS5vcHRpb25zLndlZWtTdGFydHNPbjtcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIkMShsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIkMShvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJycpIHtcbiAgICBpZiAoZGF0ZVN0cmluZyA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0b0RhdGUoZGlydHlCYWNrdXBEYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1YkZuT3B0aW9ucyA9IHtcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbixcbiAgICBsb2NhbGU6IGxvY2FsZSQxIC8vIElmIHRpbWV6b25lIGlzbid0IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuXG4gIH07XG4gIHZhciBzZXR0ZXJzID0gW3tcbiAgICBwcmlvcml0eTogVElNRVpPTkVfVU5JVF9QUklPUklUWSxcbiAgICBzZXQ6IGRhdGVUb1N5c3RlbVRpbWV6b25lLFxuICAgIGluZGV4OiAwXG4gIH1dO1xuICB2YXIgaTtcbiAgdmFyIHRva2VucyA9IGZvcm1hdFN0cmluZy5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxKS5tYXAoZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgIHZhciBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcblxuICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gJ3AnIHx8IGZpcnN0Q2hhcmFjdGVyID09PSAnUCcpIHtcbiAgICAgIHZhciBsb25nRm9ybWF0dGVyID0gbG9uZ0Zvcm1hdHRlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuICAgICAgcmV0dXJuIGxvbmdGb3JtYXR0ZXIoc3Vic3RyaW5nLCBsb2NhbGUkMS5mb3JtYXRMb25nLCBzdWJGbk9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzdHJpbmc7XG4gIH0pLmpvaW4oJycpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSk7XG4gIHZhciB1c2VkVG9rZW5zID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSkge1xuICAgICAgdGhyb3dQcm90ZWN0ZWRFcnJvcih0b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbih0b2tlbikpIHtcbiAgICAgIHRocm93UHJvdGVjdGVkRXJyb3IodG9rZW4pO1xuICAgIH1cblxuICAgIHZhciBmaXJzdENoYXJhY3RlciA9IHRva2VuWzBdO1xuICAgIHZhciBwYXJzZXIgPSBwYXJzZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIHZhciBpbmNvbXBhdGlibGVUb2tlbnMgPSBwYXJzZXIuaW5jb21wYXRpYmxlVG9rZW5zO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmNvbXBhdGlibGVUb2tlbnMpKSB7XG4gICAgICAgIHZhciBpbmNvbXBhdGlibGVUb2tlbiA9IHZvaWQgMDtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXNlZFRva2Vucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgdXNlZFRva2VuID0gdXNlZFRva2Vuc1tfaV0udG9rZW47XG5cbiAgICAgICAgICBpZiAoaW5jb21wYXRpYmxlVG9rZW5zLmluZGV4T2YodXNlZFRva2VuKSAhPT0gLTEgfHwgdXNlZFRva2VuID09PSBmaXJzdENoYXJhY3Rlcikge1xuICAgICAgICAgICAgaW5jb21wYXRpYmxlVG9rZW4gPSB1c2VkVG9rZW5zW19pXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNvbXBhdGlibGVUb2tlbikge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIGZvcm1hdCBzdHJpbmcgbXVzdG4ndCBjb250YWluIGBcIi5jb25jYXQoaW5jb21wYXRpYmxlVG9rZW4uZnVsbFRva2VuLCBcImAgYW5kIGBcIikuY29uY2F0KHRva2VuLCBcImAgYXQgdGhlIHNhbWUgdGltZVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VyLmluY29tcGF0aWJsZVRva2VucyA9PT0gJyonICYmIHVzZWRUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIGZvcm1hdCBzdHJpbmcgbXVzdG4ndCBjb250YWluIGBcIi5jb25jYXQodG9rZW4sIFwiYCBhbmQgYW55IG90aGVyIHRva2VuIGF0IHRoZSBzYW1lIHRpbWVcIikpO1xuICAgICAgfVxuXG4gICAgICB1c2VkVG9rZW5zLnB1c2goe1xuICAgICAgICB0b2tlbjogZmlyc3RDaGFyYWN0ZXIsXG4gICAgICAgIGZ1bGxUb2tlbjogdG9rZW5cbiAgICAgIH0pO1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gcGFyc2VyLnBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBsb2NhbGUkMS5tYXRjaCwgc3ViRm5PcHRpb25zKTtcblxuICAgICAgaWYgKCFwYXJzZVJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICAgIH1cblxuICAgICAgc2V0dGVycy5wdXNoKHtcbiAgICAgICAgcHJpb3JpdHk6IHBhcnNlci5wcmlvcml0eSxcbiAgICAgICAgc2V0OiBwYXJzZXIuc2V0LFxuICAgICAgICB2YWxpZGF0ZTogcGFyc2VyLnZhbGlkYXRlLFxuICAgICAgICB2YWx1ZTogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgIGluZGV4OiBzZXR0ZXJzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBkYXRlU3RyaW5nID0gcGFyc2VSZXN1bHQucmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyLm1hdGNoKHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwJDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdGb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXIgYCcgKyBmaXJzdENoYXJhY3RlciArICdgJyk7XG4gICAgICB9IC8vIFJlcGxhY2UgdHdvIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJcblxuXG4gICAgICBpZiAodG9rZW4gPT09IFwiJydcIikge1xuICAgICAgICB0b2tlbiA9IFwiJ1wiO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgICAgdG9rZW4gPSBjbGVhbkVzY2FwZWRTdHJpbmckMSh0b2tlbik7XG4gICAgICB9IC8vIEN1dCB0b2tlbiBmcm9tIHN0cmluZywgb3IsIGlmIHN0cmluZyBkb2Vzbid0IG1hdGNoIHRoZSB0b2tlbiwgcmV0dXJuIEludmFsaWQgRGF0ZVxuXG5cbiAgICAgIGlmIChkYXRlU3RyaW5nLmluZGV4T2YodG9rZW4pID09PSAwKSB7XG4gICAgICAgIGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyBpbnB1dCBjb250YWlucyBzb21ldGhpbmcgb3RoZXIgdGhhbiB3aGl0ZXNwYWNlXG5cblxuICBpZiAoZGF0ZVN0cmluZy5sZW5ndGggPiAwICYmIG5vdFdoaXRlc3BhY2VSZWdFeHAudGVzdChkYXRlU3RyaW5nKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG5cbiAgdmFyIHVuaXF1ZVByaW9yaXR5U2V0dGVycyA9IHNldHRlcnMubWFwKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICByZXR1cm4gc2V0dGVyLnByaW9yaXR5O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHByaW9yaXR5LCBpbmRleCwgYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihwcmlvcml0eSkgPT09IGluZGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHNldHRlcnMuZmlsdGVyKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIucHJpb3JpdHkgPT09IHByaW9yaXR5O1xuICAgIH0pLnJldmVyc2UoKTtcbiAgfSkubWFwKGZ1bmN0aW9uIChzZXR0ZXJBcnJheSkge1xuICAgIHJldHVybiBzZXR0ZXJBcnJheVswXTtcbiAgfSk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5QmFja3VwRGF0ZSk7XG5cbiAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH0gLy8gQ29udmVydCB0aGUgZGF0ZSBpbiBzeXN0ZW0gdGltZXpvbmUgdG8gdGhlIHNhbWUgZGF0ZSBpbiBVVEMrMDA6MDAgdGltZXpvbmUuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gVVRDIGZ1bmN0aW9ucyB3aWxsIGJlIGltcGxlbWVudGVkLCBsb2NhbGVzIHdpbGwgYmUgY29tcGF0aWJsZSB3aXRoIHRoZW0uXG4gIC8vIFNlZSBhbiBpc3N1ZSBhYm91dCBVVEMgZnVuY3Rpb25zOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3XG5cblxuICB2YXIgdXRjRGF0ZSA9IHN1Yk1pbGxpc2Vjb25kcyhkYXRlLCBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGRhdGUpKTtcbiAgdmFyIGZsYWdzID0ge307XG5cbiAgZm9yIChpID0gMDsgaSA8IHVuaXF1ZVByaW9yaXR5U2V0dGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZXR0ZXIgPSB1bmlxdWVQcmlvcml0eVNldHRlcnNbaV07XG5cbiAgICBpZiAoc2V0dGVyLnZhbGlkYXRlICYmICFzZXR0ZXIudmFsaWRhdGUodXRjRGF0ZSwgc2V0dGVyLnZhbHVlLCBzdWJGbk9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gc2V0dGVyLnNldCh1dGNEYXRlLCBmbGFncywgc2V0dGVyLnZhbHVlLCBzdWJGbk9wdGlvbnMpOyAvLyBSZXN1bHQgaXMgdHVwbGUgKGRhdGUsIGZsYWdzKVxuXG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgdXRjRGF0ZSA9IHJlc3VsdFswXTtcbiAgICAgIGFzc2lnbiQxKGZsYWdzLCByZXN1bHRbMV0pOyAvLyBSZXN1bHQgaXMgZGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGNEYXRlID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dGNEYXRlO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9TeXN0ZW1UaW1lem9uZShkYXRlLCBmbGFncykge1xuICBpZiAoZmxhZ3MudGltZXN0YW1wSXNTZXQpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZWREYXRlID0gbmV3IERhdGUoMCk7XG4gIGNvbnZlcnRlZERhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgY29udmVydGVkRGF0ZS5zZXRIb3VycyhkYXRlLmdldFVUQ0hvdXJzKCksIGRhdGUuZ2V0VVRDTWludXRlcygpLCBkYXRlLmdldFVUQ1NlY29uZHMoKSwgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSk7XG4gIHJldHVybiBjb252ZXJ0ZWREYXRlO1xufVxuXG5mdW5jdGlvbiBjbGVhbkVzY2FwZWRTdHJpbmckMShpbnB1dCkge1xuICByZXR1cm4gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cCQxKVsxXS5yZXBsYWNlKGRvdWJsZVF1b3RlUmVnRXhwJDEsIFwiJ1wiKTtcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9IT1VSJDEgPSAzNjAwMDAwO1xudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMiA9IDYwMDAwO1xudmFyIERFRkFVTFRfQURESVRJT05BTF9ESUdJVFMgPSAyO1xudmFyIHBhdHRlcm5zID0ge1xuICBkYXRlVGltZURlbGltaXRlcjogL1tUIF0vLFxuICB0aW1lWm9uZURlbGltaXRlcjogL1taIF0vaSxcbiAgdGltZXpvbmU6IC8oW1orLV0uKikkL1xufTtcbnZhciBkYXRlUmVnZXggPSAvXi0/KD86KFxcZHszfSl8KFxcZHsyfSkoPzotPyhcXGR7Mn0pKT98VyhcXGR7Mn0pKD86LT8oXFxkezF9KSk/fCkkLztcbnZhciB0aW1lUmVnZXggPSAvXihcXGR7Mn0oPzpbLixdXFxkKik/KSg/Ojo/KFxcZHsyfSg/OlsuLF1cXGQqKT8pKT8oPzo6PyhcXGR7Mn0oPzpbLixdXFxkKik/KSk/JC87XG52YXIgdGltZXpvbmVSZWdleCA9IC9eKFsrLV0pKFxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8kLztcbi8qKlxuICogQG5hbWUgcGFyc2VJU09cbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgSVNPIHN0cmluZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQgYW5kIHJldHVybiBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxuICogSVNPIDg2MDE6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDFcbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXNuJ3QgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiBjYW5ub3QgcGFyc2UgdGhlIHN0cmluZyBvclxuICogdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIFRoZSBwcmV2aW91cyBgcGFyc2VgIGltcGxlbWVudGF0aW9uIHdhcyByZW5hbWVkIHRvIGBwYXJzZUlTT2AuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgcGFyc2UoJzIwMTYtMDEtMDEnKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICogICBwYXJzZUlTTygnMjAxNi0wMS0wMScpXG4gKiAgIGBgYFxuICpcbiAqIC0gYHBhcnNlSVNPYCBub3cgdmFsaWRhdGVzIHNlcGFyYXRlIGRhdGUgYW5kIHRpbWUgdmFsdWVzIGluIElTTy04NjAxIHN0cmluZ3NcbiAqICAgYW5kIHJldHVybnMgYEludmFsaWQgRGF0ZWAgaWYgdGhlIGRhdGUgaXMgaW52YWxpZC5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgcGFyc2VJU08oJzIwMTgtMTMtMzInKVxuICogICAvLz0+IEludmFsaWQgRGF0ZVxuICogICBgYGBcbiAqXG4gKiAtIGBwYXJzZUlTT2Agbm93IGRvZXNuJ3QgZmFsbCBiYWNrIHRvIGBuZXcgRGF0ZWAgY29uc3RydWN0b3JcbiAqICAgaWYgaXQgZmFpbHMgdG8gcGFyc2UgYSBzdHJpbmcgYXJndW1lbnQuIEluc3RlYWQsIGl0IHJldHVybnMgYEludmFsaWQgRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJzIwMTQtMDItMTFUMTE6MzA6MzAnIHRvIGRhdGU6XG4gKiB2YXIgcmVzdWx0ID0gcGFyc2VJU08oJzIwMTQtMDItMTFUMTE6MzA6MzAnKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJyswMjAxNDEwMScgdG8gZGF0ZSxcbiAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XG4gKiB2YXIgcmVzdWx0ID0gcGFyc2VJU08oJyswMjAxNDEwMScsIHsgYWRkaXRpb25hbERpZ2l0czogMSB9KVxuICogLy89PiBGcmkgQXByIDExIDIwMTQgMDA6MDA6MDBcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUlTTyhhcmd1bWVudCwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGFkZGl0aW9uYWxEaWdpdHMgPSBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHMgPT0gbnVsbCA/IERFRkFVTFRfQURESVRJT05BTF9ESUdJVFMgOiB0b0ludGVnZXIkMShvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHMpO1xuXG4gIGlmIChhZGRpdGlvbmFsRGlnaXRzICE9PSAyICYmIGFkZGl0aW9uYWxEaWdpdHMgIT09IDEgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhZGRpdGlvbmFsRGlnaXRzIG11c3QgYmUgMCwgMSBvciAyJyk7XG4gIH1cblxuICBpZiAoISh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG5cbiAgdmFyIGRhdGVTdHJpbmdzID0gc3BsaXREYXRlU3RyaW5nKGFyZ3VtZW50KTtcbiAgdmFyIGRhdGU7XG5cbiAgaWYgKGRhdGVTdHJpbmdzLmRhdGUpIHtcbiAgICB2YXIgcGFyc2VZZWFyUmVzdWx0ID0gcGFyc2VZZWFyKGRhdGVTdHJpbmdzLmRhdGUsIGFkZGl0aW9uYWxEaWdpdHMpO1xuICAgIGRhdGUgPSBwYXJzZURhdGUocGFyc2VZZWFyUmVzdWx0LnJlc3REYXRlU3RyaW5nLCBwYXJzZVllYXJSZXN1bHQueWVhcik7XG4gIH1cblxuICBpZiAoaXNOYU4oZGF0ZSkgfHwgIWRhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIHRpbWUgPSAwO1xuICB2YXIgb2Zmc2V0O1xuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lKSB7XG4gICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcblxuICAgIGlmIChpc05hTih0aW1lKSB8fCB0aW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGF0ZVN0cmluZ3MudGltZXpvbmUpIHtcbiAgICBvZmZzZXQgPSBwYXJzZVRpbWV6b25lKGRhdGVTdHJpbmdzLnRpbWV6b25lKTtcblxuICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZ1bGxUaW1lID0gdGltZXN0YW1wICsgdGltZTtcbiAgICB2YXIgZnVsbFRpbWVEYXRlID0gbmV3IERhdGUoZnVsbFRpbWUpO1xuICAgIG9mZnNldCA9IGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZnVsbFRpbWVEYXRlKTsgLy8gQWRqdXN0IHRpbWUgd2hlbiBpdCdzIGNvbWluZyBmcm9tIERTVFxuXG4gICAgdmFyIGZ1bGxUaW1lRGF0ZU5leHREYXkgPSBuZXcgRGF0ZShmdWxsVGltZSk7XG4gICAgZnVsbFRpbWVEYXRlTmV4dERheS5zZXREYXRlKGZ1bGxUaW1lRGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICB2YXIgb2Zmc2V0RGlmZiA9IGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZnVsbFRpbWVEYXRlTmV4dERheSkgLSBvZmZzZXQ7XG5cbiAgICBpZiAob2Zmc2V0RGlmZiA+IDApIHtcbiAgICAgIG9mZnNldCArPSBvZmZzZXREaWZmO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gc3BsaXREYXRlU3RyaW5nKGRhdGVTdHJpbmcpIHtcbiAgdmFyIGRhdGVTdHJpbmdzID0ge307XG4gIHZhciBhcnJheSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMuZGF0ZVRpbWVEZWxpbWl0ZXIpO1xuICB2YXIgdGltZVN0cmluZztcblxuICBpZiAoLzovLnRlc3QoYXJyYXlbMF0pKSB7XG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IG51bGw7XG4gICAgdGltZVN0cmluZyA9IGFycmF5WzBdO1xuICB9IGVsc2Uge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBhcnJheVswXTtcbiAgICB0aW1lU3RyaW5nID0gYXJyYXlbMV07XG5cbiAgICBpZiAocGF0dGVybnMudGltZVpvbmVEZWxpbWl0ZXIudGVzdChkYXRlU3RyaW5ncy5kYXRlKSkge1xuICAgICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMudGltZVpvbmVEZWxpbWl0ZXIpWzBdO1xuICAgICAgdGltZVN0cmluZyA9IGRhdGVTdHJpbmcuc3Vic3RyKGRhdGVTdHJpbmdzLmRhdGUubGVuZ3RoLCBkYXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZS5leGVjKHRpbWVTdHJpbmcpO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZy5yZXBsYWNlKHRva2VuWzFdLCAnJyk7XG4gICAgICBkYXRlU3RyaW5ncy50aW1lem9uZSA9IHRva2VuWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0ZVN0cmluZ3M7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkYXRlU3RyaW5nLCBhZGRpdGlvbmFsRGlnaXRzKSB7XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ14oPzooXFxcXGR7NH18WystXVxcXFxkeycgKyAoNCArIGFkZGl0aW9uYWxEaWdpdHMpICsgJ30pfChcXFxcZHsyfXxbKy1dXFxcXGR7JyArICgyICsgYWRkaXRpb25hbERpZ2l0cykgKyAnfSkkKScpO1xuICB2YXIgY2FwdHVyZXMgPSBkYXRlU3RyaW5nLm1hdGNoKHJlZ2V4KTsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcblxuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4ge1xuICAgIHllYXI6IG51bGxcbiAgfTtcbiAgdmFyIHllYXIgPSBjYXB0dXJlc1sxXSAmJiBwYXJzZUludChjYXB0dXJlc1sxXSk7XG4gIHZhciBjZW50dXJ5ID0gY2FwdHVyZXNbMl0gJiYgcGFyc2VJbnQoY2FwdHVyZXNbMl0pO1xuICByZXR1cm4ge1xuICAgIHllYXI6IGNlbnR1cnkgPT0gbnVsbCA/IHllYXIgOiBjZW50dXJ5ICogMTAwLFxuICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKChjYXB0dXJlc1sxXSB8fCBjYXB0dXJlc1syXSkubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZywgeWVhcikge1xuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICBpZiAoeWVhciA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBjYXB0dXJlcyA9IGRhdGVTdHJpbmcubWF0Y2goZGF0ZVJlZ2V4KTsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHN0cmluZ1xuXG4gIGlmICghY2FwdHVyZXMpIHJldHVybiBudWxsO1xuICB2YXIgaXNXZWVrRGF0ZSA9ICEhY2FwdHVyZXNbNF07XG4gIHZhciBkYXlPZlllYXIgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzFdKTtcbiAgdmFyIG1vbnRoID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1syXSkgLSAxO1xuICB2YXIgZGF5ID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1szXSk7XG4gIHZhciB3ZWVrID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1s0XSk7XG4gIHZhciBkYXlPZldlZWsgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzVdKSAtIDE7XG5cbiAgaWYgKGlzV2Vla0RhdGUpIHtcbiAgICBpZiAoIXZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5T2ZXZWVrKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuXG4gICAgaWYgKCF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRheSkgfHwgIXZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG5cbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBNYXRoLm1heChkYXlPZlllYXIsIGRheSkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZVVuaXQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gcGFyc2VJbnQodmFsdWUpIDogMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWVTdHJpbmcpIHtcbiAgdmFyIGNhcHR1cmVzID0gdGltZVN0cmluZy5tYXRjaCh0aW1lUmVnZXgpO1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gbnVsbDsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcblxuICB2YXIgaG91cnMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzFdKTtcbiAgdmFyIG1pbnV0ZXMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzJdKTtcbiAgdmFyIHNlY29uZHMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzNdKTtcblxuICBpZiAoIXZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgcmV0dXJuIGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIkMSArIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDIgKyBzZWNvbmRzICogMTAwMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lVW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkgfHwgMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZSh0aW1lem9uZVN0cmluZykge1xuICBpZiAodGltZXpvbmVTdHJpbmcgPT09ICdaJykgcmV0dXJuIDA7XG4gIHZhciBjYXB0dXJlcyA9IHRpbWV6b25lU3RyaW5nLm1hdGNoKHRpbWV6b25lUmVnZXgpO1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gMDtcbiAgdmFyIHNpZ24gPSBjYXB0dXJlc1sxXSA9PT0gJysnID8gLTEgOiAxO1xuICB2YXIgaG91cnMgPSBwYXJzZUludChjYXB0dXJlc1syXSk7XG4gIHZhciBtaW51dGVzID0gY2FwdHVyZXNbM10gJiYgcGFyc2VJbnQoY2FwdHVyZXNbM10pIHx8IDA7XG5cbiAgaWYgKCF2YWxpZGF0ZVRpbWV6b25lKGhvdXJzLCBtaW51dGVzKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIChob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSJDEgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQyKTtcbn1cblxuZnVuY3Rpb24gZGF5T2ZJU09XZWVrWWVhcihpc29XZWVrWWVhciwgd2VlaywgZGF5KSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoMCk7XG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoaXNvV2Vla1llYXIsIDAsIDQpO1xuICB2YXIgZm91cnRoT2ZKYW51YXJ5RGF5ID0gZGF0ZS5nZXRVVENEYXkoKSB8fCA3O1xuICB2YXIgZGlmZiA9ICh3ZWVrIC0gMSkgKiA3ICsgZGF5ICsgMSAtIGZvdXJ0aE9mSmFudWFyeURheTtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlO1xufSAvLyBWYWxpZGF0aW9uIGZ1bmN0aW9uc1xuLy8gRmVicnVhcnkgaXMgbnVsbCB0byBoYW5kbGUgdGhlIGxlYXAgeWVhciAodXNpbmcgfHwpXG5cblxudmFyIGRheXNJbk1vbnRocyA9IFszMSwgbnVsbCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuXG5mdW5jdGlvbiBpc0xlYXBZZWFySW5kZXgkMSh5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNDAwID09PSAwIHx8IHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDA7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICByZXR1cm4gbW9udGggPj0gMCAmJiBtb250aCA8PSAxMSAmJiBkYXRlID49IDEgJiYgZGF0ZSA8PSAoZGF5c0luTW9udGhzW21vbnRoXSB8fCAoaXNMZWFwWWVhckluZGV4JDEoeWVhcikgPyAyOSA6IDI4KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpIHtcbiAgcmV0dXJuIGRheU9mWWVhciA+PSAxICYmIGRheU9mWWVhciA8PSAoaXNMZWFwWWVhckluZGV4JDEoeWVhcikgPyAzNjYgOiAzNjUpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVdlZWtEYXRlKF95ZWFyLCB3ZWVrLCBkYXkpIHtcbiAgcmV0dXJuIHdlZWsgPj0gMSAmJiB3ZWVrIDw9IDUzICYmIGRheSA+PSAwICYmIGRheSA8PSA2O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgaWYgKGhvdXJzID09PSAyNCkge1xuICAgIHJldHVybiBtaW51dGVzID09PSAwICYmIHNlY29uZHMgPT09IDA7XG4gIH1cblxuICByZXR1cm4gc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCA2MCAmJiBtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwICYmIGhvdXJzID49IDAgJiYgaG91cnMgPCAyNTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lem9uZShfaG91cnMsIG1pbnV0ZXMpIHtcbiAgcmV0dXJuIG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDw9IDU5O1xufVxuXG52YXIgcGFyc2VEYXRlJDEgPSBmdW5jdGlvbiBwYXJzZURhdGUodmFsdWUsIGZvcm1hdCkge1xuICBpZiAoaXNTdHJpbmdfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0ID8gcGFyc2UodmFsdWUsIGZvcm1hdCwgbmV3IERhdGUoKSkgOiBwYXJzZUlTTyh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvRGF0ZSh2YWx1ZSk7XG4gIH1cbn07IC8vIFdlIHdhbnQgdG8gc2V0IHRoZSBtZXNzYWdlcyBhIHN1cGVyZ2xvYmFsIHNvIHRoYXQgaW1wb3J0cyBhY3Jvc3MgZmlsZXNcbi8vIHJlZmVyZW5jZSB0aGUgc2FtZSBtZXNzYWdlcyBvYmplY3QuXG5cblxudmFyIF9nbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCB8fCB7fTtcbi8qKlxuICogR2xvYmFsIHZhbGlkYXRpb24gbWVzc2FnZSByZWdpc3RyeS5cbiAqL1xuXG5cbnZhciBtZXNzYWdlcyA9IF9nbG9iYWwuX192dWVtY192YWxpZGF0aW9uX21lc3NhZ2VzID0gX2dsb2JhbC5fX3Z1ZW1jX3ZhbGlkYXRpb25fbWVzc2FnZXMgfHwgbmV3IChcbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgZXZlcnl0aGluZyB0byB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy4kbG9jYWxlID0gJ2VuLXVzJztcbiAgICAgIHRoaXMuJGZhbGxiYWNrID0gJ2VuLXVzJztcbiAgICAgIHRoaXMuJGxvY2FsZXMgPSB7fTtcbiAgICAgIHRoaXMucmVnaXN0ZXIoZW5fdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgbG9jYWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9jYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsZShfbG9jYWxlKSB7XG4gICAgICB0aGlzLiRsb2NhbGUgPSB0b0xvd2VyXzEoX2xvY2FsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGxhbmd1YWdlIHBhY2suXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihidW5kbGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBsb2NhbGUgPSB0b0xvd2VyXzEoYnVuZGxlLmxvY2FsZSk7XG4gICAgICBlYWNoKGdldF8xKGJ1bmRsZSwgJ21lc3NhZ2VzJywge30pLCBmdW5jdGlvbiAobWVzc2FnZSwgbmFtZSkge1xuICAgICAgICBzZXRfMShfdGhpcy4kbG9jYWxlcywgW2xvY2FsZSwgbmFtZV0sIHRlbXBsYXRlXzEobWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG9yIGFkZHMgYSBuZXcgbWVzc2FnZSBmb3IgYSBnaXZlbiBuYW1lIGFuZCBvcHRpb25hbCBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQobmFtZSwgZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgIHZhciAkdGVtcGxhdGUgPSBpc1N0cmluZ18xKGZvcm1hdCkgPyB0ZW1wbGF0ZV8xKGZvcm1hdCkgOiBmb3JtYXQ7IC8vIFVzZSB0aGUgZ2l2ZW4gbG9jYWxlLlxuXG4gICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgIHNldF8xKHRoaXMuJGxvY2FsZXMsIFtsb2NhbGUsIG5hbWVdLCAkdGVtcGxhdGUpOyAvLyBPdGhlcndpc2UgdXNlIHRoZSBhY3RpdmUgbG9jYWxlLlxuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuJGxvY2FsZSkge1xuICAgICAgICBzZXRfMSh0aGlzLiRsb2NhbGVzLCBbdGhpcy4kbG9jYWxlLCBuYW1lXSwgJHRlbXBsYXRlKTsgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBsb2NhbGUuXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldF8xKHRoaXMuJGxvY2FsZXMsIFt0aGlzLiRmYWxsYmFjaywgbmFtZV0sICR0ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBhIGdpdmVuIG1lc3NhZ2UgbmFtZSBhbmQgY29udGV4dCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIC8vIEF0dGVtcHQgdG8gZmluZCB0aGUgbmFtZSB1c2luZyB0aGUgYWN0aXZlIGxvY2FsZSwgZmFsbGluZyBiYWNrIHRvIHRoZVxuICAgICAgLy8gYWN0aXZlIGxvY2FsZSdzIGxhbmd1YWdlLCBhbmQgZmluYWxseSBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQuXG4gICAgICB2YXIgdGVtcGxhdGUgPSBnZXRfMSh0aGlzLiRsb2NhbGVzLCBbdGhpcy4kbG9jYWxlLCBuYW1lXSwgZ2V0XzEodGhpcy4kbG9jYWxlcywgW3NwbGl0XzEodGhpcy4kbG9jYWxlLCAnLScpWzBdLCBuYW1lXSwgZ2V0XzEodGhpcy4kbG9jYWxlcywgW3RoaXMuJGZhbGxiYWNrLCBuYW1lXSkpKTsgLy8gRmFsbCBiYWNrIHRvIGEgYmxhbmsgc3RyaW5nIHNvIHRoYXQgd2UgZG9uJ3QgcG90ZW50aWFsbHlcbiAgICAgIC8vIGxlYWsgbWVzc2FnZSBuYW1lcyBvciBjb250ZXh0IGRhdGEgaW50byB0aGUgdGVtcGxhdGUuXG5cblxuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZW1wbGF0ZShkYXRhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2NsYXNzO1xufSgpKSgpO1xuLyoqXG4gKiBSdWxlIGhlbHBlcnMgZm9yIGVhc3kgdmFsaWRhdGlvbi5cbiAqIFRoZXNlIGNhbiBhbGwgYmUgdXNlZCBkaXJlY3RseSBpbiBhIG1vZGVsJ3MgdmFsaWRhdGlvbiBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHthc2NpaSwgbGVuZ3RofSBmcm9tICd2dWUtbWMvdmFsaWRhdGlvbidcbiAqXG4gKiBjbGFzcyBVc2VyIGV4dGVuZHMgTW9kZWwge1xuICogICAgIHZhbGlkYXRpb24oKSB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgICBwYXNzd29yZDogYXNjaWkuYW5kKGxlbmd0aCg2KSksXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZhbGlkYXRpb24gcnVsZS5cbiAqXG4gKiBSdWxlcyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBjaGFpbmVkIHdpdGggYG9yYCBhbmQgYGFuZGAuXG4gKiBGb3IgZXhhbXBsZTogYHJ1bGVBLm9yKHJ1bGVCLmFuZChSdWxlQykpLmFuZChSdWxlRClgXG4gKlxuICogVGhlIGVycm9yIG1lc3NhZ2UgY2FuIGJlIHNldCBvciByZXBsYWNlZCB1c2luZyBgZm9ybWF0KG1lc3NhZ2V8dGVtcGxhdGUpYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnOlxuICogICAgIC0gbmFtZTogTmFtZSBvZiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqICAgICAtIGRhdGE6IENvbnRleHQgZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICogICAgIC0gdGVzdDogRnVuY3Rpb24gYWNjZXB0aW5nICh2YWx1ZSwgbW9kZWwpLCB3aGljaCBzaG91bGRcbiAqICAgICAgICAgICAgIHJldHVybiBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHZhbGlkLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVmFsaWRhdGlvbiBydWxlLlxuICovXG5cbnZhciBydWxlID0gZnVuY3Rpb24gcnVsZShjb25maWcpIHtcbiAgdmFyIG5hbWUgPSBnZXRfMShjb25maWcsICduYW1lJyk7XG5cbiAgdmFyIGRhdGEgPSBnZXRfMShjb25maWcsICdkYXRhJywge30pO1xuXG4gIHZhciB0ZXN0ID0gZ2V0XzEoY29uZmlnLCAndGVzdCcsIHN0dWJUcnVlXzEpO1xuICAvKipcbiAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB1c2luZyB0aGlzIHJ1bGUuXG4gICAqIEl0IGhhcyBzb21lIGV4dHJhIG1ldGFkYXRhIHRvIGFsbG93IHJ1bGUgY2hhaW5pbmcgYW5kIGN1c3RvbSBmb3JtYXRzLlxuICAgKi9cblxuXG4gIHZhciAkcnVsZSA9IGZ1bmN0aW9uICRydWxlKHZhbHVlLCBhdHRyaWJ1dGUsIG1vZGVsKSB7XG4gICAgLy8gYHRydWVgIGlmIHRoaXMgcnVsZSdzIGNvcmUgYWNjZXB0YW5jZSBjcml0ZXJpYSB3YXMgbWV0LlxuICAgIHZhciB2YWxpZCA9IHRlc3QodmFsdWUsIGF0dHJpYnV0ZSwgbW9kZWwpOyAvLyBJZiB2YWxpZCwgY2hlY2sgdGhhdCBhbGwgcnVsZXMgaW4gdGhlIFwiYW5kXCIgY2hhaW4gYWxzbyBwYXNzLlxuXG4gICAgaWYgKHZhbGlkKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gJHJ1bGUuX2FuZFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2FuZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IF9hbmQodmFsdWUsIGF0dHJpYnV0ZSwgbW9kZWwpOyAvLyBJZiBhbnkgb2YgdGhlIGNoYWluZWQgcnVsZXMgcmV0dXJuIGEgc3RyaW5nLCB3ZSBrbm93IHRoYXRcbiAgICAgICAgICAvLyB0aGF0IHJ1bGUgaGFzIGZhaWxlZCwgYW5kIHRoZXJlZm9yZSB0aGlzIGNoYWluIGlzIGludmFsaWQuXG5cblxuICAgICAgICAgIGlmIChpc1N0cmluZ18xKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEVpdGhlciB0aGVyZSB3ZXJlbid0IGFueSBcImFuZFwiIHJ1bGVzIG9yIHRoZXkgYWxsIHBhc3NlZC5cblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbXCJyZXR1cm5cIl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yW1wicmV0dXJuXCJdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlOyAvLyBUaGlzIHJ1bGUncyBhY2NlcHRhbmNlIGNyaXRlcmlhIHdhcyBub3QgbWV0LCBidXQgdGhlcmUgaXMgYSBjaGFuY2VcbiAgICAgIC8vIHRoYXQgYSBydWxlIGluIHRoZSBcIm9yXCIgY2hhaW4ncyBtaWdodCBwYXNzLlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9ICRydWxlLl9vcltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfb3IgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3Jlc3VsdCA9IF9vcih2YWx1ZSwgYXR0cmlidXRlLCBtb2RlbCk7IC8vIEEgcnVsZSBzaG91bGQgZWl0aGVyIHJldHVybiB0cnVlIGluIHRoZSBldmVudCBvZiBhIGdlbmVyYWxcbiAgICAgICAgICAvLyBcInBhc3NcIiwgb3Igbm90aGluZyBhdCBhbGwuIEEgZmFpbHVyZSB3b3VsZCBoYXZlIHRvIGJlIGFcbiAgICAgICAgICAvLyBzdHJpbmcgbWVzc2FnZSAodXN1YWxseSBmcm9tIGFub3RoZXIgcnVsZSkuXG5cblxuICAgICAgICAgIGlmIChfcmVzdWx0ID09PSB0cnVlIHx8IGlzVW5kZWZpbmVkXzEoX3Jlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyW1wicmV0dXJuXCJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjJbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQXQgdGhpcyBwb2ludCB3ZSB3YW50IHRvIHJlcG9ydCB0aGF0IHRoaXMgcnVsZSBoYXMgZmFpbGVkLCBiZWNhdXNlXG4gICAgLy8gbm9uZSBvZiB0aGUgXCJhbmRcIiBvciBcIm9yXCIgY2hhaW5zIHBhc3NlZCBlaXRoZXIuXG4gICAgLy8gQWRkIHRoZSBpbnZhbGlkIHZhbHVlIHRvIHRoZSBtZXNzYWdlIGNvbnRleHQsIHdoaWNoIGlzIG1hZGUgYXZhaWxhYmxlXG4gICAgLy8gdG8gYWxsIHJ1bGVzIGJ5IGRlZmF1bHQuIFRoaXMgYWxsb3dzIGZvciAke3ZhbHVlfSBpbnRlcnBvbGF0aW9uLlxuXG5cbiAgICBhc3NpZ25fMShkYXRhLCB7XG4gICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pOyAvLyBUaGlzIHdvdWxkIGJlIGEgY3VzdG9tIGZvcm1hdCBleHBsaWNpdGx5IHNldCBvbiB0aGlzIHJ1bGUuXG5cbiAgICB2YXIgZm9ybWF0ID0gZ2V0XzEoJHJ1bGUsICdfZm9ybWF0Jyk7IC8vIFVzZSB0aGUgZGVmYXVsdCBtZXNzYWdlIGlmIGFuIGV4cGxpY2l0IGZvcm1hdCBpc24ndCBzZXQuXG5cblxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICByZXR1cm4gbWVzc2FnZXMuZ2V0KG5hbWUsIGRhdGEpO1xuICAgIH0gLy8gUmVwbGFjZSB0aGUgY3VzdG9tIGZvcm1hdCB3aXRoIGEgdGVtcGxhdGUgaWYgaXQncyBzdGlsbCBhIHN0cmluZy5cblxuXG4gICAgaWYgKGlzU3RyaW5nXzEoZm9ybWF0KSkge1xuICAgICAgJHJ1bGUuX2Zvcm1hdCA9IGZvcm1hdCA9IHRlbXBsYXRlXzEoZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0KGRhdGEpO1xuICB9O1xuICAvKipcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGNvcHkgb2YgdGhpcyBydWxlLCBzbyB0aGF0IGFwcGVuZGluZyB0byBhIGNoYWluIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgc2V0dGluZyBhIGN1c3RvbSBmb3JtYXQgZG9lc24ndCBtb2RpZnkgdGhlIGJhc2UgcnVsZS5cbiAgICovXG5cblxuICAkcnVsZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhc3NpZ25fMShydWxlKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pLCBwaWNrXzEoJHJ1bGUsIFsnX2Zvcm1hdCcsICdfYW5kJywgJ19vciddKSk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgZm9ybWF0IG9uIHRoaXMgcnVsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IGZvcm1hdFxuICAgKi9cblxuXG4gICRydWxlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gYXNzaWduXzEoJHJ1bGUuY29weSgpLCB7XG4gICAgICBfZm9ybWF0OiBmb3JtYXRcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgYW5vdGhlciBydWxlIG9yIGZ1bmN0aW9uIHRvIHRoaXMgcnVsZSdzIE9SIGNoYWluLiBJZiB0aGUgZ2l2ZW4gcnVsZVxuICAgKiBwYXNzZXMgd2hlbiB0aGlzIG9uZSBmYWlscywgdGhpcyBydWxlIHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfSBydWxlcyBPbmUgb3IgbW9yZSBmdW5jdGlvbnMgdG8gYWRkIHRvIHRoZSBjaGFpbi5cbiAgICovXG5cblxuICAkcnVsZS5vciA9IGZ1bmN0aW9uIChydWxlcykge1xuICAgIHJldHVybiBhc3NpZ25fMSgkcnVsZS5jb3B5KCksIHtcbiAgICAgIF9vcjogY29uY2F0XzEoJHJ1bGUuX29yLCBydWxlcylcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgYW5vdGhlciBydWxlIG9yIGZ1bmN0aW9uIHRvIHRoaXMgcnVsZSdzIEFORCBjaGFpbi4gSWYgdGhlIGdpdmVuIHJ1bGVcbiAgICogZmFpbHMgd2hlbiB0aGlzIG9uZSBwYXNzZXMsIHRoaXMgcnVsZSB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119IHJ1bGVzIE9uZSBvciBtb3JlIGZ1bmN0aW9ucyB0byBhZGQgdG8gdGhlIGNoYWluLlxuICAgKi9cblxuXG4gICRydWxlLmFuZCA9IGZ1bmN0aW9uIChydWxlcykge1xuICAgIHJldHVybiBhc3NpZ25fMSgkcnVsZS5jb3B5KCksIHtcbiAgICAgIF9hbmQ6IGNvbmNhdF8xKCRydWxlLl9hbmQsIHJ1bGVzKVxuICAgIH0pO1xuICB9O1xuXG4gICRydWxlLl9hbmQgPSBbXTsgLy8gXCJhbmRcIiBjaGFpblxuXG4gICRydWxlLl9vciA9IFtdOyAvLyBcIm9yXCIgY2hhaW5cblxuICAkcnVsZS5fZm9ybWF0ID0gbnVsbDsgLy8gQ3VzdG9tIGZvcm1hdFxuXG4gIHJldHVybiAkcnVsZTtcbn07XG4vKipcbiAqIEFWQUlMQUJMRSBSVUxFU1xuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhZnRlciBhIGdpdmVuIGRhdGUgc3RyaW5nIG9yIGBEYXRlYCBvYmplY3QuXG4gKi9cblxudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoZGF0ZSkge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2FmdGVyJyxcbiAgICBkYXRhOiB7XG4gICAgICBkYXRlOiBkYXRlXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBZnRlcihwYXJzZURhdGUkMSh2YWx1ZSksIHBhcnNlRGF0ZSQxKGRhdGUpKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgb25seSBoYXMgbGV0dGVycy5cbiAqL1xuXG52YXIgYWxwaGEgPSBydWxlKHtcbiAgbmFtZTogJ2FscGhhJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0FscGhhKGRlYnVycl8xKHZhbHVlKSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBvbmx5IGhhcyBsZXR0ZXJzIG9yIG51bWJlcnMuXG4gKi9cblxudmFyIGFscGhhbnVtZXJpYyA9IHJ1bGUoe1xuICBuYW1lOiAnYWxwaGFudW1lcmljJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0FscGhhbnVtZXJpYyhkZWJ1cnJfMSh2YWx1ZSkpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXG4gKi9cblxudmFyIGFycmF5ID0gcnVsZSh7XG4gIG5hbWU6ICdhcnJheScsXG4gIHRlc3Q6IGlzQXJyYXlfMVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzLlxuICovXG5cbnZhciBhc2NpaSA9IHJ1bGUoe1xuICBuYW1lOiAnYXNjaWknLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIC9eW1xceDAwLVxceDdGXSskLy50ZXN0KHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgQmFzZTY0IHN0cmluZy5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcnVsZSh7XG4gIG5hbWU6ICdiYXNlNjQnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzQmFzZTY0KHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGJlZm9yZSBhIGdpdmVuIGRhdGUgc3RyaW5nIG9yIGBEYXRlYCBvYmplY3QuXG4gKi9cblxudmFyIGJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZShkYXRlKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnYmVmb3JlJyxcbiAgICBkYXRhOiB7XG4gICAgICBkYXRlOiBkYXRlXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNCZWZvcmUocGFyc2VEYXRlJDEodmFsdWUpLCBwYXJzZURhdGUkMShkYXRlKSk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGJldHdlZW4gYSBnaXZlbiBtaW5pbXVtIG9yIG1heGltdW0sIGluY2x1c2l2ZSBieSBkZWZhdWx0LlxuICovXG5cbnZhciBiZXR3ZWVuID0gZnVuY3Rpb24gYmV0d2VlbihtaW4sIG1heCkge1xuICB2YXIgaW5jbHVzaXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gIHZhciBfbWluID0gKyhpc1N0cmluZ18xKG1pbikgPyBwYXJzZURhdGUkMShtaW4pIDogbWluKTtcblxuICB2YXIgX21heCA9ICsoaXNTdHJpbmdfMShtYXgpID8gcGFyc2VEYXRlJDEobWF4KSA6IG1heCk7XG5cbiAgcmV0dXJuIHJ1bGUoe1xuICAgIGRhdGE6IHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9LFxuICAgIG5hbWU6IGluY2x1c2l2ZSA/ICdiZXR3ZWVuX2luY2x1c2l2ZScgOiAnYmV0d2VlbicsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgdmFyIF92YWx1ZSA9ICsoaXNTdHJpbmdfMSh2YWx1ZSkgPyBwYXJzZURhdGUkMSh2YWx1ZSkgOiB2YWx1ZSk7XG5cbiAgICAgIHJldHVybiBpbmNsdXNpdmUgPyBndGVfMShfdmFsdWUsIF9taW4pICYmIGx0ZV8xKF92YWx1ZSwgX21heCkgOiBndF8xKF92YWx1ZSwgX21pbikgJiYgbHRfMShfdmFsdWUsIF9tYXgpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIGJvb2xlYW4gKHN0cmljdGx5IHRydWUgb3IgZmFsc2UpLlxuICovXG5cbnZhciBfYm9vbGVhbiA9IHJ1bGUoe1xuICBuYW1lOiAnYm9vbGVhbicsXG4gIHRlc3Q6IGlzQm9vbGVhbl8xXG59KTtcbnZhciBjcmVkaXRjYXJkID0gcnVsZSh7XG4gIG5hbWU6ICdjcmVkaXRjYXJkJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0NyZWRpdENhcmQodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgcGFyc2VhYmxlIGFzIGEgZGF0ZS5cbiAqL1xuXG52YXIgZGF0ZSA9IHJ1bGUoe1xuICBuYW1lOiAnZGF0ZScsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNWYWxpZChwYXJzZURhdGUkMSh2YWx1ZSkpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgbWF0Y2hlcyB0aGUgZ2l2ZW4gZGF0ZSBmb3JtYXQuXG4gKlxuICogQHNlZSBodHRwczovL2RhdGUtZm5zLm9yZy92Mi4wLjAtYWxwaGEuOS9kb2NzL2Zvcm1hdFxuICovXG5cbnZhciBkYXRlZm9ybWF0ID0gZnVuY3Rpb24gZGF0ZWZvcm1hdChmb3JtYXQkMSkge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2RhdGVmb3JtYXQnLFxuICAgIGRhdGE6IHtcbiAgICAgIGZvcm1hdDogZm9ybWF0JDFcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHBhcnNlRGF0ZSQxKHZhbHVlLnRvU3RyaW5nKCksIGZvcm1hdCQxKSkgJiYgZm9ybWF0KHBhcnNlRGF0ZSQxKHZhbHVlLnRvU3RyaW5nKCksIGZvcm1hdCQxKSwgZm9ybWF0JDEpID09PSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGBcbiAqL1xuXG52YXIgZGVmaW5lZCA9IHJ1bGUoe1xuICBuYW1lOiAnZGVmaW5lZCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkXzEodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICovXG5cbnZhciBlbWFpbCA9IHJ1bGUoe1xuICBuYW1lOiAnZW1haWwnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzRW1haWwodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkuXG4gKlxuICogQHNlZSBodHRwczovL2xvZGFzaC5jb20vZG9jcy8jaXNFbXB0eVxuICovXG5cbnZhciBlbXB0eSA9IHJ1bGUoe1xuICBuYW1lOiAnZW1wdHknLFxuICB0ZXN0OiBpc0VtcHR5XzFcbn0pO1xuLyoqXG4gKiBBbGlhcyBmb3IgYGVxdWFsc2BcbiAqL1xuXG52YXIgZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChvdGhlcikge1xuICByZXR1cm4gZXF1YWxzKG90aGVyKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGVxdWFscyB0aGUgZ2l2ZW4gdmFsdWUuXG4gKi9cblxudmFyIGVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2VxdWFscycsXG4gICAgZGF0YToge1xuICAgICAgb3RoZXI6IG90aGVyXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNFcXVhbF8xKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBhIGdpdmVuIG1pbmltdW0uXG4gKi9cblxudmFyIGd0JDEgPSBmdW5jdGlvbiBndChtaW4pIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdndCcsXG4gICAgZGF0YToge1xuICAgICAgbWluOiBtaW5cbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBndF8xKHZhbHVlLCBtaW4pO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYSBnaXZlbiBtaW5pbXVtLlxuICovXG5cbnZhciBndGUkMSA9IGZ1bmN0aW9uIGd0ZShtaW4pIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdndGUnLFxuICAgIGRhdGE6IHtcbiAgICAgIG1pbjogbWluXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ3RlXzEodmFsdWUsIG1pbik7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cblxudmFyIGludGVnZXIgPSBydWxlKHtcbiAgbmFtZTogJ2ludGVnZXInLFxuICB0ZXN0OiBpc0ludGVnZXJfMVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgSVAgYWRkcmVzcy5cbiAqL1xuXG52YXIgaXAgPSBydWxlKHtcbiAgbmFtZTogJ2lwJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0lQKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgemVyby1sZW5ndGggc3RyaW5nLlxuICovXG5cbnZhciBpc2JsYW5rID0gcnVsZSh7XG4gIG5hbWU6ICdpc2JsYW5rJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJyc7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKi9cblxudmFyIGlzbmlsID0gcnVsZSh7XG4gIG5hbWU6ICdpc25pbCcsXG4gIHRlc3Q6IGlzTmlsXzFcbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBgbnVsbGAuXG4gKi9cblxudmFyIGlzbnVsbCA9IHJ1bGUoe1xuICBuYW1lOiAnaXNudWxsJyxcbiAgdGVzdDogaXNOdWxsXzFcbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIElTTzg2MDEgZGF0ZSBzdHJpbmcuXG4gKi9cblxudmFyIGlzbzg2MDEgPSBydWxlKHtcbiAgbmFtZTogJ2lzbzg2MDEnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzSVNPODYwMSh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyB2YWxpZCBKU09OLlxuICovXG5cbnZhciBqc29uID0gcnVsZSh7XG4gIG5hbWU6ICdqc29uJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0pTT04odmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUncyBsZW5ndGggaXMgYXQgbGVhc3QgYSBnaXZlbiBtaW5pbXVtLCBhbmQgbm8gbW9yZSB0aGFuIGFuXG4gKiBvcHRpb25hbCBtYXhpbXVtLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvI3RvTGVuZ3RoXG4gKi9cblxudmFyIGxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChtaW4sIG1heCkge1xuICAvLyBObyBtYXhpbXVtIG1lYW5zIHRoZSB2YWx1ZSBtdXN0IGJlICphdCBsZWFzdCogdGhlIG1pbmltdW0uXG4gIGlmIChpc1VuZGVmaW5lZF8xKG1heCkpIHtcbiAgICByZXR1cm4gcnVsZSh7XG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4XG4gICAgICB9LFxuICAgICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2l6ZV8xKHZhbHVlKSA+PSBtaW47XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gTWluaW11bSBhbmQgbWF4aW11bSBnaXZlbiwgc28gY2hlY2sgdGhhdCB0aGUgdmFsdWUgaXMgd2l0aGluIHRoZSByYW5nZS5cblxuXG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnbGVuZ3RoX2JldHdlZW4nLFxuICAgIGRhdGE6IHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzaXplXzEodmFsdWUpO1xuICAgICAgcmV0dXJuIGxlbmd0aCA+PSBtaW4gJiYgbGVuZ3RoIDw9IG1heDtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgbGVzcyB0aGFuIGEgZ2l2ZW4gbWF4aW11bS5cbiAqL1xuXG52YXIgbHQkMSA9IGZ1bmN0aW9uIGx0KG1heCkge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2x0JyxcbiAgICBkYXRhOiB7XG4gICAgICBtYXg6IG1heFxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGx0XzEodmFsdWUsIG1heCk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhIGdpdmVuIG1heGltdW0uXG4gKi9cblxudmFyIGx0ZSQxID0gZnVuY3Rpb24gbHRlKG1heCkge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2x0ZScsXG4gICAgZGF0YToge1xuICAgICAgbWF4OiBtYXhcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBsdGVfMSh2YWx1ZSwgbWF4KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgb3IgUmVnRXhwLlxuICovXG5cbnZhciBtYXRjaCQxID0gZnVuY3Rpb24gbWF0Y2gocGF0dGVybikge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ21hdGNoJyxcbiAgICBkYXRhOiB7XG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuKS50ZXN0KHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQWxpYXMgZm9yIGBsdGVgLlxuICovXG5cbnZhciBtYXggPSBmdW5jdGlvbiBtYXgoX21heDIpIHtcbiAgcmV0dXJuIGx0ZSQxKF9tYXgyKTtcbn07XG4vKipcbiAqIEFsaWFzIGZvciBgZ3RlYC5cbiAqL1xuXG52YXIgbWluID0gZnVuY3Rpb24gbWluKF9taW4yKSB7XG4gIHJldHVybiBndGUkMShfbWluMik7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAqL1xuXG52YXIgbmVnYXRpdmUgPSBydWxlKHtcbiAgbmFtZTogJ25lZ2F0aXZlJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiB0b051bWJlcl8xKHZhbHVlKSA8IDA7XG4gIH1cbn0pO1xuLyoqXG4gKlxuICovXG5cbnZhciBub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdub3QnLFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiAhaW5jbHVkZXNfMSh2YWx1ZXMsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpLCBleGNsdWRpbmcgYE5hTmAuXG4gKi9cblxudmFyIG51bWJlciA9IHJ1bGUoe1xuICBuYW1lOiAnbnVtYmVyJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBfaXNGaW5pdGUodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIgb3IgbnVtZXJpYyBzdHJpbmcsIGV4Y2x1ZGluZyBgTmFOYC5cbiAqL1xuXG52YXIgbnVtZXJpYyA9IHJ1bGUoe1xuICBuYW1lOiAnbnVtZXJpYycsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJfMSh2YWx1ZSkgJiYgIV9pc05hTih2YWx1ZSkgfHwgdmFsdWUgJiYgaXNTdHJpbmdfMSh2YWx1ZSkgJiYgIV9pc05hTih0b051bWJlcl8xKHZhbHVlKSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBvYmplY3QsIGV4Y2x1ZGluZyBhcnJheXMgYW5kIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgb2JqZWN0ID0gcnVsZSh7XG4gIG5hbWU6ICdvYmplY3QnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0XzEodmFsdWUpICYmICFpc0FycmF5XzEodmFsdWUpICYmICFpc0Z1bmN0aW9uXzEodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgcG9zaXRpdmUuXG4gKi9cblxudmFyIHBvc2l0aXZlID0gcnVsZSh7XG4gIG5hbWU6ICdwb3NpdGl2ZScsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdG9OdW1iZXJfMSh2YWx1ZSkgPiAwO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgcHJlc2VudCwgaWUuIG5vdCBgbnVsbGAsIGB1bmRlZmluZWRgLCBvciBhIGJsYW5rIHN0cmluZy5cbiAqL1xuXG52YXIgcmVxdWlyZWQgPSBydWxlKHtcbiAgbmFtZTogJ3JlcXVpcmVkJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiAhKGlzTmlsXzEodmFsdWUpIHx8IHZhbHVlID09PSAnJyk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBlcXVhbHMgYW5vdGhlciBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAqL1xuXG52YXIgc2FtZSA9IGZ1bmN0aW9uIHNhbWUob3RoZXIpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdzYW1lJyxcbiAgICBkYXRhOiB7XG4gICAgICBvdGhlcjogb3RoZXJcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUsIGF0dHJpYnV0ZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBpc0VxdWFsXzEodmFsdWUsIG1vZGVsLmdldChvdGhlcikpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuXG52YXIgc3RyaW5nID0gcnVsZSh7XG4gIG5hbWU6ICdzdHJpbmcnLFxuICB0ZXN0OiBpc1N0cmluZ18xXG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBVUkwgc3RyaW5nLlxuICovXG5cbnZhciB1cmwgPSBydWxlKHtcbiAgbmFtZTogJ3VybCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNVUkwodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBVVUlELlxuICovXG5cbnZhciB1dWlkID0gcnVsZSh7XG4gIG5hbWU6ICd1dWlkJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc1VVSUQodmFsdWUpO1xuICB9XG59KTtcblxuZXhwb3J0cy5hZnRlciA9IGFmdGVyO1xuZXhwb3J0cy5hbHBoYSA9IGFscGhhO1xuZXhwb3J0cy5hbHBoYW51bWVyaWMgPSBhbHBoYW51bWVyaWM7XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5leHBvcnRzLmFzY2lpID0gYXNjaWk7XG5leHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcbmV4cG9ydHMuYmVmb3JlID0gYmVmb3JlO1xuZXhwb3J0cy5iZXR3ZWVuID0gYmV0d2VlbjtcbmV4cG9ydHMuYm9vbGVhbiA9IF9ib29sZWFuO1xuZXhwb3J0cy5jcmVkaXRjYXJkID0gY3JlZGl0Y2FyZDtcbmV4cG9ydHMuZGF0ZSA9IGRhdGU7XG5leHBvcnRzLmRhdGVmb3JtYXQgPSBkYXRlZm9ybWF0O1xuZXhwb3J0cy5kZWZpbmVkID0gZGVmaW5lZDtcbmV4cG9ydHMuZW1haWwgPSBlbWFpbDtcbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmV4cG9ydHMuZXF1YWwgPSBlcXVhbDtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5ndCA9IGd0JDE7XG5leHBvcnRzLmd0ZSA9IGd0ZSQxO1xuZXhwb3J0cy5pbnRlZ2VyID0gaW50ZWdlcjtcbmV4cG9ydHMuaXAgPSBpcDtcbmV4cG9ydHMuaXNibGFuayA9IGlzYmxhbms7XG5leHBvcnRzLmlzbmlsID0gaXNuaWw7XG5leHBvcnRzLmlzbnVsbCA9IGlzbnVsbDtcbmV4cG9ydHMuaXNvODYwMSA9IGlzbzg2MDE7XG5leHBvcnRzLmpzb24gPSBqc29uO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmx0ID0gbHQkMTtcbmV4cG9ydHMubHRlID0gbHRlJDE7XG5leHBvcnRzLm1hdGNoID0gbWF0Y2gkMTtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm5lZ2F0aXZlID0gbmVnYXRpdmU7XG5leHBvcnRzLm5vdCA9IG5vdDtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5udW1lcmljID0gbnVtZXJpYztcbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuZXhwb3J0cy5wb3NpdGl2ZSA9IHBvc2l0aXZlO1xuZXhwb3J0cy5yZXF1aXJlZCA9IHJlcXVpcmVkO1xuZXhwb3J0cy5ydWxlID0gcnVsZTtcbmV4cG9ydHMuc2FtZSA9IHNhbWU7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmV4cG9ydHMudXJsID0gdXJsO1xuZXhwb3J0cy51dWlkID0gdXVpZDtcbiIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsXSwibmFtZXMiOlsiTW9kZWwiLCJ0b051bWJlciIsIkNvbGxlY3Rpb24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImVuX3VzIiwibG9jYWxlIiwibWVzc2FnZXMiLCJhZnRlciIsImFscGhhIiwiYWxwaGFudW1lcmljIiwiYXJyYXkiLCJhc2NpaSIsImJhc2U2NCIsImJlZm9yZSIsImJldHdlZW4iLCJiZXR3ZWVuX2luY2x1c2l2ZSIsImNyZWRpdGNhcmQiLCJkYXRlIiwiZGF0ZWZvcm1hdCIsImRlZmluZWQiLCJlbWFpbCIsImVtcHR5IiwiZXF1YWxzIiwiZ3QiLCJndGUiLCJpbnRlZ2VyIiwiaXAiLCJpc2JsYW5rIiwiaXNuaWwiLCJpc251bGwiLCJpc284NjAxIiwianNvbiIsImxlbmd0aF9iZXR3ZWVuIiwibHQiLCJsdGUiLCJtYXRjaCIsIm5lZ2F0aXZlIiwibm90IiwibnVtYmVyIiwibnVtZXJpYyIsIm9iamVjdCIsInBvc2l0aXZlIiwicmVxdWlyZWQiLCJzYW1lIiwic3RyaW5nIiwidXJsIiwidXVpZCIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJ1bndyYXBFeHBvcnRzIiwieCIsIl9fZXNNb2R1bGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsImZuIiwibW9kdWxlIiwiZXhwb3J0cyIsImFzc2VydFN0cmluZ18xIiwiYXNzZXJ0U3RyaW5nIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIl90eXBlb2YyIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsImlucHV0IiwiaXNTdHJpbmciLCJTdHJpbmciLCJpbnZhbGlkVHlwZSIsIm5hbWUiLCJjb25jYXQiLCJhbHBoYV8xIiwiY29tbWFEZWNpbWFsIiwiZG90RGVjaW1hbCIsImFyYWJpY0xvY2FsZXMiLCJlbmdsaXNoTG9jYWxlcyIsImRlY2ltYWwiLCJhciIsIl9sb2NhbGUiLCJfaSIsIl9pMiIsIl9pMyIsImlzQWxwaGFfMSIsImlzQWxwaGEiLCJsb2NhbGVzIiwiX2Fzc2VydFN0cmluZyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJzdHIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ0ZXN0IiwiRXJyb3IiLCJrZXlzIiwiaXNBbHBoYW51bWVyaWNfMSIsImlzQWxwaGFudW1lcmljIiwiaXNCYXNlNjRfMSIsImlzQmFzZTY0Iiwibm90QmFzZTY0IiwibGVuIiwiZmlyc3RQYWRkaW5nQ2hhciIsImluZGV4T2YiLCJpc0NyZWRpdENhcmRfMSIsImlzQ3JlZGl0Q2FyZCIsImNyZWRpdENhcmQiLCJzYW5pdGl6ZWQiLCJyZXBsYWNlIiwic3VtIiwiZGlnaXQiLCJ0bXBOdW0iLCJzaG91bGREb3VibGUiLCJzdWJzdHJpbmciLCJwYXJzZUludCIsIm1lcmdlXzEiLCJtZXJnZSIsImRlZmF1bHRzIiwiaXNCeXRlTGVuZ3RoXzEiLCJpc0J5dGVMZW5ndGgiLCJvcHRpb25zIiwibWluIiwibWF4IiwiZW5jb2RlVVJJIiwic3BsaXQiLCJpc0ZRRE5fMSIsImlzRlFETiIsIl9tZXJnZSIsImRlZmF1bHRfZnFkbl9vcHRpb25zIiwicmVxdWlyZV90bGQiLCJhbGxvd191bmRlcnNjb3JlcyIsImFsbG93X3RyYWlsaW5nX2RvdCIsInBhcnRzIiwidGxkIiwicG9wIiwicGFydCIsImlzSVBfMSIsImlzSVAiLCJpcHY0TWF5YmUiLCJpcHY2QmxvY2siLCJ2ZXJzaW9uIiwic29ydCIsImEiLCJiIiwiYmxvY2tzIiwiZm91bmRPbWlzc2lvbkJsb2NrIiwiZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrIiwiZXhwZWN0ZWROdW1iZXJPZkJsb2NrcyIsInN1YnN0ciIsInNoaWZ0IiwiaXNFbWFpbF8xIiwiaXNFbWFpbCIsIl9pc0J5dGVMZW5ndGgiLCJfaXNGUUROIiwiX2lzSVAiLCJkZWZhdWx0X2VtYWlsX29wdGlvbnMiLCJhbGxvd19kaXNwbGF5X25hbWUiLCJyZXF1aXJlX2Rpc3BsYXlfbmFtZSIsImFsbG93X3V0ZjhfbG9jYWxfcGFydCIsImRpc3BsYXlOYW1lIiwiZW1haWxVc2VyUGFydCIsImdtYWlsVXNlclBhcnQiLCJxdW90ZWRFbWFpbFVzZXIiLCJlbWFpbFVzZXJVdGY4UGFydCIsInF1b3RlZEVtYWlsVXNlclV0ZjgiLCJkaXNwbGF5X2VtYWlsIiwiZG9tYWluIiwidXNlciIsImpvaW4iLCJsb3dlcl9kb21haW4iLCJ0b0xvd2VyQ2FzZSIsImRvbWFpbl9zcGVjaWZpY192YWxpZGF0aW9uIiwidXNlcm5hbWUiLCJfdXNlcl9wYXJ0cyIsImFsbG93X2lwX2RvbWFpbiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsIm5vQnJhY2tldGRvbWFpbiIsInNsaWNlIiwicGF0dGVybiIsInVzZXJfcGFydHMiLCJpc0lTTzg2MDFfMSIsImlzSVNPODYwMSIsImlzVmFsaWREYXRlIiwib3JkaW5hbE1hdGNoIiwib1llYXIiLCJOdW1iZXIiLCJvRGF5IiwibWFwIiwieWVhciIsIm1vbnRoIiwiZGF5IiwibW9udGhTdHJpbmciLCJkYXlTdHJpbmciLCJkIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJjaGVjayIsInN0cmljdCIsImlzSlNPTl8xIiwiaXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZSIsImlzVVJMXzEiLCJpc1VSTCIsImRlZmF1bHRfdXJsX29wdGlvbnMiLCJwcm90b2NvbHMiLCJyZXF1aXJlX3Byb3RvY29sIiwicmVxdWlyZV9ob3N0IiwicmVxdWlyZV92YWxpZF9wcm90b2NvbCIsImFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMiLCJ3cmFwcGVkX2lwdjYiLCJpc1JlZ0V4cCIsInRvU3RyaW5nIiwiY2hlY2tIb3N0IiwiaG9zdCIsIm1hdGNoZXMiLCJwcm90b2NvbCIsImF1dGgiLCJob3N0bmFtZSIsInBvcnQiLCJwb3J0X3N0ciIsImlwdjYiLCJkaXNhbGxvd19hdXRoIiwiaXB2Nl9tYXRjaCIsImhvc3Rfd2hpdGVsaXN0IiwiaG9zdF9ibGFja2xpc3QiLCJpc1VVSURfMSIsImlzVVVJRCIsImFsbCIsImZyZWVHbG9iYWwiLCJfZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiX3Jvb3QiLCJTeW1ib2wkMSIsIl9TeW1ib2wiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJfZ2V0UmF3VGFnIiwib2JqZWN0UHJvdG8kMSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nJDEiLCJvYmplY3RUb1N0cmluZyIsIl9vYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyQxIiwiYmFzZUdldFRhZyIsIl9iYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJ0eXBlIiwiaXNPYmplY3RfMSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImlzRnVuY3Rpb25fMSIsImNvcmVKc0RhdGEiLCJfY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsImZ1bmMiLCJfaXNNYXNrZWQiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsIl90b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byQxIiwib2JqZWN0UHJvdG8kMiIsImZ1bmNUb1N0cmluZyQxIiwiaGFzT3duUHJvcGVydHkkMSIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJiYXNlSXNOYXRpdmUiLCJfYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJfZ2V0VmFsdWUiLCJnZXROYXRpdmUiLCJfZ2V0TmF0aXZlIiwiX2RlZmluZVByb3BlcnR5IiwiYmFzZUFzc2lnblZhbHVlIiwiX2Jhc2VBc3NpZ25WYWx1ZSIsImVxIiwib3RoZXIiLCJlcV8xIiwib2JqZWN0UHJvdG8kMyIsImhhc093blByb3BlcnR5JDIiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiX2Fzc2lnblZhbHVlIiwiY29weU9iamVjdCIsInNvdXJjZSIsImN1c3RvbWl6ZXIiLCJpc05ldyIsImluZGV4IiwibmV3VmFsdWUiLCJfY29weU9iamVjdCIsImlkZW50aXR5IiwiaWRlbnRpdHlfMSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ3MiLCJfYXBwbHkiLCJuYXRpdmVNYXgiLCJNYXRoIiwib3ZlclJlc3QiLCJzdGFydCIsInRyYW5zZm9ybSIsIkFycmF5Iiwib3RoZXJBcmdzIiwiX292ZXJSZXN0IiwiY29uc3RhbnQiLCJjb25zdGFudF8xIiwiYmFzZVNldFRvU3RyaW5nIiwiX2Jhc2VTZXRUb1N0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93Iiwibm93Iiwic2hvcnRPdXQiLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsIl9zaG9ydE91dCIsInNldFRvU3RyaW5nIiwiX3NldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJfYmFzZVJlc3QiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNMZW5ndGgiLCJpc0xlbmd0aF8xIiwiaXNBcnJheUxpa2UiLCJpc0FycmF5TGlrZV8xIiwiTUFYX1NBRkVfSU5URUdFUiQxIiwicmVJc1VpbnQiLCJpc0luZGV4IiwiX2lzSW5kZXgiLCJpc0l0ZXJhdGVlQ2FsbCIsIl9pc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJfY3JlYXRlQXNzaWduZXIiLCJvYmplY3RQcm90byQ0IiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJfaXNQcm90b3R5cGUiLCJiYXNlVGltZXMiLCJuIiwiaXRlcmF0ZWUiLCJfYmFzZVRpbWVzIiwiaXNPYmplY3RMaWtlIiwiaXNPYmplY3RMaWtlXzEiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwiX2Jhc2VJc0FyZ3VtZW50cyIsIm9iamVjdFByb3RvJDUiLCJoYXNPd25Qcm9wZXJ0eSQzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImlzQXJndW1lbnRzXzEiLCJpc0FycmF5IiwiaXNBcnJheV8xIiwic3R1YkZhbHNlIiwic3R1YkZhbHNlXzEiLCJpc0J1ZmZlcl8xIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImFyZ3NUYWckMSIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWckMSIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiX2Jhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJfYmFzZVVuYXJ5IiwiX25vZGVVdGlsIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheV8xIiwib2JqZWN0UHJvdG8kNiIsImhhc093blByb3BlcnR5JDQiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwicHVzaCIsIl9hcnJheUxpa2VLZXlzIiwib3ZlckFyZyIsImFyZyIsIl9vdmVyQXJnIiwibmF0aXZlS2V5cyIsIl9uYXRpdmVLZXlzIiwib2JqZWN0UHJvdG8kNyIsImhhc093blByb3BlcnR5JDUiLCJiYXNlS2V5cyIsIl9iYXNlS2V5cyIsImtleXNfMSIsIm9iamVjdFByb3RvJDgiLCJoYXNPd25Qcm9wZXJ0eSQ2IiwiYXNzaWduIiwiYXNzaWduXzEiLCJhcnJheVB1c2giLCJ2YWx1ZXMiLCJvZmZzZXQiLCJfYXJyYXlQdXNoIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsImlzRmxhdHRlbmFibGUiLCJfaXNGbGF0dGVuYWJsZSIsImJhc2VGbGF0dGVuIiwiZGVwdGgiLCJwcmVkaWNhdGUiLCJpc1N0cmljdCIsIl9iYXNlRmxhdHRlbiIsImNvcHlBcnJheSIsIl9jb3B5QXJyYXkiLCJjb25jYXRfMSIsImJhc2VQcm9wZXJ0eU9mIiwiX2Jhc2VQcm9wZXJ0eU9mIiwiZGVidXJyZWRMZXR0ZXJzIiwiZGVidXJyTGV0dGVyIiwiX2RlYnVyckxldHRlciIsImFycmF5TWFwIiwiX2FycmF5TWFwIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJpc1N5bWJvbF8xIiwiSU5GSU5JVFkiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwiX2Jhc2VUb1N0cmluZyIsInRvU3RyaW5nXzEiLCJyZUxhdGluIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNDb21ibyIsInJlQ29tYm9NYXJrIiwiZGVidXJyIiwiZGVidXJyXzEiLCJhcnJheUVhY2giLCJfYXJyYXlFYWNoIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJfY3JlYXRlQmFzZUZvciIsImJhc2VGb3IiLCJfYmFzZUZvciIsImJhc2VGb3JPd24iLCJfYmFzZUZvck93biIsImNyZWF0ZUJhc2VFYWNoIiwiZWFjaEZ1bmMiLCJjb2xsZWN0aW9uIiwiX2NyZWF0ZUJhc2VFYWNoIiwiYmFzZUVhY2giLCJfYmFzZUVhY2giLCJjYXN0RnVuY3Rpb24iLCJfY2FzdEZ1bmN0aW9uIiwiZm9yRWFjaCIsImZvckVhY2hfMSIsImVhY2giLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiaXNLZXkiLCJfaXNLZXkiLCJuYXRpdmVDcmVhdGUiLCJfbmF0aXZlQ3JlYXRlIiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJzaXplIiwiX2hhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXMiLCJfaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEIiwib2JqZWN0UHJvdG8kOSIsImhhc093blByb3BlcnR5JDciLCJoYXNoR2V0IiwiZGF0YSIsIl9oYXNoR2V0Iiwib2JqZWN0UHJvdG8kYSIsImhhc093blByb3BlcnR5JDgiLCJoYXNoSGFzIiwiX2hhc2hIYXMiLCJIQVNIX1VOREVGSU5FRCQxIiwiaGFzaFNldCIsIl9oYXNoU2V0IiwiSGFzaCIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwiZ2V0IiwiX0hhc2giLCJsaXN0Q2FjaGVDbGVhciIsIl9saXN0Q2FjaGVDbGVhciIsImFzc29jSW5kZXhPZiIsIl9hc3NvY0luZGV4T2YiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGlzdENhY2hlRGVsZXRlIiwibGFzdEluZGV4IiwiX2xpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsIl9saXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJfbGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiX2xpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIl9MaXN0Q2FjaGUiLCJNYXAiLCJfTWFwIiwibWFwQ2FjaGVDbGVhciIsIl9tYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiX2lzS2V5YWJsZSIsImdldE1hcERhdGEiLCJfZ2V0TWFwRGF0YSIsIm1hcENhY2hlRGVsZXRlIiwiX21hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJfbWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIl9tYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiX21hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJfTWFwQ2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsImNhY2hlIiwiQ2FjaGUiLCJtZW1vaXplXzEiLCJNQVhfTUVNT0laRV9TSVpFIiwibWVtb2l6ZUNhcHBlZCIsIl9tZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImNoYXJDb2RlQXQiLCJxdW90ZSIsInN1YlN0cmluZyIsIl9zdHJpbmdUb1BhdGgiLCJjYXN0UGF0aCIsIl9jYXN0UGF0aCIsIklORklOSVRZJDEiLCJ0b0tleSIsIl90b0tleSIsImJhc2VHZXQiLCJwYXRoIiwiX2Jhc2VHZXQiLCJkZWZhdWx0VmFsdWUiLCJnZXRfMSIsImJhc2VHdCIsIl9iYXNlR3QiLCJOQU4iLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsInZhbHVlT2YiLCJpc0JpbmFyeSIsInRvTnVtYmVyXzEiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwib3BlcmF0b3IiLCJfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsImd0XzEiLCJndGVfMSIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJfYmFzZUZpbmRJbmRleCIsImJhc2VJc05hTiIsIl9iYXNlSXNOYU4iLCJzdHJpY3RJbmRleE9mIiwiX3N0cmljdEluZGV4T2YiLCJiYXNlSW5kZXhPZiIsIl9iYXNlSW5kZXhPZiIsInN0cmluZ1RhZyQxIiwiaXNTdHJpbmdfMSIsIklORklOSVRZJDIiLCJNQVhfSU5URUdFUiIsInRvRmluaXRlIiwic2lnbiIsInRvRmluaXRlXzEiLCJ0b0ludGVnZXIiLCJyZW1haW5kZXIiLCJ0b0ludGVnZXJfMSIsImJhc2VWYWx1ZXMiLCJfYmFzZVZhbHVlcyIsInZhbHVlc18xIiwibmF0aXZlTWF4JDEiLCJpbmNsdWRlcyIsImluY2x1ZGVzXzEiLCJib29sVGFnJDEiLCJpc0Jvb2xlYW4iLCJpc0Jvb2xlYW5fMSIsIkRhdGFWaWV3IiwiX0RhdGFWaWV3IiwiUHJvbWlzZSIsIl9Qcm9taXNlIiwiU2V0IiwiX1NldCIsIldlYWtNYXAiLCJfV2Vha01hcCIsIm1hcFRhZyQxIiwib2JqZWN0VGFnJDEiLCJwcm9taXNlVGFnIiwic2V0VGFnJDEiLCJ3ZWFrTWFwVGFnJDEiLCJkYXRhVmlld1RhZyQxIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnIiwiQXJyYXlCdWZmZXIiLCJyZXNvbHZlIiwiY3RvclN0cmluZyIsIl9nZXRUYWciLCJtYXBUYWckMiIsInNldFRhZyQyIiwib2JqZWN0UHJvdG8kYiIsImhhc093blByb3BlcnR5JDkiLCJpc0VtcHR5IiwiaXNFbXB0eV8xIiwic3RhY2tDbGVhciIsIl9zdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJfc3RhY2tEZWxldGUiLCJzdGFja0dldCIsIl9zdGFja0dldCIsInN0YWNrSGFzIiwiX3N0YWNrSGFzIiwiTEFSR0VfQVJSQVlfU0laRSIsInN0YWNrU2V0IiwicGFpcnMiLCJfc3RhY2tTZXQiLCJTdGFjayIsIl9TdGFjayIsIkhBU0hfVU5ERUZJTkVEJDIiLCJzZXRDYWNoZUFkZCIsIl9zZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiX3NldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhZGQiLCJfU2V0Q2FjaGUiLCJhcnJheVNvbWUiLCJfYXJyYXlTb21lIiwiY2FjaGVIYXMiLCJfY2FjaGVIYXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImJpdG1hc2siLCJlcXVhbEZ1bmMiLCJzdGFjayIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJfZXF1YWxBcnJheXMiLCJVaW50OEFycmF5IiwiX1VpbnQ4QXJyYXkiLCJtYXBUb0FycmF5IiwiX21hcFRvQXJyYXkiLCJzZXRUb0FycmF5IiwiX3NldFRvQXJyYXkiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyQxIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyQxIiwiYm9vbFRhZyQyIiwiZGF0ZVRhZyQxIiwiZXJyb3JUYWckMSIsIm1hcFRhZyQzIiwibnVtYmVyVGFnJDEiLCJyZWdleHBUYWckMSIsInNldFRhZyQzIiwic3RyaW5nVGFnJDIiLCJzeW1ib2xUYWckMSIsImFycmF5QnVmZmVyVGFnJDEiLCJkYXRhVmlld1RhZyQyIiwic3ltYm9sUHJvdG8kMSIsInN5bWJvbFZhbHVlT2YiLCJlcXVhbEJ5VGFnIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJtZXNzYWdlIiwiY29udmVydCIsIl9lcXVhbEJ5VGFnIiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsIl9iYXNlR2V0QWxsS2V5cyIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJfYXJyYXlGaWx0ZXIiLCJzdHViQXJyYXkiLCJzdHViQXJyYXlfMSIsIm9iamVjdFByb3RvJGMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSQxIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFN5bWJvbHMiLCJzeW1ib2wiLCJfZ2V0U3ltYm9scyIsImdldEFsbEtleXMiLCJfZ2V0QWxsS2V5cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDIiLCJvYmplY3RQcm90byRkIiwiaGFzT3duUHJvcGVydHkkYSIsImVxdWFsT2JqZWN0cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiX2VxdWFsT2JqZWN0cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDMiLCJhcmdzVGFnJDIiLCJhcnJheVRhZyQxIiwib2JqZWN0VGFnJDIiLCJvYmplY3RQcm90byRlIiwiaGFzT3duUHJvcGVydHkkYiIsImJhc2VJc0VxdWFsRGVlcCIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiX2Jhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwiX2Jhc2VJc0VxdWFsIiwiaXNFcXVhbCIsImlzRXF1YWxfMSIsIm5hdGl2ZUlzRmluaXRlIiwiaXNGaW5pdGUiLCJfaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0ludGVnZXJfMSIsIm51bWJlclRhZyQyIiwiaXNOdW1iZXIiLCJpc051bWJlcl8xIiwiaXNOYU4kMSIsIl9pc05hTiIsImlzTmlsIiwiaXNOaWxfMSIsImlzTnVsbCIsImlzTnVsbF8xIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZF8xIiwiYmFzZUx0IiwiX2Jhc2VMdCIsImx0XzEiLCJsdGVfMSIsImJhc2VTZXQiLCJuZXN0ZWQiLCJfYmFzZVNldCIsImJhc2VQaWNrQnkiLCJwYXRocyIsIl9iYXNlUGlja0J5IiwiYmFzZUhhc0luIiwiX2Jhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiX2hhc1BhdGgiLCJoYXNJbiIsImhhc0luXzEiLCJiYXNlUGljayIsIl9iYXNlUGljayIsImZsYXR0ZW4iLCJmbGF0dGVuXzEiLCJmbGF0UmVzdCIsIl9mbGF0UmVzdCIsInBpY2siLCJwaWNrXzEiLCJzZXRfMSIsImJhc2VQcm9wZXJ0eSIsIl9iYXNlUHJvcGVydHkiLCJhc2NpaVNpemUiLCJfYXNjaWlTaXplIiwicnNBc3RyYWxSYW5nZSIsInJzQ29tYm9NYXJrc1JhbmdlJDEiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMSIsInJzQ29tYm9SYW5nZSQxIiwicnNWYXJSYW5nZSIsInJzWldKIiwicmVIYXNVbmljb2RlIiwiaGFzVW5pY29kZSIsIl9oYXNVbmljb2RlIiwicnNBc3RyYWxSYW5nZSQxIiwicnNDb21ib01hcmtzUmFuZ2UkMiIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQyIiwicnNDb21ib1N5bWJvbHNSYW5nZSQyIiwicnNDb21ib1JhbmdlJDIiLCJyc1ZhclJhbmdlJDEiLCJyc0FzdHJhbCIsInJzQ29tYm8kMSIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNaV0okMSIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwidW5pY29kZVNpemUiLCJfdW5pY29kZVNpemUiLCJzdHJpbmdTaXplIiwiX3N0cmluZ1NpemUiLCJtYXBUYWckNCIsInNldFRhZyQ0Iiwic2l6ZV8xIiwiYmFzZVNsaWNlIiwiZW5kIiwiX2Jhc2VTbGljZSIsImNhc3RTbGljZSIsIl9jYXN0U2xpY2UiLCJyZWdleHBUYWckMiIsImJhc2VJc1JlZ0V4cCIsIl9iYXNlSXNSZWdFeHAiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cF8xIiwiYXNjaWlUb0FycmF5IiwiX2FzY2lpVG9BcnJheSIsInJzQXN0cmFsUmFuZ2UkMiIsInJzQ29tYm9NYXJrc1JhbmdlJDMiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMyIsInJzQ29tYm9SYW5nZSQzIiwicnNWYXJSYW5nZSQyIiwicnNBc3RyYWwkMSIsInJzQ29tYm8kMiIsInJzRml0eiQxIiwicnNNb2RpZmllciQxIiwicnNOb25Bc3RyYWwkMSIsInJzUmVnaW9uYWwkMSIsInJzU3VyclBhaXIkMSIsInJzWldKJDIiLCJyZU9wdE1vZCQxIiwicnNPcHRWYXIkMSIsInJzT3B0Sm9pbiQxIiwicnNTZXEkMSIsInJzU3ltYm9sJDEiLCJyZVVuaWNvZGUkMSIsInVuaWNvZGVUb0FycmF5IiwiX3VuaWNvZGVUb0FycmF5Iiwic3RyaW5nVG9BcnJheSIsIl9zdHJpbmdUb0FycmF5IiwiTUFYX0FSUkFZX0xFTkdUSCIsInNlcGFyYXRvciIsImxpbWl0Iiwic3BsaXRfMSIsInN0dWJUcnVlIiwic3R1YlRydWVfMSIsIm5hdGl2ZUtleXNJbiIsIl9uYXRpdmVLZXlzSW4iLCJvYmplY3RQcm90byRmIiwiaGFzT3duUHJvcGVydHkkYyIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwiX2Jhc2VLZXlzSW4iLCJrZXlzSW4iLCJrZXlzSW5fMSIsImFzc2lnbkluV2l0aCIsInNyY0luZGV4IiwiYXNzaWduSW5XaXRoXzEiLCJnZXRQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGUiLCJvYmplY3RUYWckMyIsImZ1bmNQcm90byQyIiwib2JqZWN0UHJvdG8kZyIsImZ1bmNUb1N0cmluZyQyIiwiaGFzT3duUHJvcGVydHkkZCIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNQbGFpbk9iamVjdF8xIiwiZG9tRXhjVGFnIiwiZXJyb3JUYWckMiIsImlzRXJyb3IiLCJpc0Vycm9yXzEiLCJhdHRlbXB0IiwiYXR0ZW1wdF8xIiwib2JqZWN0UHJvdG8kaCIsImhhc093blByb3BlcnR5JGUiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwic3JjVmFsdWUiLCJfY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsInN0cmluZ0VzY2FwZXMiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiX2VzY2FwZVN0cmluZ0NoYXIiLCJyZUludGVycG9sYXRlIiwiX3JlSW50ZXJwb2xhdGUiLCJodG1sRXNjYXBlcyIsImVzY2FwZUh0bWxDaGFyIiwiX2VzY2FwZUh0bWxDaGFyIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwiZXNjYXBlIiwiX2VzY2FwZSIsInJlRXNjYXBlIiwiX3JlRXNjYXBlIiwicmVFdmFsdWF0ZSIsIl9yZUV2YWx1YXRlIiwidGVtcGxhdGVTZXR0aW5ncyIsInRlbXBsYXRlU2V0dGluZ3NfMSIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNUZW1wbGF0ZSIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwib2JqZWN0UHJvdG8kaSIsImhhc093blByb3BlcnR5JGYiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsIl8iLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJ2YXJpYWJsZSIsInRlbXBsYXRlXzEiLCJ0b0xvd2VyIiwidG9Mb3dlcl8xIiwidG9EYXRlIiwiYXJndW1lbnQiLCJhcmdTdHIiLCJnZXRUaW1lIiwiY29uc29sZSIsIndhcm4iLCJOYU4iLCJ0b0ludGVnZXIkMSIsImRpcnR5TnVtYmVyIiwiY2VpbCIsImZsb29yIiwiYWRkTWlsbGlzZWNvbmRzIiwiZGlydHlEYXRlIiwiZGlydHlBbW91bnQiLCJ0aW1lc3RhbXAiLCJhbW91bnQiLCJNSUxMSVNFQ09ORFNfSU5fTUlOVVRFIiwiZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyIsImJhc2VUaW1lem9uZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0U2Vjb25kcyIsIm1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0IiwiaXNWYWxpZCIsImZvcm1hdERpc3RhbmNlTG9jYWxlIiwibGVzc1RoYW5YU2Vjb25kcyIsIm9uZSIsInhTZWNvbmRzIiwiaGFsZkFNaW51dGUiLCJsZXNzVGhhblhNaW51dGVzIiwieE1pbnV0ZXMiLCJhYm91dFhIb3VycyIsInhIb3VycyIsInhEYXlzIiwiYWJvdXRYTW9udGhzIiwieE1vbnRocyIsImFib3V0WFllYXJzIiwieFllYXJzIiwib3ZlclhZZWFycyIsImFsbW9zdFhZZWFycyIsImZvcm1hdERpc3RhbmNlIiwidG9rZW4iLCJhZGRTdWZmaXgiLCJjb21wYXJpc29uIiwiYnVpbGRGb3JtYXRMb25nRm4iLCJkaXJ0eU9wdGlvbnMiLCJ3aWR0aCIsImRlZmF1bHRXaWR0aCIsImZvcm1hdCIsImZvcm1hdHMiLCJkYXRlRm9ybWF0cyIsImZ1bGwiLCJtZWRpdW0iLCJ0aW1lRm9ybWF0cyIsImRhdGVUaW1lRm9ybWF0cyIsImZvcm1hdExvbmciLCJ0aW1lIiwiZGF0ZVRpbWUiLCJmb3JtYXRSZWxhdGl2ZUxvY2FsZSIsImxhc3RXZWVrIiwieWVzdGVyZGF5IiwidG9kYXkiLCJ0b21vcnJvdyIsIm5leHRXZWVrIiwiZm9ybWF0UmVsYXRpdmUiLCJfZGF0ZSIsIl9iYXNlRGF0ZSIsIl9vcHRpb25zIiwiYnVpbGRMb2NhbGl6ZUZuIiwiZGlydHlJbmRleCIsImNvbnRleHQiLCJ2YWx1ZXNBcnJheSIsImZvcm1hdHRpbmdWYWx1ZXMiLCJkZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIiwiX2RlZmF1bHRXaWR0aCIsIl93aWR0aCIsImFyZ3VtZW50Q2FsbGJhY2siLCJlcmFWYWx1ZXMiLCJuYXJyb3ciLCJhYmJyZXZpYXRlZCIsIndpZGUiLCJxdWFydGVyVmFsdWVzIiwibW9udGhWYWx1ZXMiLCJkYXlWYWx1ZXMiLCJkYXlQZXJpb2RWYWx1ZXMiLCJhbSIsInBtIiwibWlkbmlnaHQiLCJub29uIiwibW9ybmluZyIsImFmdGVybm9vbiIsImV2ZW5pbmciLCJuaWdodCIsImZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMiLCJvcmRpbmFsTnVtYmVyIiwiX2RpcnR5T3B0aW9ucyIsInJlbTEwMCIsImxvY2FsaXplIiwiZXJhIiwicXVhcnRlciIsImRheVBlcmlvZCIsImJ1aWxkTWF0Y2hQYXR0ZXJuRm4iLCJkaXJ0eVN0cmluZyIsIm1hdGNoUmVzdWx0IiwibWF0Y2hQYXR0ZXJuIiwibWF0Y2hlZFN0cmluZyIsInBhcnNlUmVzdWx0IiwicGFyc2VQYXR0ZXJuIiwidmFsdWVDYWxsYmFjayIsInJlc3QiLCJidWlsZE1hdGNoRm4iLCJtYXRjaFBhdHRlcm5zIiwiZGVmYXVsdE1hdGNoV2lkdGgiLCJwYXJzZVBhdHRlcm5zIiwiZGVmYXVsdFBhcnNlV2lkdGgiLCJmaW5kSW5kZXgiLCJmaW5kS2V5IiwibWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiIsInBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4iLCJtYXRjaEVyYVBhdHRlcm5zIiwicGFyc2VFcmFQYXR0ZXJucyIsImFueSIsIm1hdGNoUXVhcnRlclBhdHRlcm5zIiwicGFyc2VRdWFydGVyUGF0dGVybnMiLCJtYXRjaE1vbnRoUGF0dGVybnMiLCJwYXJzZU1vbnRoUGF0dGVybnMiLCJtYXRjaERheVBhdHRlcm5zIiwicGFyc2VEYXlQYXR0ZXJucyIsIm1hdGNoRGF5UGVyaW9kUGF0dGVybnMiLCJwYXJzZURheVBlcmlvZFBhdHRlcm5zIiwid2Vla1N0YXJ0c09uIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIiwic3ViTWlsbGlzZWNvbmRzIiwiYWRkTGVhZGluZ1plcm9zIiwidGFyZ2V0TGVuZ3RoIiwib3V0cHV0IiwiYWJzIiwiZm9ybWF0dGVycyIsInkiLCJzaWduZWRZZWFyIiwiTSIsImRheVBlcmlvZEVudW1WYWx1ZSIsImdldFVUQ0hvdXJzIiwidG9VcHBlckNhc2UiLCJoIiwiSCIsIm0iLCJnZXRVVENNaW51dGVzIiwicyIsImdldFVUQ1NlY29uZHMiLCJTIiwibnVtYmVyT2ZEaWdpdHMiLCJtaWxsaXNlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJmcmFjdGlvbmFsU2Vjb25kcyIsInBvdyIsIk1JTExJU0VDT05EU19JTl9EQVkiLCJnZXRVVENEYXlPZlllYXIiLCJzZXRVVENNb250aCIsInNldFVUQ0hvdXJzIiwic3RhcnRPZlllYXJUaW1lc3RhbXAiLCJkaWZmZXJlbmNlIiwic3RhcnRPZlVUQ0lTT1dlZWsiLCJnZXRVVENEYXkiLCJkaWZmIiwic2V0VVRDRGF0ZSIsImdldFVUQ0lTT1dlZWtZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciIsInNldFVUQ0Z1bGxZZWFyIiwic3RhcnRPZk5leHRZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciIsInN0YXJ0T2ZUaGlzWWVhciIsInN0YXJ0T2ZVVENJU09XZWVrWWVhciIsImZvdXJ0aE9mSmFudWFyeSIsIk1JTExJU0VDT05EU19JTl9XRUVLIiwiZ2V0VVRDSVNPV2VlayIsInJvdW5kIiwic3RhcnRPZlVUQ1dlZWsiLCJsb2NhbGVXZWVrU3RhcnRzT24iLCJkZWZhdWx0V2Vla1N0YXJ0c09uIiwiUmFuZ2VFcnJvciIsImdldFVUQ1dlZWtZZWFyIiwibG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlIiwiZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSIsImZpcnN0V2Vla09mTmV4dFllYXIiLCJmaXJzdFdlZWtPZlRoaXNZZWFyIiwic3RhcnRPZlVUQ1dlZWtZZWFyIiwiZmlyc3RXZWVrIiwiTUlMTElTRUNPTkRTX0lOX1dFRUskMSIsImdldFVUQ1dlZWsiLCJkYXlQZXJpb2RFbnVtIiwiZm9ybWF0dGVycyQxIiwiRyIsInVuaXQiLCJZIiwic2lnbmVkV2Vla1llYXIiLCJ3ZWVrWWVhciIsInR3b0RpZ2l0WWVhciIsIlIiLCJpc29XZWVrWWVhciIsInUiLCJRIiwicSIsIkwiLCJ3Iiwid2VlayIsIkkiLCJpc29XZWVrIiwiRCIsImRheU9mWWVhciIsIkUiLCJkYXlPZldlZWsiLCJsb2NhbERheU9mV2VlayIsImMiLCJpc29EYXlPZldlZWsiLCJob3VycyIsIkIiLCJLIiwiayIsIlgiLCJfbG9jYWxpemUiLCJvcmlnaW5hbERhdGUiLCJfb3JpZ2luYWxEYXRlIiwidGltZXpvbmVPZmZzZXQiLCJmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXMiLCJmb3JtYXRUaW1lem9uZSIsIk8iLCJmb3JtYXRUaW1lem9uZVNob3J0IiwieiIsInQiLCJUIiwiZGlydHlEZWxpbWl0ZXIiLCJhYnNPZmZzZXQiLCJtaW51dGVzIiwiZGVsaW1pdGVyIiwiZGF0ZUxvbmdGb3JtYXR0ZXIiLCJ0aW1lTG9uZ0Zvcm1hdHRlciIsImRhdGVUaW1lTG9uZ0Zvcm1hdHRlciIsImRhdGVQYXR0ZXJuIiwidGltZVBhdHRlcm4iLCJkYXRlVGltZUZvcm1hdCIsImxvbmdGb3JtYXR0ZXJzIiwicCIsIlAiLCJwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMiLCJwcm90ZWN0ZWRXZWVrWWVhclRva2VucyIsImlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4iLCJpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4iLCJ0aHJvd1Byb3RlY3RlZEVycm9yIiwiZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCIsImxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwIiwiZXNjYXBlZFN0cmluZ1JlZ0V4cCIsImRvdWJsZVF1b3RlUmVnRXhwIiwidW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAiLCJkaXJ0eUZvcm1hdFN0ciIsImZvcm1hdFN0ciIsImxvY2FsZSQxIiwidXRjRGF0ZSIsImZvcm1hdHRlck9wdGlvbnMiLCJmaXJzdENoYXJhY3RlciIsImxvbmdGb3JtYXR0ZXIiLCJjbGVhbkVzY2FwZWRTdHJpbmciLCJmb3JtYXR0ZXIiLCJ1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMiLCJ1c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zIiwiYXNzaWduJDEiLCJkaXJ0eU9iamVjdCIsInByb3BlcnR5IiwiaXNBZnRlciIsImRpcnR5RGF0ZVRvQ29tcGFyZSIsImRhdGVUb0NvbXBhcmUiLCJpc0JlZm9yZSIsInNldFVUQ0RheSIsImRpcnR5RGF5IiwiY3VycmVudERheSIsImRheUluZGV4Iiwic2V0VVRDSVNPRGF5Iiwic2V0VVRDSVNPV2VlayIsImRpcnR5SVNPV2VlayIsInNldFVUQ1dlZWsiLCJkaXJ0eVdlZWsiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiIsIk1JTExJU0VDT05EU19JTl9NSU5VVEUkMSIsIk1JTExJU0VDT05EU19JTl9TRUNPTkQiLCJudW1lcmljUGF0dGVybnMiLCJob3VyMjNoIiwiaG91cjI0aCIsImhvdXIxMWgiLCJob3VyMTJoIiwibWludXRlIiwic2Vjb25kIiwic2luZ2xlRGlnaXQiLCJ0d29EaWdpdHMiLCJ0aHJlZURpZ2l0cyIsImZvdXJEaWdpdHMiLCJhbnlEaWdpdHNTaWduZWQiLCJzaW5nbGVEaWdpdFNpZ25lZCIsInR3b0RpZ2l0c1NpZ25lZCIsInRocmVlRGlnaXRzU2lnbmVkIiwiZm91ckRpZ2l0c1NpZ25lZCIsInRpbWV6b25lUGF0dGVybnMiLCJiYXNpY09wdGlvbmFsTWludXRlcyIsImJhc2ljIiwiYmFzaWNPcHRpb25hbFNlY29uZHMiLCJleHRlbmRlZCIsImV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzIiwicGFyc2VOdW1lcmljUGF0dGVybiIsInBhcnNlVGltZXpvbmVQYXR0ZXJuIiwic2Vjb25kcyIsInBhcnNlQW55RGlnaXRzU2lnbmVkIiwicGFyc2VORGlnaXRzIiwicGFyc2VORGlnaXRzU2lnbmVkIiwiZGF5UGVyaW9kRW51bVRvSG91cnMiLCJlbnVtVmFsdWUiLCJub3JtYWxpemVUd29EaWdpdFllYXIiLCJjdXJyZW50WWVhciIsImlzQ29tbW9uRXJhIiwiYWJzQ3VycmVudFllYXIiLCJyYW5nZUVuZCIsInJhbmdlRW5kQ2VudHVyeSIsImlzUHJldmlvdXNDZW50dXJ5IiwiREFZU19JTl9NT05USCIsIkRBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSIiwiaXNMZWFwWWVhckluZGV4IiwicGFyc2VycyIsInByaW9yaXR5IiwiZmxhZ3MiLCJpbmNvbXBhdGlibGVUb2tlbnMiLCJpc1R3b0RpZ2l0WWVhciIsInZhbGlkYXRlIiwibm9ybWFsaXplZFR3b0RpZ2l0WWVhciIsIl9tYXRjaCIsIl9mbGFncyIsImZpcnN0V2Vla09mWWVhciIsImlzTGVhcFllYXIiLCJ3aG9sZVdlZWtEYXlzIiwiaXNQTSIsInNldFVUQ01pbnV0ZXMiLCJzZXRVVENTZWNvbmRzIiwic2V0VVRDTWlsbGlzZWNvbmRzIiwidGltZXN0YW1wSXNTZXQiLCJfdG9rZW4iLCJUSU1FWk9ORV9VTklUX1BSSU9SSVRZIiwiZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxIiwibG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSIsImVzY2FwZWRTdHJpbmdSZWdFeHAkMSIsImRvdWJsZVF1b3RlUmVnRXhwJDEiLCJub3RXaGl0ZXNwYWNlUmVnRXhwIiwidW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAkMSIsImRpcnR5RGF0ZVN0cmluZyIsImRpcnR5Rm9ybWF0U3RyaW5nIiwiZGlydHlCYWNrdXBEYXRlIiwiZGF0ZVN0cmluZyIsImZvcm1hdFN0cmluZyIsInN1YkZuT3B0aW9ucyIsInNldHRlcnMiLCJkYXRlVG9TeXN0ZW1UaW1lem9uZSIsInRva2VucyIsInVzZWRUb2tlbnMiLCJwYXJzZXIiLCJpbmNvbXBhdGlibGVUb2tlbiIsInVzZWRUb2tlbiIsImZ1bGxUb2tlbiIsImNsZWFuRXNjYXBlZFN0cmluZyQxIiwidW5pcXVlUHJpb3JpdHlTZXR0ZXJzIiwic2V0dGVyIiwiZmlsdGVyIiwicmV2ZXJzZSIsInNldHRlckFycmF5IiwiY29udmVydGVkRGF0ZSIsInNldEZ1bGxZZWFyIiwic2V0SG91cnMiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiQxIiwiTUlMTElTRUNPTkRTX0lOX01JTlVURSQyIiwiREVGQVVMVF9BRERJVElPTkFMX0RJR0lUUyIsInBhdHRlcm5zIiwiZGF0ZVRpbWVEZWxpbWl0ZXIiLCJ0aW1lWm9uZURlbGltaXRlciIsInRpbWV6b25lIiwiZGF0ZVJlZ2V4IiwidGltZVJlZ2V4IiwidGltZXpvbmVSZWdleCIsInBhcnNlSVNPIiwiYWRkaXRpb25hbERpZ2l0cyIsImRhdGVTdHJpbmdzIiwic3BsaXREYXRlU3RyaW5nIiwicGFyc2VZZWFyUmVzdWx0IiwicGFyc2VZZWFyIiwicGFyc2VEYXRlIiwicmVzdERhdGVTdHJpbmciLCJwYXJzZVRpbWUiLCJwYXJzZVRpbWV6b25lIiwiZnVsbFRpbWUiLCJmdWxsVGltZURhdGUiLCJmdWxsVGltZURhdGVOZXh0RGF5Iiwic2V0RGF0ZSIsImdldERhdGUiLCJvZmZzZXREaWZmIiwidGltZVN0cmluZyIsInJlZ2V4IiwiY2FwdHVyZXMiLCJjZW50dXJ5IiwiaXNXZWVrRGF0ZSIsInBhcnNlRGF0ZVVuaXQiLCJ2YWxpZGF0ZVdlZWtEYXRlIiwiZGF5T2ZJU09XZWVrWWVhciIsInZhbGlkYXRlRGF0ZSIsInZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSIsInBhcnNlVGltZVVuaXQiLCJ2YWxpZGF0ZVRpbWUiLCJwYXJzZUZsb2F0IiwidGltZXpvbmVTdHJpbmciLCJ2YWxpZGF0ZVRpbWV6b25lIiwiZm91cnRoT2ZKYW51YXJ5RGF5IiwiZGF5c0luTW9udGhzIiwiaXNMZWFwWWVhckluZGV4JDEiLCJfeWVhciIsIl9ob3VycyIsInBhcnNlRGF0ZSQxIiwiX2dsb2JhbCIsIl9fdnVlbWNfdmFsaWRhdGlvbl9tZXNzYWdlcyIsIl9jbGFzcyIsInJlc2V0IiwiJGxvY2FsZSIsIiRmYWxsYmFjayIsIiRsb2NhbGVzIiwicmVnaXN0ZXIiLCJidW5kbGUiLCJfdGhpcyIsIiR0ZW1wbGF0ZSIsInJ1bGUiLCJjb25maWciLCIkcnVsZSIsImF0dHJpYnV0ZSIsIm1vZGVsIiwidmFsaWQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9hbmQiLCJfc3RlcCIsIm5leHQiLCJkb25lIiwiZXJyIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIiLCJfZGlkSXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3IyIiwiX29yIiwiX3N0ZXAyIiwiX3Jlc3VsdCIsIl9mb3JtYXQiLCJjb3B5Iiwib3IiLCJydWxlcyIsImFuZCIsImluY2x1c2l2ZSIsIl9taW4iLCJfbWF4IiwiX3ZhbHVlIiwiX2Jvb2xlYW4iLCJmb3JtYXQkMSIsImVycm9yIiwiZXF1YWwiLCJndCQxIiwiZ3RlJDEiLCJsdCQxIiwibHRlJDEiLCJtYXRjaCQxIiwiX21heDIiLCJfbWluMiIsIl9sZW4iLCJfa2V5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7TUFHcUIsT0FBUSxTQUFRQSxXQUFLO0lBQ3hDLFFBQVE7UUFDTixPQUFPO1lBQ0wsRUFBRSxFQUFFLElBQUk7WUFDUixnQkFBZ0IsRUFBRSxJQUFJO1lBQ3RCLFdBQVcsRUFBRSxJQUFJO1lBQ2pCLFVBQVUsRUFBRSxJQUFJO1lBQ2hCLE1BQU0sRUFBRSxJQUFJO1lBQ1osSUFBSSxFQUFFLElBQUk7WUFDVixJQUFJLEVBQUUsSUFBSTtTQUNYLENBQUM7S0FDSDtJQUVELFNBQVM7UUFDUCxPQUFPO1lBQ0wsRUFBRSxFQUFFLENBQUMsRUFBVSxLQUFLQyxlQUFRLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSTtZQUN4QyxnQkFBZ0IsRUFBRSxDQUFDLEVBQVUsS0FBS0EsZUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUk7WUFDdEQsV0FBVyxFQUFFLENBQUMsRUFBVSxLQUFLQSxlQUFRLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSTtZQUNqRCxVQUFVLEVBQUUsQ0FBQyxFQUFVLEtBQUtBLGVBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJO1NBQ2pELENBQUM7S0FDSDtJQUVELFVBQVU7UUFDUixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsTUFBTTtRQUNKLE9BQU87WUFDTCxLQUFLLEVBQUUsZUFBZTtZQUN0QixNQUFNLEVBQUUsZ0JBQWdCO1lBQ3hCLE1BQU0sRUFBRSxpQkFBaUI7WUFDekIsTUFBTSxFQUFFLGtCQUFrQjtTQUMzQixDQUFDO0tBQ0g7OztNQy9Ca0IsaUJBQWtCLFNBQVFDLGdCQUFtQjtJQUNoRSxLQUFLO1FBQ0gsT0FBTyxPQUFPLENBQUM7S0FDaEI7SUFFRCxNQUFNO1FBQ0osT0FBTztZQUNMLEtBQUssRUFBRSxnQkFBZ0I7WUFDdkIsSUFBSSxFQUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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
