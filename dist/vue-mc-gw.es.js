
  /**
   * @license
   * author: Alvaro Canepa
   * vue-mc-gw.js v1.0.14
   * Released under the MIT license.
   */

import { Model, Collection } from '@planetadeleste/vue-mc';
import { toNumber } from 'lodash';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var validation = {};

(function (exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /**
   * Afrikaans
   */


  var en_us = {
    locale: 'en-US',
    messages: {
      after: 'Must be after ${date}',
      alpha: 'Can only use letters',
      alphanumeric: 'Must be alphanumeric',
      array: 'Must be an array',
      ascii: 'Must be ASCII',
      base64: 'Must be valid Base64',
      before: 'Must be before ${date}',
      between: 'Must be between ${min} and ${max}',
      between_inclusive: 'Must be between ${min} and ${max}, inclusive',
      "boolean": 'Must be true or false',
      creditcard: 'Must be a valid credit card number',
      date: 'Must be a valid date',
      dateformat: 'Must use "${format}" format',
      defined: 'Required',
      email: 'Must be a valid email address',
      empty: 'Must be empty',
      equals: 'Must be equal to ${other}',
      gt: 'Must be greater than ${min}',
      gte: 'Must be greater than or equal to ${min}',
      integer: 'Must be an integer',
      ip: 'Must be a valid IP address',
      isblank: 'May not be blank',
      isnil: 'Required',
      isnull: 'Required',
      iso8601: 'Must be a valid ISO8601 date',
      json: 'Must be a valid JSON',
      length: 'Must have a length of at least ${min}',
      length_between: 'Must have a length between ${min} and ${max}',
      lt: 'Must be less than ${max}',
      lte: 'Must be less than or equal to ${max}',
      match: 'Must match "${pattern}"',
      negative: 'Must be a negative number',
      not: 'Can not be ${value}',
      number: 'Must be a number',
      numeric: 'Must be numeric',
      object: 'Must be an object',
      positive: 'Must be a positive number',
      required: 'Required',
      same: 'Must have the same value as "${other}"',
      string: 'Must be a string',
      url: 'Must be a valid URL',
      uuid: 'Must be a valid UUID'
    }
    /**
     * Persian - Islamic Republic of Iran
     */

  };
  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

  function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  var assertString_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = assertString;

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }

    function assertString(input) {
      var isString = typeof input === 'string' || input instanceof String;

      if (!isString) {
        var invalidType;

        if (input === null) {
          invalidType = 'null';
        } else {
          invalidType = _typeof$1(input);

          if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
            invalidType = input.constructor.name;
          } else {
            invalidType = "a ".concat(invalidType);
          }
        }

        throw new TypeError("Expected string but received ".concat(invalidType, "."));
      }
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(assertString_1);
  var alpha_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commaDecimal = exports.dotDecimal = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
    var alpha = {
      'en-US': /^[A-Z]+$/i,
      'bg-BG': /^[А-Я]+$/i,
      'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      'da-DK': /^[A-ZÆØÅ]+$/i,
      'de-DE': /^[A-ZÄÖÜß]+$/i,
      'el-GR': /^[Α-ω]+$/i,
      'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      'nb-NO': /^[A-ZÆØÅ]+$/i,
      'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      'nn-NO': /^[A-ZÆØÅ]+$/i,
      'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      'pt-PT': /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
      'ru-RU': /^[А-ЯЁ]+$/i,
      'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
      'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
      'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
      'sv-SE': /^[A-ZÅÄÖ]+$/i,
      'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
      'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    exports.alpha = alpha;
    var alphanumeric = {
      'en-US': /^[0-9A-Z]+$/i,
      'bg-BG': /^[0-9А-Я]+$/i,
      'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      'da-DK': /^[0-9A-ZÆØÅ]+$/i,
      'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
      'el-GR': /^[0-9Α-ω]+$/i,
      'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
      'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
      'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      'pt-PT': /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
      'ru-RU': /^[0-9А-ЯЁ]+$/i,
      'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
      'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
      'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
      'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    exports.alphanumeric = alphanumeric;
    var decimal = {
      'en-US': '.',
      ar: '٫'
    };
    exports.decimal = decimal;
    var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
    exports.englishLocales = englishLocales;

    for (var locale, i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha['en-US'];
      alphanumeric[locale] = alphanumeric['en-US'];
      decimal[locale] = decimal['en-US'];
    } // Source: http://www.localeplanet.com/java/


    var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
    exports.arabicLocales = arabicLocales;

    for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    } // Source: https://en.wikipedia.org/wiki/Decimal_mark


    var dotDecimal = [];
    exports.dotDecimal = dotDecimal;
    var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA'];
    exports.commaDecimal = commaDecimal;

    for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
      decimal[dotDecimal[_i2]] = decimal['en-US'];
    }

    for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
      decimal[commaDecimal[_i3]] = ',';
    }

    alpha['pt-BR'] = alpha['pt-PT'];
    alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
    decimal['pt-BR'] = decimal['pt-PT']; // see #862

    alpha['pl-Pl'] = alpha['pl-PL'];
    alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
    decimal['pl-Pl'] = decimal['pl-PL'];
  });
  unwrapExports(alpha_1);
  alpha_1.commaDecimal;
  alpha_1.dotDecimal;
  alpha_1.arabicLocales;
  alpha_1.englishLocales;
  alpha_1.decimal;
  alpha_1.alphanumeric;
  alpha_1.alpha;
  var isAlpha_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isAlpha;
    exports.locales = void 0;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function isAlpha(str) {
      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
      (0, _assertString["default"])(str);

      if (locale in alpha_1.alpha) {
        return alpha_1.alpha[locale].test(str);
      }

      throw new Error("Invalid locale '".concat(locale, "'"));
    }

    var locales = Object.keys(alpha_1.alpha);
    exports.locales = locales;
  });
  var isAlpha = unwrapExports(isAlpha_1);
  isAlpha_1.locales;
  var isAlphanumeric_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isAlphanumeric;
    exports.locales = void 0;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function isAlphanumeric(str) {
      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
      (0, _assertString["default"])(str);

      if (locale in alpha_1.alphanumeric) {
        return alpha_1.alphanumeric[locale].test(str);
      }

      throw new Error("Invalid locale '".concat(locale, "'"));
    }

    var locales = Object.keys(alpha_1.alphanumeric);
    exports.locales = locales;
  });
  var isAlphanumeric = unwrapExports(isAlphanumeric_1);
  isAlphanumeric_1.locales;
  var isBase64_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isBase64;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var notBase64 = /[^A-Z0-9+\/=]/i;

    function isBase64(str) {
      (0, _assertString["default"])(str);
      var len = str.length;

      if (!len || len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }

      var firstPaddingChar = str.indexOf('=');
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isBase64 = unwrapExports(isBase64_1);
  var isCreditCard_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isCreditCard;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    /* eslint-disable max-len */


    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
    /* eslint-enable max-len */

    function isCreditCard(str) {
      (0, _assertString["default"])(str);
      var sanitized = str.replace(/[- ]+/g, '');

      if (!creditCard.test(sanitized)) {
        return false;
      }

      var sum = 0;
      var digit;
      var tmpNum;
      var shouldDouble;

      for (var i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, i + 1);
        tmpNum = parseInt(digit, 10);

        if (shouldDouble) {
          tmpNum *= 2;

          if (tmpNum >= 10) {
            sum += tmpNum % 10 + 1;
          } else {
            sum += tmpNum;
          }
        } else {
          sum += tmpNum;
        }

        shouldDouble = !shouldDouble;
      }

      return !!(sum % 10 === 0 ? sanitized : false);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isCreditCard = unwrapExports(isCreditCard_1);
  var merge_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = merge;

    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : undefined;

      for (var key in defaults) {
        if (typeof obj[key] === 'undefined') {
          obj[key] = defaults[key];
        }
      }

      return obj;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(merge_1);
  var isByteLength_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isByteLength;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }
    /* eslint-disable prefer-rest-params */


    function isByteLength(str, options) {
      (0, _assertString["default"])(str);
      var min;
      var max;

      if (_typeof$1(options) === 'object') {
        min = options.min || 0;
        max = options.max;
      } else {
        // backwards compatibility: isByteLength(str, min [, max])
        min = arguments[1];
        max = arguments[2];
      }

      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === 'undefined' || len <= max);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(isByteLength_1);
  var isFQDN_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isFQDN;

    var _assertString = _interopRequireDefault(assertString_1);

    var _merge = _interopRequireDefault(merge_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false
    };

    function isFQDN(str, options) {
      (0, _assertString["default"])(str);
      options = (0, _merge["default"])(options, default_fqdn_options);
      /* Remove the optional trailing dot before checking validity */

      if (options.allow_trailing_dot && str[str.length - 1] === '.') {
        str = str.substring(0, str.length - 1);
      }

      var parts = str.split('.');

      for (var i = 0; i < parts.length; i++) {
        if (parts[i].length > 63) {
          return false;
        }
      }

      if (options.require_tld) {
        var tld = parts.pop();

        if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        } // disallow spaces


        if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
          return false;
        }
      }

      for (var part, _i = 0; _i < parts.length; _i++) {
        part = parts[_i];

        if (options.allow_underscores) {
          part = part.replace(/_/g, '');
        }

        if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        } // disallow full-width chars


        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }

        if (part[0] === '-' || part[part.length - 1] === '-') {
          return false;
        }
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  unwrapExports(isFQDN_1);
  var isIP_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isIP;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    var ipv6Block = /^[0-9A-F]{1,4}$/i;

    function isIP(str) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      (0, _assertString["default"])(str);
      version = String(version);

      if (!version) {
        return isIP(str, 4) || isIP(str, 6);
      } else if (version === '4') {
        if (!ipv4Maybe.test(str)) {
          return false;
        }

        var parts = str.split('.').sort(function (a, b) {
          return a - b;
        });
        return parts[3] <= 255;
      } else if (version === '6') {
        var blocks = str.split(':');
        var foundOmissionBlock = false; // marker to indicate ::
        // At least some OS accept the last 32 bits of an IPv6 address
        // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
        // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
        // and '::a.b.c.d' is deprecated, but also valid.

        var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
        var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

        if (blocks.length > expectedNumberOfBlocks) {
          return false;
        } // initial or final ::


        if (str === '::') {
          return true;
        } else if (str.substr(0, 2) === '::') {
          blocks.shift();
          blocks.shift();
          foundOmissionBlock = true;
        } else if (str.substr(str.length - 2) === '::') {
          blocks.pop();
          blocks.pop();
          foundOmissionBlock = true;
        }

        for (var i = 0; i < blocks.length; ++i) {
          // test for a :: which can not be at the string start/end
          // since those cases have been handled above
          if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
            if (foundOmissionBlock) {
              return false; // multiple :: in address
            }

            foundOmissionBlock = true;
          } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ;else if (!ipv6Block.test(blocks[i])) {
            return false;
          }
        }

        if (foundOmissionBlock) {
          return blocks.length >= 1;
        }

        return blocks.length === expectedNumberOfBlocks;
      }

      return false;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isIP = unwrapExports(isIP_1);
  var isEmail_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isEmail;

    var _assertString = _interopRequireDefault(assertString_1);

    var _merge = _interopRequireDefault(merge_1);

    var _isByteLength = _interopRequireDefault(isByteLength_1);

    var _isFQDN = _interopRequireDefault(isFQDN_1);

    var _isIP = _interopRequireDefault(isIP_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_email_options = {
      allow_display_name: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true
    };
    /* eslint-disable max-len */

    /* eslint-disable no-control-regex */

    var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    /* eslint-enable max-len */

    /* eslint-enable no-control-regex */

    function isEmail(str, options) {
      (0, _assertString["default"])(str);
      options = (0, _merge["default"])(options, default_email_options);

      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(displayName);

        if (display_email) {
          str = display_email[1];
        } else if (options.require_display_name) {
          return false;
        }
      }

      var parts = str.split('@');
      var domain = parts.pop();
      var user = parts.join('@');
      var lower_domain = domain.toLowerCase();

      if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
        /*
          Previously we removed dots for gmail addresses before validating.
          This was removed because it allows `multiple..dots@gmail.com`
          to be reported as valid, but it is not.
          Gmail only normalizes single dots, removing them from here is pointless,
          should be done in normalizeEmail
        */
        user = user.toLowerCase(); // Removing sub-address from username before gmail validation

        var username = user.split('+')[0]; // Dots are not included in gmail length restriction

        if (!(0, _isByteLength["default"])(username.replace('.', ''), {
          min: 6,
          max: 30
        })) {
          return false;
        }

        var _user_parts = username.split('.');

        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }

      if (!(0, _isByteLength["default"])(user, {
        max: 64
      }) || !(0, _isByteLength["default"])(domain, {
        max: 254
      })) {
        return false;
      }

      if (!(0, _isFQDN["default"])(domain, {
        require_tld: options.require_tld
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }

        if (!(0, _isIP["default"])(domain)) {
          if (!domain.startsWith('[') || !domain.endsWith(']')) {
            return false;
          }

          var noBracketdomain = domain.substr(1, domain.length - 2);

          if (noBracketdomain.length === 0 || !(0, _isIP["default"])(noBracketdomain)) {
            return false;
          }
        }
      }

      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }

      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split('.');

      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isEmail = unwrapExports(isEmail_1);
  var isISO8601_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isISO8601;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    /* eslint-disable max-len */
    // from http://goo.gl/0ejHHW


    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    /* eslint-enable max-len */

    var isValidDate = function isValidDate(str) {
      // str must have passed the ISO8601 check
      // this check is meant to catch invalid dates
      // like 2009-02-31
      // first check for ordinal dates
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);

      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]); // if is leap year

        if (oYear % 4 === 0 && oYear % 100 !== 0) return oDay <= 366;
        return oDay <= 365;
      }

      var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match[1];
      var month = match[2];
      var day = match[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day; // create a date object and compare

      var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
      if (isNaN(d.getUTCFullYear())) return false;

      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }

      return true;
    };

    function isISO8601(str, options) {
      (0, _assertString["default"])(str);
      var check = iso8601.test(str);
      if (!options) return check;
      if (check && options.strict) return isValidDate(str);
      return check;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isISO8601 = unwrapExports(isISO8601_1);
  var isJSON_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isJSON;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }

      return _typeof$1(obj);
    }

    function isJSON(str) {
      (0, _assertString["default"])(str);

      try {
        var obj = JSON.parse(str);
        return !!obj && _typeof$1(obj) === 'object';
      } catch (e) {
        /* ignore */
      }

      return false;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isJSON = unwrapExports(isJSON_1);
  var isURL_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isURL;

    var _assertString = _interopRequireDefault(assertString_1);

    var _isFQDN = _interopRequireDefault(isFQDN_1);

    var _isIP = _interopRequireDefault(isIP_1);

    var _merge = _interopRequireDefault(merge_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var default_url_options = {
      protocols: ['http', 'https', 'ftp'],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

    function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === '[object RegExp]';
    }

    function checkHost(host, matches) {
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];

        if (host === match || isRegExp(match) && match.test(host)) {
          return true;
        }
      }

      return false;
    }

    function isURL(url, options) {
      (0, _assertString["default"])(url);

      if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
        return false;
      }

      if (url.indexOf('mailto:') === 0) {
        return false;
      }

      options = (0, _merge["default"])(options, default_url_options);
      var protocol, auth, host, hostname, port, port_str, split, ipv6;
      split = url.split('#');
      url = split.shift();
      split = url.split('?');
      url = split.shift();
      split = url.split('://');

      if (split.length > 1) {
        protocol = split.shift().toLowerCase();

        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.substr(0, 2) === '//') {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }

        split[0] = url.substr(2);
      }

      url = split.join('://');

      if (url === '') {
        return false;
      }

      split = url.split('/');
      url = split.shift();

      if (url === '' && !options.require_host) {
        return true;
      }

      split = url.split('@');

      if (split.length > 1) {
        if (options.disallow_auth) {
          return false;
        }

        auth = split.shift();

        if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
          return false;
        }
      }

      hostname = split.join('@');
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);

      if (ipv6_match) {
        host = '';
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split = hostname.split(':');
        host = split.shift();

        if (split.length) {
          port_str = split.join(':');
        }
      }

      if (port_str !== null) {
        port = parseInt(port_str, 10);

        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      }

      if (!(0, _isIP["default"])(host) && !(0, _isFQDN["default"])(host, options) && (!ipv6 || !(0, _isIP["default"])(ipv6, 6))) {
        return false;
      }

      host = host || ipv6;

      if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
        return false;
      }

      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }

      return true;
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isURL = unwrapExports(isURL_1);
  var isUUID_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isUUID;

    var _assertString = _interopRequireDefault(assertString_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var uuid = {
      3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };

    function isUUID(str) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
      (0, _assertString["default"])(str);
      var pattern = uuid[version];
      return pattern && pattern.test(str);
    }

    module.exports = exports["default"];
    module.exports["default"] = exports["default"];
  });
  var isUUID = unwrapExports(isUUID_1);
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal$1) == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  var _freeGlobal = freeGlobal;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;
  /** Built-in value references. */

  var Symbol$1 = _root.Symbol;
  var _Symbol = Symbol$1;
  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;
  /** Used for built-in method references. */

  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;
  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  function isObject(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;
  /** `Object#toString` result references. */

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = _baseGetTag(value);

    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;
  /** Used for built-in method references. */

  var funcProto = Function.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$1 = funcProto$1.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */

  function getNative(object, key) {
    var value = _getValue(object, key);

    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var defineProperty = function () {
    try {
      var func = _getNative(Object, 'defineProperty');

      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  var _defineProperty = defineProperty;
  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;
  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }

    return object;
  }

  var _copyObject = copyObject;
  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */

  function identity(value) {
    return value;
  }

  var identity_1 = identity;
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  var _apply = apply;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max;
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;
  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */

  function constant(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant;
  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString;
  /** Used to detect hot functions by number of calls within a span of milliseconds. */

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeNow = Date.now;
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;
  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */

  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */

  function isIndex(value, length) {
    var type = _typeof(value);

    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;
  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */

  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }

    var type = _typeof(index);

    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
      return eq_1(object[index], value);
    }

    return false;
  }

  var _isIterateeCall = isIterateeCall;
  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */

  function createAssigner(assigner) {
    return _baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }

  var _createAssigner = createAssigner;
  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$4;
    return value === proto;
  }

  var _isPrototype = isPrototype;
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]';
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;
  /** Used for built-in method references. */

  var objectProto$5 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
  /** Built-in value references. */

  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */

  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments;
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray = Array.isArray;
  var isArray_1 = isArray;
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;
  var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Built-in value references. */

    var Buffer = moduleExports ? _root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse_1;
    module.exports = isBuffer;
  });
  /** `Object#toString` result references. */

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && _freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    module.exports = nodeUtil;
  });
  /* Node.js helper references. */


  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */

  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;
  /** Used for built-in method references. */

  var objectProto$6 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;
  /** Used for built-in method references. */

  var objectProto$7 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;
  /** Used for built-in method references. */

  var objectProto$8 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */

  var assign = _createAssigner(function (object, source) {
    if (_isPrototype(source) || isArrayLike_1(source)) {
      _copyObject(source, keys_1(source), object);

      return;
    }

    for (var key in source) {
      if (hasOwnProperty$6.call(source, key)) {
        _assignValue(object, key, source[key]);
      }
    }
  });

  var assign_1 = assign;
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;
  /** Built-in value references. */

  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */

  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  var _baseFlatten = baseFlatten;
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */

  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  var _copyArray = copyArray;
  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */

  function concat() {
    var length = arguments.length;

    if (!length) {
      return [];
    }

    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }

    return _arrayPush(isArray_1(array) ? _copyArray(array) : [array], _baseFlatten(args, 1));
  }

  var concat_1 = concat;
  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */

  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  var _basePropertyOf = basePropertyOf;
  /** Used to map Latin Unicode letters to basic Latin letters. */

  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',
    '\xc1': 'A',
    '\xc2': 'A',
    '\xc3': 'A',
    '\xc4': 'A',
    '\xc5': 'A',
    '\xe0': 'a',
    '\xe1': 'a',
    '\xe2': 'a',
    '\xe3': 'a',
    '\xe4': 'a',
    '\xe5': 'a',
    '\xc7': 'C',
    '\xe7': 'c',
    '\xd0': 'D',
    '\xf0': 'd',
    '\xc8': 'E',
    '\xc9': 'E',
    '\xca': 'E',
    '\xcb': 'E',
    '\xe8': 'e',
    '\xe9': 'e',
    '\xea': 'e',
    '\xeb': 'e',
    '\xcc': 'I',
    '\xcd': 'I',
    '\xce': 'I',
    '\xcf': 'I',
    '\xec': 'i',
    '\xed': 'i',
    '\xee': 'i',
    '\xef': 'i',
    '\xd1': 'N',
    '\xf1': 'n',
    '\xd2': 'O',
    '\xd3': 'O',
    '\xd4': 'O',
    '\xd5': 'O',
    '\xd6': 'O',
    '\xd8': 'O',
    '\xf2': 'o',
    '\xf3': 'o',
    '\xf4': 'o',
    '\xf5': 'o',
    '\xf6': 'o',
    '\xf8': 'o',
    '\xd9': 'U',
    '\xda': 'U',
    '\xdb': 'U',
    '\xdc': 'U',
    '\xf9': 'u',
    '\xfa': 'u',
    '\xfb': 'u',
    '\xfc': 'u',
    '\xdd': 'Y',
    '\xfd': 'y',
    '\xff': 'y',
    '\xc6': 'Ae',
    '\xe6': 'ae',
    '\xde': 'Th',
    '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    "\u0100": 'A',
    "\u0102": 'A',
    "\u0104": 'A',
    "\u0101": 'a',
    "\u0103": 'a',
    "\u0105": 'a',
    "\u0106": 'C',
    "\u0108": 'C',
    "\u010A": 'C',
    "\u010C": 'C',
    "\u0107": 'c',
    "\u0109": 'c',
    "\u010B": 'c',
    "\u010D": 'c',
    "\u010E": 'D',
    "\u0110": 'D',
    "\u010F": 'd',
    "\u0111": 'd',
    "\u0112": 'E',
    "\u0114": 'E',
    "\u0116": 'E',
    "\u0118": 'E',
    "\u011A": 'E',
    "\u0113": 'e',
    "\u0115": 'e',
    "\u0117": 'e',
    "\u0119": 'e',
    "\u011B": 'e',
    "\u011C": 'G',
    "\u011E": 'G',
    "\u0120": 'G',
    "\u0122": 'G',
    "\u011D": 'g',
    "\u011F": 'g',
    "\u0121": 'g',
    "\u0123": 'g',
    "\u0124": 'H',
    "\u0126": 'H',
    "\u0125": 'h',
    "\u0127": 'h',
    "\u0128": 'I',
    "\u012A": 'I',
    "\u012C": 'I',
    "\u012E": 'I',
    "\u0130": 'I',
    "\u0129": 'i',
    "\u012B": 'i',
    "\u012D": 'i',
    "\u012F": 'i',
    "\u0131": 'i',
    "\u0134": 'J',
    "\u0135": 'j',
    "\u0136": 'K',
    "\u0137": 'k',
    "\u0138": 'k',
    "\u0139": 'L',
    "\u013B": 'L',
    "\u013D": 'L',
    "\u013F": 'L',
    "\u0141": 'L',
    "\u013A": 'l',
    "\u013C": 'l',
    "\u013E": 'l',
    "\u0140": 'l',
    "\u0142": 'l',
    "\u0143": 'N',
    "\u0145": 'N',
    "\u0147": 'N',
    "\u014A": 'N',
    "\u0144": 'n',
    "\u0146": 'n',
    "\u0148": 'n',
    "\u014B": 'n',
    "\u014C": 'O',
    "\u014E": 'O',
    "\u0150": 'O',
    "\u014D": 'o',
    "\u014F": 'o',
    "\u0151": 'o',
    "\u0154": 'R',
    "\u0156": 'R',
    "\u0158": 'R',
    "\u0155": 'r',
    "\u0157": 'r',
    "\u0159": 'r',
    "\u015A": 'S',
    "\u015C": 'S',
    "\u015E": 'S',
    "\u0160": 'S',
    "\u015B": 's',
    "\u015D": 's',
    "\u015F": 's',
    "\u0161": 's',
    "\u0162": 'T',
    "\u0164": 'T',
    "\u0166": 'T',
    "\u0163": 't',
    "\u0165": 't',
    "\u0167": 't',
    "\u0168": 'U',
    "\u016A": 'U',
    "\u016C": 'U',
    "\u016E": 'U',
    "\u0170": 'U',
    "\u0172": 'U',
    "\u0169": 'u',
    "\u016B": 'u',
    "\u016D": 'u',
    "\u016F": 'u',
    "\u0171": 'u',
    "\u0173": 'u',
    "\u0174": 'W',
    "\u0175": 'w',
    "\u0176": 'Y',
    "\u0177": 'y',
    "\u0178": 'Y',
    "\u0179": 'Z',
    "\u017B": 'Z',
    "\u017D": 'Z',
    "\u017A": 'z',
    "\u017C": 'z',
    "\u017E": 'z',
    "\u0132": 'IJ',
    "\u0133": 'ij',
    "\u0152": 'Oe',
    "\u0153": 'oe',
    "\u0149": "'n",
    "\u017F": 's'
  };
  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */

  var deburrLetter = _basePropertyOf(deburredLetters);

  var _deburrLetter = deburrLetter;
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */

  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;
  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
  }

  var isSymbol_1 = isSymbol;
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  var _baseToString = baseToString;
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */

  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;
  /** Used to match Latin Unicode letters (excluding mathematical operators). */

  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  /** Used to compose unicode character classes. */

  var rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
  /** Used to compose unicode capture groups. */

  var rsCombo = '[' + rsComboRange + ']';
  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */

  var reComboMark = RegExp(rsCombo, 'g');
  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */

  function deburr(string) {
    string = toString_1(string);
    return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
  }

  var deburr_1 = deburr;
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */

  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var _arrayEach = arrayEach;
  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  var _createBaseFor = createBaseFor;
  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */

  var baseFor = _createBaseFor();

  var _baseFor = baseFor;
  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;
  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  var _createBaseEach = createBaseEach;
  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */

  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;
  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */

  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;
  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */

  function forEach(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayEach : _baseEach;
    return func(collection, _castFunction(iteratee));
  }

  var forEach_1 = forEach;
  var each = forEach_1;
  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = _typeof(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;
  /* Built-in method references that are verified to be native. */

  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used for built-in method references. */

  var objectProto$9 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;
  /** Used for built-in method references. */

  var objectProto$a = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
  }

  var _hashHas = hashHas;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `Hash`.


  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;
  /** Used for built-in method references. */

  var arrayProto = Array.prototype;
  /** Built-in value references. */

  var splice = arrayProto.splice;
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;
  /* Built-in method references that are verified to be native. */

  var Map = _getNative(_root, 'Map');

  var _Map = Map;
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */

  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);

    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;
  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = _MapCache;
  var memoize_1 = memoize;
  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;
  /** Used to match property names within property paths. */

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */

  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  var _stringToPath = stringToPath;
  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;
  /** Used as references for various `Number` constants. */

  var INFINITY$1 = 1 / 0;
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  var _toKey = toKey;
  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */

  function baseGet(object, path) {
    path = _castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  var _baseGet = baseGet;
  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;
  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */

  function baseGt(value, other) {
    return value > other;
  }

  var _baseGt = baseGt;
  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;
  /**
   * Creates a function that performs a relational operation on two values.
   *
   * @private
   * @param {Function} operator The function to perform the operation.
   * @returns {Function} Returns the new relational operation function.
   */

  function createRelationalOperation(operator) {
    return function (value, other) {
      if (!(typeof value == 'string' && typeof other == 'string')) {
        value = toNumber_1(value);
        other = toNumber_1(other);
      }

      return operator(value, other);
    };
  }

  var _createRelationalOperation = createRelationalOperation;
  /**
   * Checks if `value` is greater than `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   * @see _.lt
   * @example
   *
   * _.gt(3, 1);
   * // => true
   *
   * _.gt(3, 3);
   * // => false
   *
   * _.gt(1, 3);
   * // => false
   */

  var gt = _createRelationalOperation(_baseGt);

  var gt_1 = gt;
  /**
   * Checks if `value` is greater than or equal to `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than or equal to
   *  `other`, else `false`.
   * @see _.lte
   * @example
   *
   * _.gte(3, 1);
   * // => true
   *
   * _.gte(3, 3);
   * // => true
   *
   * _.gte(1, 3);
   * // => false
   */

  var gte = _createRelationalOperation(function (value, other) {
    return value >= other;
  });

  var gte_1 = gte;
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  var _baseFindIndex = baseFindIndex;
  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */

  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;
  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  var _strictIndexOf = strictIndexOf;
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;
  /** `Object#toString` result references. */

  var stringTag$1 = '[object String]';
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */

  function isString(value) {
    return typeof value == 'string' || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$1;
  }

  var isString_1 = isString;
  /** Used as references for various `Number` constants. */

  var INFINITY$2 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber_1(value);

    if (value === INFINITY$2 || value === -INFINITY$2) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;
  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */

  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var toInteger_1 = toInteger;
  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */

  function baseValues(object, props) {
    return _arrayMap(props, function (key) {
      return object[key];
    });
  }

  var _baseValues = baseValues;
  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */

  function values(object) {
    return object == null ? [] : _baseValues(object, keys_1(object));
  }

  var values_1 = values;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax$1 = Math.max;
  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */

  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike_1(collection) ? collection : values_1(collection);
    fromIndex = fromIndex && !guard ? toInteger_1(fromIndex) : 0;
    var length = collection.length;

    if (fromIndex < 0) {
      fromIndex = nativeMax$1(length + fromIndex, 0);
    }

    return isString_1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _baseIndexOf(collection, value, fromIndex) > -1;
  }

  var includes_1 = includes;
  /** `Object#toString` result references. */

  var boolTag$1 = '[object Boolean]';
  /**
   * Checks if `value` is classified as a boolean primitive or object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
   * @example
   *
   * _.isBoolean(false);
   * // => true
   *
   * _.isBoolean(null);
   * // => false
   */

  function isBoolean(value) {
    return value === true || value === false || isObjectLike_1(value) && _baseGetTag(value) == boolTag$1;
  }

  var isBoolean_1 = isBoolean;
  /* Built-in method references that are verified to be native. */

  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;
  /* Built-in method references that are verified to be native. */

  var Promise = _getNative(_root, 'Promise');

  var _Promise = Promise;
  /* Built-in method references that are verified to be native. */

  var Set = _getNative(_root, 'Set');

  var _Set = Set;
  /* Built-in method references that are verified to be native. */

  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;
  /** `Object#toString` result references. */

  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$1 = '[object DataView]';
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */


  var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;

          case mapCtorString:
            return mapTag$1;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$1;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;
  /** `Object#toString` result references. */

  var mapTag$2 = '[object Map]',
      setTag$2 = '[object Set]';
  /** Used for built-in method references. */

  var objectProto$b = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */

  function isEmpty(value) {
    if (value == null) {
      return true;
    }

    if (isArrayLike_1(value) && (isArray_1(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer_1(value) || isTypedArray_1(value) || isArguments_1(value))) {
      return !value.length;
    }

    var tag = _getTag(value);

    if (tag == mapTag$2 || tag == setTag$2) {
      return !value.size;
    }

    if (_isPrototype(value)) {
      return !_baseKeys(value).length;
    }

    for (var key in value) {
      if (hasOwnProperty$9.call(value, key)) {
        return false;
      }
    }

    return true;
  }

  var isEmpty_1 = isEmpty;
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;
  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  } // Add methods to `Stack`.


  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  var _setCacheAdd = setCacheAdd;
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;
  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;
  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */

  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;
  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;
  /** Built-in value references. */

  var Uint8Array = _root.Uint8Array;
  var _Uint8Array = Uint8Array;
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  /** `Object#toString` result references. */

  var boolTag$2 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$3 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$3 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]';
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$2:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$2:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag$3:
        var convert = _mapToArray;

      case setTag$3:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);

        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);

        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;
  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */

  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;
  /** Used for built-in method references. */

  var objectProto$c = Object.prototype;
  /** Built-in value references. */

  var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$2 = 1;
  /** Used for built-in method references. */

  var objectProto$d = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$a = objectProto$d.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;
  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$3 = 1;
  /** `Object#toString` result references. */

  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$2 = '[object Object]';
  /** Used for built-in method references. */

  var objectProto$e = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);
    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;
    var objIsObj = objTag == objectTag$2,
        othIsObj = othTag == objectTag$2,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;
  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;
  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */

  function isEqual(value, other) {
    return _baseIsEqual(value, other);
  }

  var isEqual_1 = isEqual;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsFinite = _root.isFinite;
  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */

  function isFinite(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  var _isFinite = isFinite;
  /**
   * Checks if `value` is an integer.
   *
   * **Note:** This method is based on
   * [`Number.isInteger`](https://mdn.io/Number/isInteger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
   * @example
   *
   * _.isInteger(3);
   * // => true
   *
   * _.isInteger(Number.MIN_VALUE);
   * // => false
   *
   * _.isInteger(Infinity);
   * // => false
   *
   * _.isInteger('3');
   * // => false
   */

  function isInteger(value) {
    return typeof value == 'number' && value == toInteger_1(value);
  }

  var isInteger_1 = isInteger;
  /** `Object#toString` result references. */

  var numberTag$2 = '[object Number]';
  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */

  function isNumber(value) {
    return typeof value == 'number' || isObjectLike_1(value) && _baseGetTag(value) == numberTag$2;
  }

  var isNumber_1 = isNumber;
  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */

  function isNaN$1(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber_1(value) && value != +value;
  }

  var _isNaN = isNaN$1;
  /**
   * Checks if `value` is `null` or `undefined`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
   * @example
   *
   * _.isNil(null);
   * // => true
   *
   * _.isNil(void 0);
   * // => true
   *
   * _.isNil(NaN);
   * // => false
   */

  function isNil(value) {
    return value == null;
  }

  var isNil_1 = isNil;
  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */

  function isNull(value) {
    return value === null;
  }

  var isNull_1 = isNull;
  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */

  function isUndefined(value) {
    return value === undefined;
  }

  var isUndefined_1 = isUndefined;
  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */

  function baseLt(value, other) {
    return value < other;
  }

  var _baseLt = baseLt;
  /**
   * Checks if `value` is less than `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   * @see _.gt
   * @example
   *
   * _.lt(1, 3);
   * // => true
   *
   * _.lt(3, 3);
   * // => false
   *
   * _.lt(3, 1);
   * // => false
   */

  var lt = _createRelationalOperation(_baseLt);

  var lt_1 = lt;
  /**
   * Checks if `value` is less than or equal to `other`.
   *
   * @static
   * @memberOf _
   * @since 3.9.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than or equal to
   *  `other`, else `false`.
   * @see _.gte
   * @example
   *
   * _.lte(1, 3);
   * // => true
   *
   * _.lte(3, 3);
   * // => true
   *
   * _.lte(3, 1);
   * // => false
   */

  var lte = _createRelationalOperation(function (value, other) {
    return value <= other;
  });

  var lte_1 = lte;
  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */

  function baseSet(object, path, value, customizer) {
    if (!isObject_1(object)) {
      return object;
    }

    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = _toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject_1(objValue) ? objValue : _isIndex(path[index + 1]) ? [] : {};
        }
      }

      _assignValue(nested, key, newValue);

      nested = nested[key];
    }

    return object;
  }

  var _baseSet = baseSet;
  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */

  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = _baseGet(object, path);

      if (predicate(value, path)) {
        _baseSet(result, _castPath(path, object), value);
      }
    }

    return result;
  }

  var _basePickBy = basePickBy;
  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;
  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;
  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */

  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;
  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */

  function basePick(object, paths) {
    return _basePickBy(object, paths, function (value, path) {
      return hasIn_1(object, path);
    });
  }

  var _basePick = basePick;
  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */

  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? _baseFlatten(array, 1) : [];
  }

  var flatten_1 = flatten;
  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */

  function flatRest(func) {
    return _setToString(_overRest(func, undefined, flatten_1), func + '');
  }

  var _flatRest = flatRest;
  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */

  var pick = _flatRest(function (object, paths) {
    return object == null ? {} : _basePick(object, paths);
  });

  var pick_1 = pick;
  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */

  function set(object, path, value) {
    return object == null ? object : _baseSet(object, path, value);
  }

  var set_1 = set;
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */

  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;
  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  var asciiSize = _baseProperty('length');

  var _asciiSize = asciiSize;
  /** Used to compose unicode character classes. */

  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange$1 = "\\u0300-\\u036f",
      reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsZWJ = "\\u200d";
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange$1 + rsVarRange + ']');
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */

  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;
  /** Used to compose unicode character classes. */

  var rsAstralRange$1 = "\\ud800-\\udfff",
      rsComboMarksRange$2 = "\\u0300-\\u036f",
      reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
      rsVarRange$1 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo$1 = '[' + rsComboRange$2 + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo$1 + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$1 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo$1 + '?', rsCombo$1, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;

    while (reUnicode.test(string)) {
      ++result;
    }

    return result;
  }

  var _unicodeSize = unicodeSize;
  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */

  function stringSize(string) {
    return _hasUnicode(string) ? _unicodeSize(string) : _asciiSize(string);
  }

  var _stringSize = stringSize;
  /** `Object#toString` result references. */

  var mapTag$4 = '[object Map]',
      setTag$4 = '[object Set]';
  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */

  function size(collection) {
    if (collection == null) {
      return 0;
    }

    if (isArrayLike_1(collection)) {
      return isString_1(collection) ? _stringSize(collection) : collection.length;
    }

    var tag = _getTag(collection);

    if (tag == mapTag$4 || tag == setTag$4) {
      return collection.size;
    }

    return _baseKeys(collection).length;
  }

  var size_1 = size;
  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  var _baseSlice = baseSlice;
  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;
  /** `Object#toString` result references. */

  var regexpTag$2 = '[object RegExp]';
  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */

  function baseIsRegExp(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == regexpTag$2;
  }

  var _baseIsRegExp = baseIsRegExp;
  /* Node.js helper references. */

  var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;
  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */

  var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;
  var isRegExp_1 = isRegExp;
  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;
  /** Used to compose unicode character classes. */

  var rsAstralRange$2 = "\\ud800-\\udfff",
      rsComboMarksRange$3 = "\\u0300-\\u036f",
      reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$3 = "\\u20d0-\\u20ff",
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsVarRange$2 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral$1 = '[' + rsAstralRange$2 + ']',
      rsCombo$2 = '[' + rsComboRange$3 + ']',
      rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
      rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$2 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$2 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsSymbol$1 = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral$1].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode$1 = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol$1 + rsSeq$1, 'g');
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function unicodeToArray(string) {
    return string.match(reUnicode$1) || [];
  }

  var _unicodeToArray = unicodeToArray;
  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function stringToArray(string) {
    return _hasUnicode(string) ? _unicodeToArray(string) : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;
  /** Used as references for the maximum length and index of an array. */

  var MAX_ARRAY_LENGTH = 4294967295;
  /**
   * Splits `string` by `separator`.
   *
   * **Note:** This method is based on
   * [`String#split`](https://mdn.io/String/split).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to split.
   * @param {RegExp|string} separator The separator pattern to split by.
   * @param {number} [limit] The length to truncate results to.
   * @returns {Array} Returns the string segments.
   * @example
   *
   * _.split('a-b-c', '-', 2);
   * // => ['a', 'b']
   */

  function split(string, separator, limit) {
    if (limit && typeof limit != 'number' && _isIterateeCall(string, separator, limit)) {
      separator = limit = undefined;
    }

    limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

    if (!limit) {
      return [];
    }

    string = toString_1(string);

    if (string && (typeof separator == 'string' || separator != null && !isRegExp_1(separator))) {
      separator = _baseToString(separator);

      if (!separator && _hasUnicode(string)) {
        return _castSlice(_stringToArray(string), 0, limit);
      }
    }

    return string.split(separator, limit);
  }

  var split_1 = split;
  /**
   * This method returns `true`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `true`.
   * @example
   *
   * _.times(2, _.stubTrue);
   * // => [true, true]
   */

  function stubTrue() {
    return true;
  }

  var stubTrue_1 = stubTrue;
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var _nativeKeysIn = nativeKeysIn;
  /** Used for built-in method references. */

  var objectProto$f = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$c = objectProto$f.hasOwnProperty;
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }

    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$c.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeysIn = baseKeysIn;
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */

  function keysIn(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn;
  /**
   * This method is like `_.assignIn` except that it accepts `customizer`
   * which is invoked to produce the assigned values. If `customizer` returns
   * `undefined`, assignment is handled by the method instead. The `customizer`
   * is invoked with five arguments: (objValue, srcValue, key, object, source).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extendWith
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} [customizer] The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @see _.assignWith
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   return _.isUndefined(objValue) ? srcValue : objValue;
   * }
   *
   * var defaults = _.partialRight(_.assignInWith, customizer);
   *
   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */

  var assignInWith = _createAssigner(function (object, source, srcIndex, customizer) {
    _copyObject(source, keysIn_1(source), object, customizer);
  });

  var assignInWith_1 = assignInWith;
  /** Built-in value references. */

  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;
  /** `Object#toString` result references. */

  var objectTag$3 = '[object Object]';
  /** Used for built-in method references. */

  var funcProto$2 = Function.prototype,
      objectProto$g = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$2 = funcProto$2.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$d = objectProto$g.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString$2.call(Object);
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$d.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;
  /** `Object#toString` result references. */

  var domExcTag = '[object DOMException]',
      errorTag$2 = '[object Error]';
  /**
   * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
   * `SyntaxError`, `TypeError`, or `URIError` object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
   * @example
   *
   * _.isError(new Error);
   * // => true
   *
   * _.isError(Error);
   * // => false
   */

  function isError(value) {
    if (!isObjectLike_1(value)) {
      return false;
    }

    var tag = _baseGetTag(value);

    return tag == errorTag$2 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject_1(value);
  }

  var isError_1 = isError;
  /**
   * Attempts to invoke `func`, returning either the result or the caught error
   * object. Any additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Function} func The function to attempt.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {*} Returns the `func` result or error object.
   * @example
   *
   * // Avoid throwing errors for invalid selectors.
   * var elements = _.attempt(function(selector) {
   *   return document.querySelectorAll(selector);
   * }, '>_>');
   *
   * if (_.isError(elements)) {
   *   elements = [];
   * }
   */

  var attempt = _baseRest(function (func, args) {
    try {
      return _apply(func, undefined, args);
    } catch (e) {
      return isError_1(e) ? e : new Error(e);
    }
  });

  var attempt_1 = attempt;
  /** Used for built-in method references. */

  var objectProto$h = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$e = objectProto$h.hasOwnProperty;
  /**
   * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
   * of source objects to the destination object for all destination properties
   * that resolve to `undefined`.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to assign.
   * @param {Object} object The parent object of `objValue`.
   * @returns {*} Returns the value to assign.
   */

  function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === undefined || eq_1(objValue, objectProto$h[key]) && !hasOwnProperty$e.call(object, key)) {
      return srcValue;
    }

    return objValue;
  }

  var _customDefaultsAssignIn = customDefaultsAssignIn;
  /** Used to escape characters for inclusion in compiled string literals. */

  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    "\u2028": 'u2028',
    "\u2029": 'u2029'
  };
  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  var _escapeStringChar = escapeStringChar;
  /** Used to match template delimiters. */

  var reInterpolate = /<%=([\s\S]+?)%>/g;
  var _reInterpolate = reInterpolate;
  /** Used to map characters to HTML entities. */

  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  var escapeHtmlChar = _basePropertyOf(htmlEscapes);

  var _escapeHtmlChar = escapeHtmlChar;
  /** Used to match HTML entities and HTML characters. */

  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */

  function escape(string) {
    string = toString_1(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, _escapeHtmlChar) : string;
  }

  var _escape = escape;
  /** Used to match template delimiters. */

  var reEscape = /<%-([\s\S]+?)%>/g;
  var _reEscape = reEscape;
  /** Used to match template delimiters. */

  var reEvaluate = /<%([\s\S]+?)%>/g;
  var _reEvaluate = reEvaluate;
  /**
   * By default, the template delimiters used by lodash are like those in
   * embedded Ruby (ERB) as well as ES2015 template strings. Change the
   * following template settings to use alternative delimiters.
   *
   * @static
   * @memberOf _
   * @type {Object}
   */

  var templateSettings = {
    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'escape': _reEscape,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'evaluate': _reEvaluate,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'interpolate': _reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type {string}
     */
    'variable': '',

    /**
     * Used to import variables into the compiled template.
     *
     * @memberOf _.templateSettings
     * @type {Object}
     */
    'imports': {
      /**
       * A reference to the `lodash` function.
       *
       * @memberOf _.templateSettings.imports
       * @type {Function}
       */
      '_': {
        'escape': _escape
      }
    }
  };
  var templateSettings_1 = templateSettings;
  /** Used to match empty string literals in compiled template source. */

  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */

  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  /** Used to ensure capturing order of template delimiters. */

  var reNoMatch = /($^)/;
  /** Used to match unescaped characters in compiled string literals. */

  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  /** Used for built-in method references. */

  var objectProto$i = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$f = objectProto$i.hasOwnProperty;
  /**
   * Creates a compiled template function that can interpolate data properties
   * in "interpolate" delimiters, HTML-escape interpolated data properties in
   * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
   * properties may be accessed as free variables in the template. If a setting
   * object is given, it takes precedence over `_.templateSettings` values.
   *
   * **Note:** In the development build `_.template` utilizes
   * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
   * for easier debugging.
   *
   * For more information on precompiling templates see
   * [lodash's custom builds documentation](https://lodash.com/custom-builds).
   *
   * For more information on Chrome extension sandboxes see
   * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The template string.
   * @param {Object} [options={}] The options object.
   * @param {RegExp} [options.escape=_.templateSettings.escape]
   *  The HTML "escape" delimiter.
   * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
   *  The "evaluate" delimiter.
   * @param {Object} [options.imports=_.templateSettings.imports]
   *  An object to import into the template as free variables.
   * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
   *  The "interpolate" delimiter.
   * @param {string} [options.sourceURL='templateSources[n]']
   *  The sourceURL of the compiled template.
   * @param {string} [options.variable='obj']
   *  The data object variable name.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Function} Returns the compiled template function.
   * @example
   *
   * // Use the "interpolate" delimiter to create a compiled template.
   * var compiled = _.template('hello <%= user %>!');
   * compiled({ 'user': 'fred' });
   * // => 'hello fred!'
   *
   * // Use the HTML "escape" delimiter to escape data property values.
   * var compiled = _.template('<b><%- value %></b>');
   * compiled({ 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
   * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the internal `print` function in "evaluate" delimiters.
   * var compiled = _.template('<% print("hello " + user); %>!');
   * compiled({ 'user': 'barney' });
   * // => 'hello barney!'
   *
   * // Use the ES template literal delimiter as an "interpolate" delimiter.
   * // Disable support by replacing the "interpolate" delimiter.
   * var compiled = _.template('hello ${ user }!');
   * compiled({ 'user': 'pebbles' });
   * // => 'hello pebbles!'
   *
   * // Use backslashes to treat delimiters as plain text.
   * var compiled = _.template('<%= "\\<%- value %\\>" %>');
   * compiled({ 'value': 'ignored' });
   * // => '<%- value %>'
   *
   * // Use the `imports` option to import `jQuery` as `jq`.
   * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
   * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the `sourceURL` option to specify a custom sourceURL for the template.
   * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
   *
   * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
   * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   * //   var __t, __p = '';
   * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
   * //   return __p;
   * // }
   *
   * // Use custom template delimiters.
   * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
   * var compiled = _.template('hello {{ user }}!');
   * compiled({ 'user': 'mustache' });
   * // => 'hello mustache!'
   *
   * // Use the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and stack traces.
   * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */

  function template(string, options, guard) {
    // Based on John Resig's `tmpl` implementation
    // (http://ejohn.org/blog/javascript-micro-templating/)
    // and Laura Doktorova's doT.js (https://github.com/olado/doT).
    var settings = templateSettings_1.imports._.templateSettings || templateSettings_1;

    if (guard && _isIterateeCall(string, options, guard)) {
      options = undefined;
    }

    string = toString_1(string);
    options = assignInWith_1({}, options, settings, _customDefaultsAssignIn);

    var imports = assignInWith_1({}, options.imports, settings.imports, _customDefaultsAssignIn),
        importsKeys = keys_1(imports),
        importsValues = _baseValues(imports, importsKeys);

    var isEscaping,
        isEvaluating,
        index = 0,
        interpolate = options.interpolate || reNoMatch,
        source = "__p += '"; // Compile the regexp to match each delimiter.

    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === _reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
    // The sourceURL gets injected into the source that's eval-ed, so be careful
    // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
    // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

    var sourceURL = hasOwnProperty$f.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
    string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

      source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar); // Replace delimiters with snippets.

      if (escapeValue) {
        isEscaping = true;
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }

      if (evaluateValue) {
        isEvaluating = true;
        source += "';\n" + evaluateValue + ";\n__p += '";
      }

      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }

      index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
      // order to produce the correct `offset` value.

      return match;
    });
    source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
    // code to add the data object to the top of the scope chain.
    // Like with sourceURL, we take care to not check the option's prototype,
    // as this configuration is a code injection vector.

    var variable = hasOwnProperty$f.call(options, 'variable') && options.variable;

    if (!variable) {
      source = 'with (obj) {\n' + source + '\n}\n';
    } // Cleanup code by stripping empty strings.


    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

    source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
    var result = attempt_1(function () {
      return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
    }); // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.

    result.source = source;

    if (isError_1(result)) {
      throw result;
    }

    return result;
  }

  var template_1 = template;
  /**
   * Converts `string`, as a whole, to lower case just like
   * [String#toLowerCase](https://mdn.io/toLowerCase).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the lower cased string.
   * @example
   *
   * _.toLower('--Foo-Bar--');
   * // => '--foo-bar--'
   *
   * _.toLower('fooBar');
   * // => 'foobar'
   *
   * _.toLower('__FOO_BAR__');
   * // => '__foo_bar__'
   */

  function toLower(value) {
    return toString_1(value).toLowerCase();
  }

  var toLower_1 = toLower;
  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   *
   * @param {Date|Number} argument - the value to convert
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Clone the date:
   * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert the timestamp to date:
   * const result = toDate(1392098430000)
   * //=> Tue Feb 11 2014 11:30:30
   */

  function toDate(argument) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var argStr = Object.prototype.toString.call(argument); // Clone the date

    if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime());
    } else if (typeof argument === 'number' || argStr === '[object Number]') {
      return new Date(argument);
    } else {
      if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
        // eslint-disable-next-line no-console
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

        console.warn(new Error().stack);
      }

      return new Date(NaN);
    }
  }

  function toInteger$1(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }

    var number = Number(dirtyNumber);

    if (isNaN(number)) {
      return number;
    }

    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }
  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be added
   * @returns {Date} the new date with the milliseconds added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */


  function addMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var timestamp = toDate(dirtyDate).getTime();
    var amount = toInteger$1(dirtyAmount);
    return new Date(timestamp + amount);
  }

  var MILLISECONDS_IN_MINUTE = 60000;
  /**
   * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
   * They usually appear for dates that denote time before the timezones were introduced
   * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
   * and GMT+01:00:00 after that date)
   *
   * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
   * which would lead to incorrect calculations.
   *
   * This function returns the timezone offset in milliseconds that takes seconds in account.
   */

  function getTimezoneOffsetInMilliseconds(dirtyDate) {
    var date = new Date(dirtyDate.getTime());
    var baseTimezoneOffset = date.getTimezoneOffset();
    date.setSeconds(0, 0);
    var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
    return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
  }
  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Now `isValid` doesn't throw an exception
   *   if the first argument is not an instance of Date.
   *   Instead, argument is converted beforehand using `toDate`.
   *
   *   Examples:
   *
   *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
   *   |---------------------------|---------------|---------------|
   *   | `new Date()`              | `true`        | `true`        |
   *   | `new Date('2016-01-01')`  | `true`        | `true`        |
   *   | `new Date('')`            | `false`       | `false`       |
   *   | `new Date(1488370835081)` | `true`        | `true`        |
   *   | `new Date(NaN)`           | `false`       | `false`       |
   *   | `'2016-01-01'`            | `TypeError`   | `true`        |
   *   | `''`                      | `TypeError`   | `false`       |
   *   | `1488370835081`           | `TypeError`   | `true`        |
   *   | `NaN`                     | `TypeError`   | `false`       |
   *
   *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
   *   that try to coerce arguments to the expected type
   *   (which is also the case with other *date-fns* functions).
   *
   * @param {*} date - the date to check
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // For the valid date:
   * var result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * var result = isValid(1393804800000)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * var result = isValid(new Date(''))
   * //=> false
   */


  function isValid(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    return !isNaN(date);
  }

  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },
    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },
    halfAMinute: 'half a minute',
    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },
    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },
    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },
    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },
    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },
    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },
    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },
    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },
    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },
    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },
    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  };

  function formatDistance(token, count, options) {
    options = options || {};
    var result;

    if (typeof formatDistanceLocale[token] === 'string') {
      result = formatDistanceLocale[token];
    } else if (count === 1) {
      result = formatDistanceLocale[token].one;
    } else {
      result = formatDistanceLocale[token].other.replace('{{count}}', count);
    }

    if (options.addSuffix) {
      if (options.comparison > 0) {
        return 'in ' + result;
      } else {
        return result + ' ago';
      }
    }

    return result;
  }

  function buildFormatLongFn(args) {
    return function (dirtyOptions) {
      var options = dirtyOptions || {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }

  var dateFormats = {
    full: 'EEEE, MMMM do, y',
    "long": 'MMMM do, y',
    medium: 'MMM d, y',
    "short": 'MM/dd/yyyy'
  };
  var timeFormats = {
    full: 'h:mm:ss a zzzz',
    "long": 'h:mm:ss a z',
    medium: 'h:mm:ss a',
    "short": 'h:mm a'
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    "long": "{{date}} 'at' {{time}}",
    medium: '{{date}}, {{time}}',
    "short": '{{date}}, {{time}}'
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: 'full'
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: 'full'
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: 'full'
    })
  };
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: 'P'
  };

  function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  }

  function buildLocalizeFn(args) {
    return function (dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var context = options.context ? String(options.context) : 'standalone';
      var valuesArray;

      if (context === 'formatting' && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;

        var _width = options.width ? String(options.width) : args.defaultWidth;

        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }

      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }

  var eraValues = {
    narrow: ['B', 'A'],
    abbreviated: ['BC', 'AD'],
    wide: ['Before Christ', 'Anno Domini']
  };
  var quarterValues = {
    narrow: ['1', '2', '3', '4'],
    abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
    wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

  };
  var monthValues = {
    narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
    abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };
  var dayValues = {
    narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    "short": ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  };
  var dayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    }
  };

  function ordinalNumber(dirtyNumber, _dirtyOptions) {
    var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`:
    //
    //   var options = dirtyOptions || {}
    //   var unit = String(options.unit)
    //
    // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'

    var rem100 = number % 100;

    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + 'st';

        case 2:
          return number + 'nd';

        case 3:
          return number + 'rd';
      }
    }

    return number + 'th';
  }

  var localize = {
    ordinalNumber: ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: 'wide'
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: 'wide',
      argumentCallback: function argumentCallback(quarter) {
        return Number(quarter) - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: 'wide'
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: 'wide'
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: 'wide',
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: 'wide'
    })
  };

  function buildMatchPatternFn(args) {
    return function (dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var matchResult = string.match(args.matchPattern);

      if (!matchResult) {
        return null;
      }

      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);

      if (!parseResult) {
        return null;
      }

      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value: value,
        rest: string.slice(matchedString.length)
      };
    };
  }

  function buildMatchFn(args) {
    return function (dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);

      if (!matchResult) {
        return null;
      }

      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var value;

      if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
        value = parsePatterns.findIndex(function (pattern) {
          return pattern.test(string);
        });
      } else {
        value = findKey(parsePatterns, function (pattern) {
          return pattern.test(string);
        });
      }

      value = args.valueCallback ? args.valueCallback(value) : value;
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value: value,
        rest: string.slice(matchedString.length)
      };
    };
  }

  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
  }

  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    "short": /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseEraPatterns,
      defaultParseWidth: 'any'
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: 'any',
      valueCallback: function valueCallback(index) {
        return index + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: 'any'
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseDayPatterns,
      defaultParseWidth: 'any'
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: 'any',
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: 'any'
    })
  };
  /**
   * @type {Locale}
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
   * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
   */

  var locale = {
    formatDistance: formatDistance,
    formatLong: formatLong,
    formatRelative: formatRelative,
    localize: localize,
    match: match,
    options: {
      weekStartsOn: 0
      /* Sunday */
      ,
      firstWeekContainsDate: 1
    }
  };
  /**
   * @name subMilliseconds
   * @category Millisecond Helpers
   * @summary Subtract the specified number of milliseconds from the given date.
   *
   * @description
   * Subtract the specified number of milliseconds from the given date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be subtracted
   * @returns {Date} the new date with the milliseconds subtracted
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
   * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:29.250
   */

  function subMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var amount = toInteger$1(dirtyAmount);
    return addMilliseconds(dirtyDate, -amount);
  }

  function addLeadingZeros(number, targetLength) {
    var sign = number < 0 ? '-' : '';
    var output = Math.abs(number).toString();

    while (output.length < targetLength) {
      output = '0' + output;
    }

    return sign + output;
  }
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* |                                |
   * |  d  | Day of month                   |  D  |                                |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  m  | Minute                         |  M  | Month                          |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  y  | Year (abs)                     |  Y  |                                |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   */


  var formatters = {
    // Year
    y: function y(date, token) {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
    },
    // Month
    M: function M(date, token) {
      var month = date.getUTCMonth();
      return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d: function d(date, token) {
      return addLeadingZeros(date.getUTCDate(), token.length);
    },
    // AM or PM
    a: function a(date, token) {
      var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return dayPeriodEnumValue.toUpperCase();

        case 'aaaaa':
          return dayPeriodEnumValue[0];

        case 'aaaa':
        default:
          return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
      }
    },
    // Hour [1-12]
    h: function h(date, token) {
      return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H: function H(date, token) {
      return addLeadingZeros(date.getUTCHours(), token.length);
    },
    // Minute
    m: function m(date, token) {
      return addLeadingZeros(date.getUTCMinutes(), token.length);
    },
    // Second
    s: function s(date, token) {
      return addLeadingZeros(date.getUTCSeconds(), token.length);
    },
    // Fraction of second
    S: function S(date, token) {
      var numberOfDigits = token.length;
      var milliseconds = date.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCDayOfYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCISOWeek(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function getUTCISOWeekYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCISOWeekYear(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var year = getUTCISOWeekYear(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary);
    return date;
  }

  var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCISOWeek(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)

    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCWeek(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function getUTCWeekYear(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var year = date.getUTCFullYear();
    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate);
    var year = getUTCWeekYear(dirtyDate, dirtyOptions);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek(firstWeek, dirtyOptions);
    return date;
  }

  var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376

  function getUTCWeek(dirtyDate, options) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)

    return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
  }

  var dayPeriodEnum = {
    am: 'am',
    pm: 'pm',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */

  };
  var formatters$1 = {
    // Era
    G: function G(date, token, localize) {
      var era = date.getUTCFullYear() > 0 ? 1 : 0;

      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return localize.era(era, {
            width: 'abbreviated'
          });
        // A, B

        case 'GGGGG':
          return localize.era(era, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return localize.era(era, {
            width: 'wide'
          });
      }
    },
    // Year
    y: function y(date, token, localize) {
      // Ordinal number
      if (token === 'yo') {
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, {
          unit: 'year'
        });
      }

      return formatters.y(date, token);
    },
    // Local week-numbering year
    Y: function Y(date, token, localize, options) {
      var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

      if (token === 'YY') {
        var twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      } // Ordinal number


      if (token === 'Yo') {
        return localize.ordinalNumber(weekYear, {
          unit: 'year'
        });
      } // Padding


      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function R(date, token) {
      var isoWeekYear = getUTCISOWeekYear(date); // Padding

      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function u(date, token) {
      var year = date.getUTCFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function Q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
          return String(quarter);
        // 01, 02, 03, 04

        case 'QQ':
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone quarter
    q: function q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

      switch (token) {
        // 1, 2, 3, 4
        case 'q':
          return String(quarter);
        // 01, 02, 03, 04

        case 'qq':
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Month
    M: function M(date, token, localize) {
      var month = date.getUTCMonth();

      switch (token) {
        case 'M':
        case 'MM':
          return formatters.M(date, token);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return localize.month(month, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone month
    L: function L(date, token, localize) {
      var month = date.getUTCMonth();

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return String(month + 1);
        // 01, 02, ..., 12

        case 'LL':
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return localize.month(month, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Local week of year
    w: function w(date, token, localize, options) {
      var week = getUTCWeek(date, options);

      if (token === 'wo') {
        return localize.ordinalNumber(week, {
          unit: 'week'
        });
      }

      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function I(date, token, localize) {
      var isoWeek = getUTCISOWeek(date);

      if (token === 'Io') {
        return localize.ordinalNumber(isoWeek, {
          unit: 'week'
        });
      }

      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function d(date, token, localize) {
      if (token === 'do') {
        return localize.ordinalNumber(date.getUTCDate(), {
          unit: 'date'
        });
      }

      return formatters.d(date, token);
    },
    // Day of year
    D: function D(date, token, localize) {
      var dayOfYear = getUTCDayOfYear(date);

      if (token === 'Do') {
        return localize.ordinalNumber(dayOfYear, {
          unit: 'dayOfYear'
        });
      }

      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function E(date, token, localize) {
      var dayOfWeek = date.getUTCDay();

      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Local day of week
    e: function e(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case 'e':
          return String(localDayOfWeek);
        // Padded numerical value

        case 'ee':
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th

        case 'eo':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });

        case 'eee':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone local day of week
    c: function c(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

      switch (token) {
        // Numerical value (same as in `e`)
        case 'c':
          return String(localDayOfWeek);
        // Padded numerical value

        case 'cc':
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th

        case 'co':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });

        case 'ccc':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // ISO day of week
    i: function i(date, token, localize) {
      var dayOfWeek = date.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

      switch (token) {
        // 2
        case 'i':
          return String(isoDayOfWeek);
        // 02

        case 'ii':
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd

        case 'io':
          return localize.ordinalNumber(isoDayOfWeek, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T

        case 'iiiii':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'iiiiii':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday

        case 'iiii':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM or PM
    a: function a(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'aaaaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM, PM, midnight, noon
    b: function b(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;

      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
      }

      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'bbbbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function B(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;

      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }

      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });

        case 'BBBBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Hour [1-12]
    h: function h(date, token, localize) {
      if (token === 'ho') {
        var hours = date.getUTCHours() % 12;
        if (hours === 0) hours = 12;
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return formatters.h(date, token);
    },
    // Hour [0-23]
    H: function H(date, token, localize) {
      if (token === 'Ho') {
        return localize.ordinalNumber(date.getUTCHours(), {
          unit: 'hour'
        });
      }

      return formatters.H(date, token);
    },
    // Hour [0-11]
    K: function K(date, token, localize) {
      var hours = date.getUTCHours() % 12;

      if (token === 'Ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function k(date, token, localize) {
      var hours = date.getUTCHours();
      if (hours === 0) hours = 24;

      if (token === 'ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }

      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function m(date, token, localize) {
      if (token === 'mo') {
        return localize.ordinalNumber(date.getUTCMinutes(), {
          unit: 'minute'
        });
      }

      return formatters.m(date, token);
    },
    // Second
    s: function s(date, token, localize) {
      if (token === 'so') {
        return localize.ordinalNumber(date.getUTCSeconds(), {
          unit: 'second'
        });
      }

      return formatters.s(date, token);
    },
    // Fraction of second
    S: function S(date, token) {
      return formatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function X(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      if (timezoneOffset === 0) {
        return 'Z';
      }

      switch (token) {
        // Hours and optional minutes
        case 'X':
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`

        case 'XXXX':
        case 'XX':
          // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`

        case 'XXXXX':
        case 'XXX': // Hours and minutes with `:` delimiter

        default:
          return formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function x(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Hours and optional minutes
        case 'x':
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`

        case 'xxxx':
        case 'xx':
          // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`

        case 'xxxxx':
        case 'xxx': // Hours and minutes with `:` delimiter

        default:
          return formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (GMT)
    O: function O(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case 'O':
        case 'OO':
        case 'OOO':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
        // Long

        case 'OOOO':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':');
      }
    },
    // Timezone (specific non-location)
    z: function z(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case 'z':
        case 'zz':
        case 'zzz':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
        // Long

        case 'zzzz':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':');
      }
    },
    // Seconds timestamp
    t: function t(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = Math.floor(originalDate.getTime() / 1000);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function T(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = originalDate.getTime();
      return addLeadingZeros(timestamp, token.length);
    }
  };

  function formatTimezoneShort(offset, dirtyDelimiter) {
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;

    if (minutes === 0) {
      return sign + String(hours);
    }

    var delimiter = dirtyDelimiter || '';
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }

  function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? '-' : '+';
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }

    return formatTimezone(offset, dirtyDelimiter);
  }

  function formatTimezone(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    var minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }

  function dateLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'P':
        return formatLong.date({
          width: 'short'
        });

      case 'PP':
        return formatLong.date({
          width: 'medium'
        });

      case 'PPP':
        return formatLong.date({
          width: 'long'
        });

      case 'PPPP':
      default:
        return formatLong.date({
          width: 'full'
        });
    }
  }

  function timeLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'p':
        return formatLong.time({
          width: 'short'
        });

      case 'pp':
        return formatLong.time({
          width: 'medium'
        });

      case 'ppp':
        return formatLong.time({
          width: 'long'
        });

      case 'pppp':
      default:
        return formatLong.time({
          width: 'full'
        });
    }
  }

  function dateTimeLongFormatter(pattern, formatLong) {
    var matchResult = pattern.match(/(P+)(p+)?/);
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];

    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong);
    }

    var dateTimeFormat;

    switch (datePattern) {
      case 'P':
        dateTimeFormat = formatLong.dateTime({
          width: 'short'
        });
        break;

      case 'PP':
        dateTimeFormat = formatLong.dateTime({
          width: 'medium'
        });
        break;

      case 'PPP':
        dateTimeFormat = formatLong.dateTime({
          width: 'long'
        });
        break;

      case 'PPPP':
      default:
        dateTimeFormat = formatLong.dateTime({
          width: 'full'
        });
        break;
    }

    return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
  }

  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var protectedDayOfYearTokens = ['D', 'DD'];
  var protectedWeekYearTokens = ['YY', 'YYYY'];

  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }

  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }

  function throwProtectedError(token) {
    if (token === 'YYYY') {
      throw new RangeError('Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr');
    } else if (token === 'YY') {
      throw new RangeError('Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr');
    } else if (token === 'D') {
      throw new RangeError('Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr');
    } else if (token === 'DD') {
      throw new RangeError('Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr');
    }
  } // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps


  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'(.*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. The result may vary by locale.
   *
   * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   * (see the last example)
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 7 below the table).
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   | Notes |
   * |---------------------------------|---------|-----------------------------------|-------|
   * | Era                             | G..GGG  | AD, BC                            |       |
   * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 | GGGGG   | A, B                              |       |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
   * |                                 | yy      | 44, 01, 00, 17                    | 5     |
   * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
   * |                                 | yyyyy   | ...                               | 3,5   |
   * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
   * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
   * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
   * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
   * |                                 | YYYYY   | ...                               | 3,5   |
   * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
   * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
   * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
   * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
   * |                                 | RRRRR   | ...                               | 3,5,7 |
   * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
   * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
   * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
   * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
   * |                                 | uuuuu   | ...                               | 3,5   |
   * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
   * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | QQ      | 01, 02, 03, 04                    |       |
   * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
   * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | qq      | 01, 02, 03, 04                    |       |
   * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
   * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | MM      | 01, 02, ..., 12                   |       |
   * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 | MMMM    | January, February, ..., December  | 2     |
   * |                                 | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
   * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | LL      | 01, 02, ..., 12                   |       |
   * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 | LLLL    | January, February, ..., December  | 2     |
   * |                                 | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | w       | 1, 2, ..., 53                     |       |
   * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
   * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | II      | 01, 02, ..., 53                   | 7     |
   * | Day of month                    | d       | 1, 2, ..., 31                     |       |
   * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
   * |                                 | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
   * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
   * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
   * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 | DDDD    | ...                               | 3     |
   * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
   * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
   * |                                 | ii      | 01, 02, ..., 07                   | 7     |
   * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
   * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
   * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
   * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
   * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | ee      | 02, 03, ..., 01                   |       |
   * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | cc      | 02, 03, ..., 01                   |       |
   * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          | a..aaa  | AM, PM                            |       |
   * |                                 | aaaa    | a.m., p.m.                        | 2     |
   * |                                 | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
   * |                                 | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
   * |                                 | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
   * |                                 | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
   * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
   * |                                 | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          | m       | 0, 1, ..., 59                     |       |
   * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | mm      | 00, 01, ..., 59                   |       |
   * | Second                          | s       | 0, 1, ..., 59                     |       |
   * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | ss      | 00, 01, ..., 59                   |       |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
   * |                                 | SS      | 00, 01, ..., 99                   |       |
   * |                                 | SSS     | 000, 0001, ..., 999               |       |
   * |                                 | SSSS    | ...                               | 3     |
   * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
   * |                                 | XX      | -0800, +0530, Z                   |       |
   * |                                 | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
   * |                                 | xx      | -0800, +0530, +0000               |       |
   * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
   * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
   * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
   * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
   * | Seconds timestamp               | t       | 512969520                         | 7     |
   * |                                 | tt      | ...                               | 3,7   |
   * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
   * |                                 | TT      | ...                               | 3,7   |
   * | Long localized date             | P       | 05/29/1453                        | 7     |
   * |                                 | PP      | May 29, 1453                      | 7     |
   * |                                 | PPP     | May 29th, 1453                    | 7     |
   * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
   * | Long localized time             | p       | 12:00 AM                          | 7     |
   * |                                 | pp      | 12:00:00 AM                       | 7     |
   * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
   * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
   * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
   * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
   * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
   * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
   *    the output will be the same as default pattern for this unit, usually
   *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
   *    are marked with "2" in the last column of the table.
   *
   *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
   *
   * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
   *    The output will be padded with zeros to match the length of the pattern.
   *
   *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
   *
   * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 5. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` always returns the last two digits of a year,
   *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
   *
   *    | Year | `yy` | `uu` |
   *    |------|------|------|
   *    | 1    |   01 |   01 |
   *    | 14   |   14 |   14 |
   *    | 376  |   76 |  376 |
   *    | 1453 |   53 | 1453 |
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
   *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
   *
   * 6. Specific non-location timezones are currently unavailable in `date-fns`,
   *    so right now these tokens fall back to GMT timezones.
   *
   * 7. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `t`: seconds timestamp
   *    - `T`: milliseconds timestamp
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The second argument is now required for the sake of explicitness.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   format(new Date(2016, 0, 1))
   *
   *   // v2.0.0 onward
   *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
   *   ```
   *
   * - New format string API for `format` function
   *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
   *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
   *
   * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
   *
   * @param {Date|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://git.io/fxCyr
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://git.io/fxCyr
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
   *   locale: eoLocale
   * })
   * //=> '2-a de julio 2014'
   *
   * @example
   * // Escape string by single quote characters:
   * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
   * //=> "3 o'clock"
   */

  function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var formatStr = String(dirtyFormatStr);
    var options = dirtyOptions || {};
    var locale$1 = options.locale || locale;
    var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    if (!locale$1.localize) {
      throw new RangeError('locale must contain localize property');
    }

    if (!locale$1.formatLong) {
      throw new RangeError('locale must contain formatLong property');
    }

    var originalDate = toDate(dirtyDate);

    if (!isValid(originalDate)) {
      throw new RangeError('Invalid time value');
    } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


    var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
    var utcDate = subMilliseconds(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale$1,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
      var firstCharacter = substring[0];

      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale$1.formatLong, formatterOptions);
      }

      return substring;
    }).join('').match(formattingTokensRegExp).map(function (substring) {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return "'";
      }

      var firstCharacter = substring[0];

      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }

      var formatter = formatters$1[firstCharacter];

      if (formatter) {
        if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
          throwProtectedError(substring);
        }

        if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
          throwProtectedError(substring);
        }

        return formatter(utcDate, substring, locale$1.localize, formatterOptions);
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      }

      return substring;
    }).join('');
    return result;
  }

  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }

  function assign$1(target, dirtyObject) {
    if (target == null) {
      throw new TypeError('assign requires that input parameter not be null or undefined');
    }

    dirtyObject = dirtyObject || {};

    for (var property in dirtyObject) {
      if (dirtyObject.hasOwnProperty(property)) {
        target[property] = dirtyObject[property];
      }
    }

    return target;
  }
  /**
   * @name isAfter
   * @category Common Helpers
   * @summary Is the first date after the second one?
   *
   * @description
   * Is the first date after the second one?
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date that should be after the other one to return true
   * @param {Date|Number} dateToCompare - the date to compare with
   * @returns {Boolean} the first date is after the second date
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Is 10 July 1989 after 11 February 1987?
   * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> true
   */


  function isAfter(dirtyDate, dirtyDateToCompare) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() > dateToCompare.getTime();
  }
  /**
   * @name isBefore
   * @category Common Helpers
   * @summary Is the first date before the second one?
   *
   * @description
   * Is the first date before the second one?
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * @param {Date|Number} date - the date that should be before the other one to return true
   * @param {Date|Number} dateToCompare - the date to compare with
   * @returns {Boolean} the first date is before the second date
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Is 10 July 1989 before 11 February 1987?
   * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> false
   */


  function isBefore(dirtyDate, dirtyDateToCompare) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() < dateToCompare.getTime();
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    var date = toDate(dirtyDate);
    var day = toInteger$1(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCISODay(dirtyDate, dirtyDay) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var day = toInteger$1(dirtyDay);

    if (day % 7 === 0) {
      day = day - 7;
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var isoWeek = toInteger$1(dirtyISOWeek);
    var diff = getUTCISOWeek(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  } // See issue: https://github.com/date-fns/date-fns/issues/376


  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    var week = toInteger$1(dirtyWeek);
    var diff = getUTCWeek(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE$1 = 60000;
  var MILLISECONDS_IN_SECOND = 1000;
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59
    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

  };
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

  function parseNumericPattern(pattern, string, valueCallback) {
    var matchResult = string.match(pattern);

    if (!matchResult) {
      return null;
    }

    var value = parseInt(matchResult[0], 10);
    return {
      value: valueCallback ? valueCallback(value) : value,
      rest: string.slice(matchResult[0].length)
    };
  }

  function parseTimezonePattern(pattern, string) {
    var matchResult = string.match(pattern);

    if (!matchResult) {
      return null;
    } // Input is 'Z'


    if (matchResult[0] === 'Z') {
      return {
        value: 0,
        rest: string.slice(1)
      };
    }

    var sign = matchResult[1] === '+' ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1 + seconds * MILLISECONDS_IN_SECOND),
      rest: string.slice(matchResult[0].length)
    };
  }

  function parseAnyDigitsSigned(string, valueCallback) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
  }

  function parseNDigits(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

      default:
        return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
    }
  }

  function parseNDigitsSigned(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

      default:
        return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
    }
  }

  function dayPeriodEnumToHours(enumValue) {
    switch (enumValue) {
      case 'morning':
        return 4;

      case 'evening':
        return 17;

      case 'pm':
      case 'noon':
      case 'afternoon':
        return 12;

      case 'am':
      case 'midnight':
      case 'night':
      default:
        return 0;
    }
  }

  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0; // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC

    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;

    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }

    return isCommonEra ? result : 1 - result;
  }

  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // User for validation

  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
   * |  p  |                                |  P  |                                |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   */


  var parsers = {
    // Era
    G: {
      priority: 140,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return match.era(string, {
              width: 'abbreviated'
            }) || match.era(string, {
              width: 'narrow'
            });
          // A, B

          case 'GGGGG':
            return match.era(string, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return match.era(string, {
              width: 'wide'
            }) || match.era(string, {
              width: 'abbreviated'
            }) || match.era(string, {
              width: 'narrow'
            });
        }
      },
      set: function set(date, flags, value, _options) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['R', 'u', 't', 'T']
    },
    // Year
    y: {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
      priority: 130,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'yy'
          };
        };

        switch (token) {
          case 'y':
            return parseNDigits(4, string, valueCallback);

          case 'yo':
            return match.ordinalNumber(string, {
              unit: 'year',
              valueCallback: valueCallback
            });

          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function validate(_date, value, _options) {
        return value.isTwoDigitYear || value.year > 0;
      },
      set: function set(date, flags, value, _options) {
        var currentYear = date.getUTCFullYear();

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
    },
    // Local week-numbering year
    Y: {
      priority: 130,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'YY'
          };
        };

        switch (token) {
          case 'Y':
            return parseNDigits(4, string, valueCallback);

          case 'Yo':
            return match.ordinalNumber(string, {
              unit: 'year',
              valueCallback: valueCallback
            });

          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function validate(_date, value, _options) {
        return value.isTwoDigitYear || value.year > 0;
      },
      set: function set(date, flags, value, options) {
        var currentYear = getUTCWeekYear(date, options);

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      },
      incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
    },
    // ISO week-numbering year
    R: {
      priority: 130,
      parse: function parse(string, token, _match, _options) {
        if (token === 'R') {
          return parseNDigitsSigned(4, string);
        }

        return parseNDigitsSigned(token.length, string);
      },
      set: function set(_date, _flags, value, _options) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek(firstWeekOfYear);
      },
      incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
    },
    // Extended year
    u: {
      priority: 130,
      parse: function parse(string, token, _match, _options) {
        if (token === 'u') {
          return parseNDigitsSigned(4, string);
        }

        return parseNDigitsSigned(token.length, string);
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
    },
    // Quarter
    Q: {
      priority: 120,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
          case 'QQ':
            // 01, 02, 03, 04
            return parseNDigits(token.length, string);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return match.ordinalNumber(string, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return match.quarter(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return match.quarter(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 4;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Stand-alone quarter
    q: {
      priority: 120,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
          case 'qq':
            // 01, 02, 03, 04
            return parseNDigits(token.length, string);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return match.ordinalNumber(string, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return match.quarter(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return match.quarter(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 4;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Month
    M: {
      priority: 110,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'M':
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          // 01, 02, ..., 12

          case 'MM':
            return parseNDigits(2, string, valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return match.ordinalNumber(string, {
              unit: 'month',
              valueCallback: valueCallback
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return match.month(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return match.month(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.month(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Stand-alone month
    L: {
      priority: 110,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          // 01, 02, ..., 12

          case 'LL':
            return parseNDigits(2, string, valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return match.ordinalNumber(string, {
              unit: 'month',
              valueCallback: valueCallback
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return match.month(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return match.month(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.month(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Local week of year
    w: {
      priority: 100,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'w':
            return parseNumericPattern(numericPatterns.week, string);

          case 'wo':
            return match.ordinalNumber(string, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 53;
      },
      set: function set(date, _flags, value, options) {
        return startOfUTCWeek(setUTCWeek(date, value, options), options);
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
    },
    // ISO week of year
    I: {
      priority: 100,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'I':
            return parseNumericPattern(numericPatterns.week, string);

          case 'Io':
            return match.ordinalNumber(string, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 53;
      },
      set: function set(date, _flags, value, options) {
        return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
      },
      incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
    },
    // Day of the month
    d: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'd':
            return parseNumericPattern(numericPatterns.date, string);

          case 'do':
            return match.ordinalNumber(string, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(date, value, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();

        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
    },
    // Day of year
    D: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'D':
          case 'DD':
            return parseNumericPattern(numericPatterns.dayOfYear, string);

          case 'Do':
            return match.ordinalNumber(string, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(date, value, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
    },
    // Day of week
    E: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
    },
    // Local day of week
    e: {
      priority: 90,
      parse: function parse(string, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'e':
          case 'ee':
            // 03
            return parseNDigits(token.length, string, valueCallback);
          // 3rd

          case 'eo':
            return match.ordinalNumber(string, {
              unit: 'day',
              valueCallback: valueCallback
            });
          // Tue

          case 'eee':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(string, {
              width: 'short',
              context: 'formatting'
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
    },
    // Stand-alone local day of week
    c: {
      priority: 90,
      parse: function parse(string, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'c':
          case 'cc':
            // 03
            return parseNDigits(token.length, string, valueCallback);
          // 3rd

          case 'co':
            return match.ordinalNumber(string, {
              unit: 'day',
              valueCallback: valueCallback
            });
          // Tue

          case 'ccc':
            return match.day(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'standalone'
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(string, {
              width: 'short',
              context: 'standalone'
            }) || match.day(string, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 6;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
    },
    // ISO day of week
    i: {
      priority: 90,
      parse: function parse(string, token, match, _options) {
        var valueCallback = function valueCallback(value) {
          if (value === 0) {
            return 7;
          }

          return value;
        };

        switch (token) {
          // 2
          case 'i':
          case 'ii':
            // 02
            return parseNDigits(token.length, string);
          // 2nd

          case 'io':
            return match.ordinalNumber(string, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return match.day(string, {
              width: 'abbreviated',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // T

          case 'iiiii':
            return match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // Tu

          case 'iiiiii':
            return match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
          // Tuesday

          case 'iiii':
          default:
            return match.day(string, {
              width: 'wide',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'abbreviated',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'short',
              context: 'formatting',
              valueCallback: valueCallback
            }) || match.day(string, {
              width: 'narrow',
              context: 'formatting',
              valueCallback: valueCallback
            });
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 7;
      },
      set: function set(date, _flags, value, options) {
        date = setUTCISODay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
    },
    // AM or PM
    a: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaaa':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['b', 'B', 'H', 'K', 'k', 't', 'T']
    },
    // AM, PM, midnight
    b: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbbb':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'B', 'H', 'K', 'k', 't', 'T']
    },
    // in the morning, in the afternoon, in the evening, at night
    B: {
      priority: 80,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBBB':
            return match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return match.dayPeriod(string, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(string, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 't', 'T']
    },
    // Hour [1-12]
    h: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'h':
            return parseNumericPattern(numericPatterns.hour12h, string);

          case 'ho':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 12;
      },
      set: function set(date, _flags, value, _options) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      },
      incompatibleTokens: ['H', 'K', 'k', 't', 'T']
    },
    // Hour [0-23]
    H: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'H':
            return parseNumericPattern(numericPatterns.hour23h, string);

          case 'Ho':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 23;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
    },
    // Hour [0-11]
    K: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'K':
            return parseNumericPattern(numericPatterns.hour11h, string);

          case 'Ko':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 11;
      },
      set: function set(date, _flags, value, _options) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'H', 'k', 't', 'T']
    },
    // Hour [1-24]
    k: {
      priority: 70,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'k':
            return parseNumericPattern(numericPatterns.hour24h, string);

          case 'ko':
            return match.ordinalNumber(string, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 1 && value <= 24;
      },
      set: function set(date, _flags, value, _options) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
    },
    // Minute
    m: {
      priority: 60,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 'm':
            return parseNumericPattern(numericPatterns.minute, string);

          case 'mo':
            return match.ordinalNumber(string, {
              unit: 'minute'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 59;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Second
    s: {
      priority: 50,
      parse: function parse(string, token, match, _options) {
        switch (token) {
          case 's':
            return parseNumericPattern(numericPatterns.second, string);

          case 'so':
            return match.ordinalNumber(string, {
              unit: 'second'
            });

          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function validate(_date, value, _options) {
        return value >= 0 && value <= 59;
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCSeconds(value, 0);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Fraction of second
    S: {
      priority: 30,
      parse: function parse(string, token, _match, _options) {
        var valueCallback = function valueCallback(value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };

        return parseNDigits(token.length, string, valueCallback);
      },
      set: function set(date, _flags, value, _options) {
        date.setUTCMilliseconds(value);
        return date;
      },
      incompatibleTokens: ['t', 'T']
    },
    // Timezone (ISO-8601. +00:00 is `'Z'`)
    X: {
      priority: 10,
      parse: function parse(string, token, _match, _options) {
        switch (token) {
          case 'X':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

          case 'XX':
            return parseTimezonePattern(timezonePatterns.basic, string);

          case 'XXXX':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

          case 'XXXXX':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

          case 'XXX':
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function set(date, flags, value, _options) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      },
      incompatibleTokens: ['t', 'T', 'x']
    },
    // Timezone (ISO-8601)
    x: {
      priority: 10,
      parse: function parse(string, token, _match, _options) {
        switch (token) {
          case 'x':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

          case 'xx':
            return parseTimezonePattern(timezonePatterns.basic, string);

          case 'xxxx':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

          case 'xxxxx':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

          case 'xxx':
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function set(date, flags, value, _options) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      },
      incompatibleTokens: ['t', 'T', 'X']
    },
    // Seconds timestamp
    t: {
      priority: 40,
      parse: function parse(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function set(_date, _flags, value, _options) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: '*'
    },
    // Milliseconds timestamp
    T: {
      priority: 20,
      parse: function parse(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function set(_date, _flags, value, _options) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: '*'
    }
  };
  var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps

  var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

  var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp$1 = /^'(.*?)'?$/;
  var doubleQuoteRegExp$1 = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format string.
   *
   * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters in the format string wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the format string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 5 below the table).
   *
   * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
   * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
   *
   * ```javascript
   * parse('23 AM', 'HH a', new Date())
   * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
   * ```
   *
   * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
   *
   * Accepted format string patterns:
   * | Unit                            |Prior| Pattern | Result examples                   | Notes |
   * |---------------------------------|-----|---------|-----------------------------------|-------|
   * | Era                             | 140 | G..GGG  | AD, BC                            |       |
   * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 |     | GGGGG   | A, B                              |       |
   * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
   * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
   * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
   * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
   * |                                 |     | yyyyy   | ...                               | 2,4   |
   * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
   * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
   * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
   * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
   * |                                 |     | YYYYY   | ...                               | 2,4   |
   * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
   * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
   * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
   * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
   * |                                 |     | RRRRR   | ...                               | 2,4,5 |
   * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
   * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
   * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
   * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
   * |                                 |     | uuuuu   | ...                               | 2,4   |
   * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
   * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
   * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
   * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | qq      | 01, 02, 03, 04                    |       |
   * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
   * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
   * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | MM      | 01, 02, ..., 12                   |       |
   * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | MMMM    | January, February, ..., December  | 2     |
   * |                                 |     | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
   * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | LL      | 01, 02, ..., 12                   |       |
   * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | LLLL    | January, February, ..., December  | 2     |
   * |                                 |     | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
   * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
   * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
   * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
   * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
   * |                                 |     | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
   * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
   * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
   * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 |     | DDDD    | ...                               | 2     |
   * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
   * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
   * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
   * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
   * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
   * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
   * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 5     |
   * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | ee      | 02, 03, ..., 01                   |       |
   * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | cc      | 02, 03, ..., 01                   |       |
   * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
   * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
   * |                                 |     | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 |     | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
   * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
   * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
   * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
   * |                                 |     | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
   * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
   * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | mm      | 00, 01, ..., 59                   |       |
   * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
   * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | ss      | 00, 01, ..., 59                   |       |
   * | Seconds timestamp               |  40 | t       | 512969520                         |       |
   * |                                 |     | tt      | ...                               | 2     |
   * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
   * |                                 |     | SS      | 00, 01, ..., 99                   |       |
   * |                                 |     | SSS     | 000, 0001, ..., 999               |       |
   * |                                 |     | SSSS    | ...                               | 2     |
   * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
   * |                                 |     | TT      | ...                               | 2     |
   * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
   * |                                 |     | XX      | -0800, +0530, Z                   |       |
   * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
   * |                                 |     | xx      | -0800, +0530, +0000               |       |
   * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
   * |                                 |     | PP      | May 29, 1453                      |       |
   * |                                 |     | PPP     | May 29th, 1453                    |       |
   * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
   * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
   * |                                 |     | pp      | 12:00:00 AM                       |       |
   * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
   * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
   * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
   * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular.
   *    In `format` function, they will produce different result:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   *    `parse` will try to match both formatting and stand-alone units interchangably.
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table:
   *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
   *      as wide as the sequence
   *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
   *      These variations are marked with "2" in the last column of the table.
   *
   * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 4. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` will try to guess the century of two digit year by proximity with `backupDate`:
   *
   *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
   *
   *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
   *
   *    while `uu` will just assign the year as is:
   *
   *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
   *
   *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
   *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
   *
   * 5. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
   *
   * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
   *    on the given locale.
   *
   *    using `en-US` locale: `P` => `MM/dd/yyyy`
   *    using `en-US` locale: `p` => `hh:mm a`
   *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
   *    using `pt-BR` locale: `p` => `HH:mm`
   *
   * Values will be assigned to the date in the descending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `backupDate` which works as a context of parsing.
   *
   * `backupDate` must be passed for correct work of the function.
   * If you're not sure which `backupDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `backupDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `backupDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Old `parse` was renamed to `toDate`.
   *   Now `parse` is a new function which parses a string using a provided format.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   toDate('2016-01-01')
   *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
   *   ```
   *
   * @param {String} dateString - the string to parse
   * @param {String} formatString - the string of tokens
   * @param {Date|Number} backupDate - defines values missing from the parsed dateString
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://git.io/fxCyr
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://git.io/fxCyr
   * @returns {Date} the parsed date
   * @throws {TypeError} 3 arguments required
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} `options.locale` must contain `match` property
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in Esperanto locale in the context of 2010 year:
   * import eo from 'date-fns/locale/eo'
   * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
   *   locale: eo
   * })
   * //=> Sun Feb 28 2010 00:00:00
   */

  function parse(dirtyDateString, dirtyFormatString, dirtyBackupDate, dirtyOptions) {
    if (arguments.length < 3) {
      throw new TypeError('3 arguments required, but only ' + arguments.length + ' present');
    }

    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var options = dirtyOptions || {};
    var locale$1 = options.locale || locale;

    if (!locale$1.match) {
      throw new RangeError('locale must contain match property');
    }

    var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }

    var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }

    if (formatString === '') {
      if (dateString === '') {
        return toDate(dirtyBackupDate);
      } else {
        return new Date(NaN);
      }
    }

    var subFnOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale$1 // If timezone isn't specified, it will be set to the system timezone

    };
    var setters = [{
      priority: TIMEZONE_UNIT_PRIORITY,
      set: dateToSystemTimezone,
      index: 0
    }];
    var i;
    var tokens = formatString.match(longFormattingTokensRegExp$1).map(function (substring) {
      var firstCharacter = substring[0];

      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale$1.formatLong, subFnOptions);
      }

      return substring;
    }).join('').match(formattingTokensRegExp$1);
    var usedTokens = [];

    for (i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
        throwProtectedError(token);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token);
      }

      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = void 0;

          for (var _i = 0; _i < usedTokens.length; _i++) {
            var usedToken = usedTokens[_i].token;

            if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
              incompatibleToken = usedTokens[_i];
              break;
            }
          }

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.parse(dateString, token, locale$1.match, subFnOptions);

        if (!parseResult) {
          return new Date(NaN);
        }

        setters.push({
          priority: parser.priority,
          set: parser.set,
          validate: parser.validate,
          value: parseResult.value,
          index: setters.length
        });
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString$1(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return new Date(NaN);
        }
      }
    } // Check if the remaining input contains something other than whitespace


    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }

    var uniquePrioritySetters = setters.map(function (setter) {
      return setter.priority;
    }).sort(function (a, b) {
      return b - a;
    }).filter(function (priority, index, array) {
      return array.indexOf(priority) === index;
    }).map(function (priority) {
      return setters.filter(function (setter) {
        return setter.priority === priority;
      }).reverse();
    }).map(function (setterArray) {
      return setterArray[0];
    });
    var date = toDate(dirtyBackupDate);

    if (isNaN(date)) {
      return new Date(NaN);
    } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


    var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
    var flags = {};

    for (i = 0; i < uniquePrioritySetters.length; i++) {
      var setter = uniquePrioritySetters[i];

      if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

      if (result[0]) {
        utcDate = result[0];
        assign$1(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }

    return utcDate;
  }

  function dateToSystemTimezone(date, flags) {
    if (flags.timestampIsSet) {
      return date;
    }

    var convertedDate = new Date(0);
    convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    return convertedDate;
  }

  function cleanEscapedString$1(input) {
    return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
  }

  var MILLISECONDS_IN_HOUR$1 = 3600000;
  var MILLISECONDS_IN_MINUTE$2 = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  /**
   * @name parseISO
   * @category Common Helpers
   * @summary Parse ISO string
   *
   * @description
   * Parse the given string in ISO 8601 format and return an instance of Date.
   *
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument isn't a string, the function cannot parse the string or
   * the values are invalid, it returns Invalid Date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The previous `parse` implementation was renamed to `parseISO`.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   parseISO('2016-01-01')
   *   ```
   *
   * - `parseISO` now validates separate date and time values in ISO-8601 strings
   *   and returns `Invalid Date` if the date is invalid.
   *
   *   ```javascript
   *   parseISO('2018-13-32')
   *   //=> Invalid Date
   *   ```
   *
   * - `parseISO` now doesn't fall back to `new Date` constructor
   *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
   *
   * @param {String} argument - the value to convert
   * @param {Object} [options] - an object with options.
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = parseISO('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = parseISO('+02014101', { additionalDigits: 1 })
   * //=> Fri Apr 11 2014 00:00:00
   */

  function parseISO(argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger$1(options.additionalDigits);

    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2');
    }

    if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
      return new Date(NaN);
    }

    var dateStrings = splitDateString(argument);
    var date;

    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }

    if (isNaN(date) || !date) {
      return new Date(NaN);
    }

    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);

      if (isNaN(time) || time === null) {
        return new Date(NaN);
      }
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);

      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var fullTime = timestamp + time;
      var fullTimeDate = new Date(fullTime);
      offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST

      var fullTimeDateNextDay = new Date(fullTime);
      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);
      var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - offset;

      if (offsetDiff > 0) {
        offset += offsetDiff;
      }
    }

    return new Date(timestamp + time + offset);
  }

  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;

    if (/:/.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];

      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }

    if (timeString) {
      var token = patterns.timezone.exec(timeString);

      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings;
  }

  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
    var captures = dateString.match(regex); // Invalid ISO-formatted year

    if (!captures) return {
      year: null
    };
    var year = captures[1] && parseInt(captures[1]);
    var century = captures[2] && parseInt(captures[2]);
    return {
      year: century == null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }

  function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return null;
    var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

    if (!captures) return null;
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;

    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }

      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date = new Date(0);

      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }

      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }

  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }

  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures) return null; // Invalid ISO-formatted time

    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);

    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }

    return hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2 + seconds * 1000;
  }

  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(',', '.')) || 0;
  }

  function parseTimezone(timezoneString) {
    if (timezoneString === 'Z') return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    var sign = captures[1] === '+' ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;

    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }

    return sign * (hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2);
  }

  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // Validation functions
  // February is null to handle the leap year (using ||)


  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function isLeapYearIndex$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100;
  }

  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex$1(year) ? 29 : 28));
  }

  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$1(year) ? 366 : 365);
  }

  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }

  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }

    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }

  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  var parseDate$1 = function parseDate(value, format) {
    if (isString_1(value)) {
      return format ? parse(value, format, new Date()) : parseISO(value);
    } else {
      return toDate(value);
    }
  }; // We want to set the messages a superglobal so that imports across files
  // reference the same messages object.


  var _global = typeof window !== 'undefined' ? window : commonjsGlobal || {};
  /**
   * Global validation message registry.
   */


  var messages = _global.__vuemc_validation_messages = _global.__vuemc_validation_messages || new ( /*#__PURE__*/function () {
    function _class() {
      _classCallCheck(this, _class);

      this.reset();
    }
    /**
     * Resets everything to the default configuration.
     */


    _createClass(_class, [{
      key: "reset",
      value: function reset() {
        this.$locale = 'en-us';
        this.$fallback = 'en-us';
        this.$locales = {};
        this.register(en_us);
      }
      /**
       * Sets the active locale.
       *
       * @param {string} locale
       */

    }, {
      key: "locale",
      value: function locale(_locale) {
        this.$locale = toLower_1(_locale);
      }
      /**
       * Registers a language pack.
       */

    }, {
      key: "register",
      value: function register(bundle) {
        var _this = this;

        var locale = toLower_1(bundle.locale);
        each(get_1(bundle, 'messages', {}), function (message, name) {
          set_1(_this.$locales, [locale, name], template_1(message));
        });
      }
      /**
       * Replaces or adds a new message for a given name and optional locale.
       *
       * @param {string} name
       * @param {string} format
       */

    }, {
      key: "set",
      value: function set(name, format, locale) {
        var $template = isString_1(format) ? template_1(format) : format; // Use the given locale.

        if (locale) {
          set_1(this.$locales, [locale, name], $template); // Otherwise use the active locale.
        } else if (this.$locale) {
          set_1(this.$locales, [this.$locale, name], $template); // Otherwise fall back to the default locale.
        } else {
          set_1(this.$locales, [this.$fallback, name], $template);
        }
      }
      /**
       * Returns a formatted string for a given message name and context data.
       *
       * @param {string} name
       * @param {Object} data
       *
       * @returns {string} The formatted message.
       */

    }, {
      key: "get",
      value: function get(name) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Attempt to find the name using the active locale, falling back to the
        // active locale's language, and finally falling back to the default.

        var template = get_1(this.$locales, [this.$locale, name], get_1(this.$locales, [split_1(this.$locale, '-')[0], name], get_1(this.$locales, [this.$fallback, name]))); // Fall back to a blank string so that we don't potentially
        // leak message names or context data into the template.

        if (!template) {
          return '';
        }

        return template(data);
      }
    }]);

    return _class;
  }())();
  /**
   * Rule helpers for easy validation.
   * These can all be used directly in a model's validation configuration.
   *
   * @example
   *
   * import {ascii, length} from 'vue-mc/validation'
   *
   * class User extends Model {
   *     validation() {
   *         return {
   *             password: ascii.and(length(6)),
   *         }
   *     }
   * }
   */

  /**
   * Creates a new validation rule.
   *
   * Rules returned by this function can be chained with `or` and `and`.
   * For example: `ruleA.or(ruleB.and(RuleC)).and(RuleD)`
   *
   * The error message can be set or replaced using `format(message|template)`.
   *
   * @param {Object} config:
   *     - name: Name of the error message.
   *     - data: Context for the error message.
   *     - test: Function accepting (value, model), which should
   *             return `true` if the value is valid.
   *
   * @returns {Function} Validation rule.
   */

  var rule = function rule(config) {
    var name = get_1(config, 'name');
    var data = get_1(config, 'data', {});
    var test = get_1(config, 'test', stubTrue_1);
    /**
     * This is the function that is called when using this rule.
     * It has some extra metadata to allow rule chaining and custom formats.
     */

    var $rule = function $rule(value, attribute, model) {
      // `true` if this rule's core acceptance criteria was met.
      var valid = test(value, attribute, model); // If valid, check that all rules in the "and" chain also pass.

      if (valid) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = $rule._and[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _and = _step.value;

            var result = _and(value, attribute, model); // If any of the chained rules return a string, we know that
            // that rule has failed, and therefore this chain is invalid.


            if (isString_1(result)) {
              return result;
            }
          } // Either there weren't any "and" rules or they all passed.

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true; // This rule's acceptance criteria was not met, but there is a chance
        // that a rule in the "or" chain's might pass.
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = $rule._or[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _or = _step2.value;

            var _result = _or(value, attribute, model); // A rule should either return true in the event of a general
            // "pass", or nothing at all. A failure would have to be a
            // string message (usually from another rule).


            if (_result === true || isUndefined_1(_result)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } // At this point we want to report that this rule has failed, because
      // none of the "and" or "or" chains passed either.
      // Add the invalid value to the message context, which is made available
      // to all rules by default. This allows for ${value} interpolation.


      assign_1(data, {
        attribute: attribute,
        value: value
      }); // This would be a custom format explicitly set on this rule.

      var format = get_1($rule, '_format'); // Use the default message if an explicit format isn't set.

      if (!format) {
        return messages.get(name, data);
      } // Replace the custom format with a template if it's still a string.


      if (isString_1(format)) {
        $rule._format = format = template_1(format);
      }

      return format(data);
    };
    /**
     * @returns {Function} A copy of this rule, so that appending to a chain or
     *                     setting a custom format doesn't modify the base rule.
     */


    $rule.copy = function () {
      return assign_1(rule({
        name: name,
        test: test,
        data: data
      }), pick_1($rule, ['_format', '_and', '_or']));
    };
    /**
     * Sets a custom error message format on this rule.
     *
     * @param {string|Function} format
     */


    $rule.format = function (format) {
      return assign_1($rule.copy(), {
        _format: format
      });
    };
    /**
     * Adds another rule or function to this rule's OR chain. If the given rule
     * passes when this one fails, this rule will return `true`.
     *
     * @param {Function|Function[]} rules One or more functions to add to the chain.
     */


    $rule.or = function (rules) {
      return assign_1($rule.copy(), {
        _or: concat_1($rule._or, rules)
      });
    };
    /**
     * Adds another rule or function to this rule's AND chain. If the given rule
     * fails when this one passes, this rule will return `false`.
     *
     * @param {Function|Function[]} rules One or more functions to add to the chain.
     */


    $rule.and = function (rules) {
      return assign_1($rule.copy(), {
        _and: concat_1($rule._and, rules)
      });
    };

    $rule._and = []; // "and" chain

    $rule._or = []; // "or" chain

    $rule._format = null; // Custom format

    return $rule;
  };
  /**
   * AVAILABLE RULES
   */

  /**
   * Checks if the value is after a given date string or `Date` object.
   */


  var after = function after(date) {
    return rule({
      name: 'after',
      data: {
        date: date
      },
      test: function test(value) {
        return isAfter(parseDate$1(value), parseDate$1(date));
      }
    });
  };
  /**
   * Checks if a value only has letters.
   */


  var alpha = rule({
    name: 'alpha',
    test: function test(value) {
      return isString_1(value) && isAlpha(deburr_1(value));
    }
  });
  /**
   * Checks if a value only has letters or numbers.
   */

  var alphanumeric = rule({
    name: 'alphanumeric',
    test: function test(value) {
      return isString_1(value) && isAlphanumeric(deburr_1(value));
    }
  });
  /**
   * Checks if a value is an array.
   */

  var array = rule({
    name: 'array',
    test: isArray_1
  });
  /**
   * Checks if a value is a string consisting only of ASCII characters.
   */

  var ascii = rule({
    name: 'ascii',
    test: function test(value) {
      return isString_1(value) && /^[\x00-\x7F]+$/.test(value);
    }
  });
  /**
   * Checks if a value is a valid Base64 string.
   */

  var base64 = rule({
    name: 'base64',
    test: function test(value) {
      return isString_1(value) && isBase64(value);
    }
  });
  /**
   * Checks if a value is before a given date string or `Date` object.
   */

  var before = function before(date) {
    return rule({
      name: 'before',
      data: {
        date: date
      },
      test: function test(value) {
        return isBefore(parseDate$1(value), parseDate$1(date));
      }
    });
  };
  /**
   * Checks if a value is between a given minimum or maximum, inclusive by default.
   */


  var between = function between(min, max) {
    var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var _min = +(isString_1(min) ? parseDate$1(min) : min);

    var _max = +(isString_1(max) ? parseDate$1(max) : max);

    return rule({
      data: {
        min: min,
        max: max
      },
      name: inclusive ? 'between_inclusive' : 'between',
      test: function test(value) {
        var _value = +(isString_1(value) ? parseDate$1(value) : value);

        return inclusive ? gte_1(_value, _min) && lte_1(_value, _max) : gt_1(_value, _min) && lt_1(_value, _max);
      }
    });
  };
  /**
   * Checks if a value is a boolean (strictly true or false).
   */


  var _boolean = rule({
    name: 'boolean',
    test: isBoolean_1
  });

  var creditcard = rule({
    name: 'creditcard',
    test: function test(value) {
      return isString_1(value) && isCreditCard(value);
    }
  });
  /**
   * Checks if a value is parseable as a date.
   */

  var date = rule({
    name: 'date',
    test: function test(value) {
      return isValid(parseDate$1(value));
    }
  });
  /**
   * Checks if a value matches the given date format.
   *
   * @see https://date-fns.org/v2.0.0-alpha.9/docs/format
   */

  var dateformat = function dateformat(format$1) {
    return rule({
      name: 'dateformat',
      data: {
        format: format$1
      },
      test: function test(value) {
        try {
          return isValid(parseDate$1(value.toString(), format$1)) && format(parseDate$1(value.toString(), format$1), format$1) === value.toString();
        } catch (error) {
          if (error instanceof RangeError) {
            return false;
          } else {
            throw error;
          }
        }
      }
    });
  };
  /**
   * Checks if a value is not `undefined`
   */


  var defined = rule({
    name: 'defined',
    test: function test(value) {
      return !isUndefined_1(value);
    }
  });
  /**
   * Checks if a value is a valid email address.
   */

  var email = rule({
    name: 'email',
    test: function test(value) {
      return isString_1(value) && isEmail(value);
    }
  });
  /**
   * Checks if value is considered empty.
   *
   * @see https://lodash.com/docs/#isEmpty
   */

  var empty = rule({
    name: 'empty',
    test: isEmpty_1
  });
  /**
   * Alias for `equals`
   */

  var equal = function equal(other) {
    return equals(other);
  };
  /**
   * Checks if a value equals the given value.
   */


  var equals = function equals(other) {
    return rule({
      name: 'equals',
      data: {
        other: other
      },
      test: function test(value) {
        return isEqual_1(value, other);
      }
    });
  };
  /**
   * Checks if a value is greater than a given minimum.
   */


  var gt$1 = function gt(min) {
    return rule({
      name: 'gt',
      data: {
        min: min
      },
      test: function test(value) {
        return gt_1(value, min);
      }
    });
  };
  /**
   * Checks if a value is greater than or equal to a given minimum.
   */


  var gte$1 = function gte(min) {
    return rule({
      name: 'gte',
      data: {
        min: min
      },
      test: function test(value) {
        return gte_1(value, min);
      }
    });
  };
  /**
   * Checks if a value is an integer.
   */


  var integer = rule({
    name: 'integer',
    test: isInteger_1
  });
  /**
   * Checks if a value is a valid IP address.
   */

  var ip = rule({
    name: 'ip',
    test: function test(value) {
      return isString_1(value) && isIP(value);
    }
  });
  /**
   * Checks if a value is a zero-length string.
   */

  var isblank = rule({
    name: 'isblank',
    test: function test(value) {
      return value === '';
    }
  });
  /**
   * Checks if a value is `null` or `undefined`.
   */

  var isnil = rule({
    name: 'isnil',
    test: isNil_1
  });
  /**
   * Checks if a value is `null`.
   */

  var isnull = rule({
    name: 'isnull',
    test: isNull_1
  });
  /**
   * Checks if a value is a valid ISO8601 date string.
   */

  var iso8601 = rule({
    name: 'iso8601',
    test: function test(value) {
      return isString_1(value) && isISO8601(value);
    }
  });
  /**
   * Checks if a value is valid JSON.
   */

  var json = rule({
    name: 'json',
    test: function test(value) {
      return isString_1(value) && isJSON(value);
    }
  });
  /**
   * Checks if a value's length is at least a given minimum, and no more than an
   * optional maximum.
   *
   * @see https://lodash.com/docs/#toLength
   */

  var length = function length(min, max) {
    // No maximum means the value must be *at least* the minimum.
    if (isUndefined_1(max)) {
      return rule({
        name: 'length',
        data: {
          min: min,
          max: max
        },
        test: function test(value) {
          return size_1(value) >= min;
        }
      });
    } // Minimum and maximum given, so check that the value is within the range.


    return rule({
      name: 'length_between',
      data: {
        min: min,
        max: max
      },
      test: function test(value) {
        var length = size_1(value);
        return length >= min && length <= max;
      }
    });
  };
  /**
   * Checks if a value is less than a given maximum.
   */


  var lt$1 = function lt(max) {
    return rule({
      name: 'lt',
      data: {
        max: max
      },
      test: function test(value) {
        return lt_1(value, max);
      }
    });
  };
  /**
   * Checks if a value is less than or equal to a given maximum.
   */


  var lte$1 = function lte(max) {
    return rule({
      name: 'lte',
      data: {
        max: max
      },
      test: function test(value) {
        return lte_1(value, max);
      }
    });
  };
  /**
   * Checks if a value matches a given regular expression string or RegExp.
   */


  var match$1 = function match(pattern) {
    return rule({
      name: 'match',
      data: {
        pattern: pattern
      },
      test: function test(value) {
        return new RegExp(pattern).test(value);
      }
    });
  };
  /**
   * Alias for `lte`.
   */


  var max = function max(_max2) {
    return lte$1(_max2);
  };
  /**
   * Alias for `gte`.
   */


  var min = function min(_min2) {
    return gte$1(_min2);
  };
  /**
   * Checks if a value is negative.
   */


  var negative = rule({
    name: 'negative',
    test: function test(value) {
      return toNumber_1(value) < 0;
    }
  });
  /**
   *
   */

  var not = function not() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return rule({
      name: 'not',
      test: function test(value) {
        return !includes_1(values, value);
      }
    });
  };
  /**
   * Checks if a value is a number (integer or float), excluding `NaN`.
   */


  var number = rule({
    name: 'number',
    test: function test(value) {
      return _isFinite(value);
    }
  });
  /**
   * Checks if a value is a number or numeric string, excluding `NaN`.
   */

  var numeric = rule({
    name: 'numeric',
    test: function test(value) {
      return isNumber_1(value) && !_isNaN(value) || value && isString_1(value) && !_isNaN(toNumber_1(value));
    }
  });
  /**
   * Checks if a value is an object, excluding arrays and functions.
   */

  var object = rule({
    name: 'object',
    test: function test(value) {
      return isObject_1(value) && !isArray_1(value) && !isFunction_1(value);
    }
  });
  /**
   * Checks if a value is positive.
   */

  var positive = rule({
    name: 'positive',
    test: function test(value) {
      return toNumber_1(value) > 0;
    }
  });
  /**
   * Checks if a value is present, ie. not `null`, `undefined`, or a blank string.
   */

  var required = rule({
    name: 'required',
    test: function test(value) {
      return !(isNil_1(value) || value === '');
    }
  });
  /**
   * Checks if a value equals another attribute's value.
   */

  var same = function same(other) {
    return rule({
      name: 'same',
      data: {
        other: other
      },
      test: function test(value, attribute, model) {
        return isEqual_1(value, model.get(other));
      }
    });
  };
  /**
   * Checks if a value is a string.
   */


  var string = rule({
    name: 'string',
    test: isString_1
  });
  /**
   * Checks if a value is a valid URL string.
   */

  var url = rule({
    name: 'url',
    test: function test(value) {
      return isString_1(value) && isURL(value);
    }
  });
  /**
   * Checks if a value is a valid UUID.
   */

  var uuid = rule({
    name: 'uuid',
    test: function test(value) {
      return isString_1(value) && isUUID(value);
    }
  });
  exports.after = after;
  exports.alpha = alpha;
  exports.alphanumeric = alphanumeric;
  exports.array = array;
  exports.ascii = ascii;
  exports.base64 = base64;
  exports.before = before;
  exports.between = between;
  exports["boolean"] = _boolean;
  exports.creditcard = creditcard;
  exports.date = date;
  exports.dateformat = dateformat;
  exports.defined = defined;
  exports.email = email;
  exports.empty = empty;
  exports.equal = equal;
  exports.equals = equals;
  exports.gt = gt$1;
  exports.gte = gte$1;
  exports.integer = integer;
  exports.ip = ip;
  exports.isblank = isblank;
  exports.isnil = isnil;
  exports.isnull = isnull;
  exports.iso8601 = iso8601;
  exports.json = json;
  exports.length = length;
  exports.lt = lt$1;
  exports.lte = lte$1;
  exports.match = match$1;
  exports.max = max;
  exports.messages = messages;
  exports.min = min;
  exports.negative = negative;
  exports.not = not;
  exports.number = number;
  exports.numeric = numeric;
  exports.object = object;
  exports.positive = positive;
  exports.required = required;
  exports.rule = rule;
  exports.same = same;
  exports.string = string;
  exports.url = url;
  exports.uuid = uuid;
})(validation);

class Branch extends Model {
    defaults() {
        return {
            id: null,
            company_id: null,
            country_id: null,
            state_id: null,
            town_id: null,
            active: null,
            is_default: null,
            name: null,
            code: null,
            address: null,
            phone: null,
            email: null,
            ucfe_code: null,
            ucfe_terminal: null,
            ucfe_password: null,
        };
    }
    mutations() {
        return {
            id: (id) => toNumber(id) || null,
            company_id: (id) => toNumber(id) || null,
            country_id: (id) => toNumber(id) || null,
            state_id: (id) => toNumber(id) || null,
            town_id: (id) => toNumber(id) || null,
        };
    }
    validation() {
        return {
            company: validation.required
        };
    }
    routes() {
        return {
            fetch: "branches.show",
            create: "branches.store",
            update: "branches.update",
            delete: "branches.destroy",
        };
    }
}

class Branches extends Collection {
    model() {
        return Branch;
    }
    routes() {
        return {
            fetch: "branches.index",
        };
    }
    byCompany(iCompanyID) {
        return this.filterBy({ company: iCompanyID });
    }
    byActive() {
        return this.filterBy({ active: 1 });
    }
    byDefault() {
        return this.filterBy({ default: 1 });
    }
}

class Company extends Model {
    defaults() {
        return {
            id: null,
            name: null,
            active: true,
            slug: null,
            code: null,
            description: null,
            preview_image: null,
            doc_id: null,
            doc_type: null,
            address: null,
            country_id: null,
            state_id: null,
            town_id: null,
        };
    }
    mutations() {
        return {
            id: (id) => toNumber(id) || null,
            country_id: (id) => toNumber(id) || null,
            state_id: (id) => toNumber(id) || null,
            town_id: (id) => toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "companies.show",
            create: "companies.store",
            update: "companies.update",
            delete: "companies.destroy",
        };
    }
}

class Companies extends Collection {
    model() {
        return Company;
    }
    routes() {
        return {
            fetch: "companies.index",
        };
    }
}

class CurrencyRate extends Model {
    defaults() {
        return {
            id: null,
            currency_id: null,
            name: null,
            rate: null,
            rated_at: null,
        };
    }
    mutations() {
        return {
            id: (id) => toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "currencyrates.show",
            create: "currencyrates.store",
            update: "currencyrates.update",
            delete: "currencyrates.destroy",
        };
    }
}

class CurrencyRates extends Collection {
    model() {
        return CurrencyRate;
    }
    routes() {
        return {
            fetch: "currencyrates.index",
        };
    }
}

class PaymentTerm extends Model {
    defaults() {
        return {
            id: null,
            active: false,
            cash: false,
            name: null,
            code: null,
            type: "fixed",
            frequency: "month",
            frequency_interval: 0,
            cycles: 0,
            delay: 0,
            description: null,
        };
    }
    mutations() {
        return {
            id: (id) => toNumber(id) || null,
        };
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "paymentterms.show",
            create: "paymentterms.store",
            update: "paymentterms.update",
            delete: "paymentterms.destroy",
        };
    }
}

class PaymentTerms extends Collection {
    model() {
        return PaymentTerm;
    }
    routes() {
        return {
            fetch: "paymentterms.index",
        };
    }
}

class Settings extends Model {
    defaults() {
        return {
            preview_image: null,
        };
    }
    mutations() {
        return {};
    }
    validation() {
        return {};
    }
    routes() {
        return {
            fetch: "settings.show",
            create: "settings.store",
        };
    }
}

export { Branch, Branches, Companies, Company, CurrencyRate, CurrencyRates, PaymentTerm, PaymentTerms, Settings };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1jLWd3LmVzLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvdnVlLW1jL3ZhbGlkYXRpb24vaW5kZXguanMiLCIuLi9zcmMvbW9kZWxzL0JyYW5jaC50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9CcmFuY2hlcy50cyIsIi4uL3NyYy9tb2RlbHMvQ29tcGFueS50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9Db21wYW5pZXMudHMiLCIuLi9zcmMvbW9kZWxzL0N1cnJlbmN5UmF0ZS50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9DdXJyZW5jeVJhdGVzLnRzIiwiLi4vc3JjL21vZGVscy9QYXltZW50VGVybS50cyIsIi4uL3NyYy9jb2xsZWN0aW9ucy9QYXltZW50VGVybXMudHMiLCIuLi9zcmMvbW9kZWxzL1NldHRpbmdzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG4vKipcbiAqIEFmcmlrYWFuc1xuICovXG52YXIgZW5fdXMgPSB7XG4gIGxvY2FsZTogJ2VuLVVTJyxcbiAgbWVzc2FnZXM6IHtcbiAgICBhZnRlcjogJ011c3QgYmUgYWZ0ZXIgJHtkYXRlfScsXG4gICAgYWxwaGE6ICdDYW4gb25seSB1c2UgbGV0dGVycycsXG4gICAgYWxwaGFudW1lcmljOiAnTXVzdCBiZSBhbHBoYW51bWVyaWMnLFxuICAgIGFycmF5OiAnTXVzdCBiZSBhbiBhcnJheScsXG4gICAgYXNjaWk6ICdNdXN0IGJlIEFTQ0lJJyxcbiAgICBiYXNlNjQ6ICdNdXN0IGJlIHZhbGlkIEJhc2U2NCcsXG4gICAgYmVmb3JlOiAnTXVzdCBiZSBiZWZvcmUgJHtkYXRlfScsXG4gICAgYmV0d2VlbjogJ011c3QgYmUgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fScsXG4gICAgYmV0d2Vlbl9pbmNsdXNpdmU6ICdNdXN0IGJlIGJldHdlZW4gJHttaW59IGFuZCAke21heH0sIGluY2x1c2l2ZScsXG4gICAgXCJib29sZWFuXCI6ICdNdXN0IGJlIHRydWUgb3IgZmFsc2UnLFxuICAgIGNyZWRpdGNhcmQ6ICdNdXN0IGJlIGEgdmFsaWQgY3JlZGl0IGNhcmQgbnVtYmVyJyxcbiAgICBkYXRlOiAnTXVzdCBiZSBhIHZhbGlkIGRhdGUnLFxuICAgIGRhdGVmb3JtYXQ6ICdNdXN0IHVzZSBcIiR7Zm9ybWF0fVwiIGZvcm1hdCcsXG4gICAgZGVmaW5lZDogJ1JlcXVpcmVkJyxcbiAgICBlbWFpbDogJ011c3QgYmUgYSB2YWxpZCBlbWFpbCBhZGRyZXNzJyxcbiAgICBlbXB0eTogJ011c3QgYmUgZW1wdHknLFxuICAgIGVxdWFsczogJ011c3QgYmUgZXF1YWwgdG8gJHtvdGhlcn0nLFxuICAgIGd0OiAnTXVzdCBiZSBncmVhdGVyIHRoYW4gJHttaW59JyxcbiAgICBndGU6ICdNdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn0nLFxuICAgIGludGVnZXI6ICdNdXN0IGJlIGFuIGludGVnZXInLFxuICAgIGlwOiAnTXVzdCBiZSBhIHZhbGlkIElQIGFkZHJlc3MnLFxuICAgIGlzYmxhbms6ICdNYXkgbm90IGJlIGJsYW5rJyxcbiAgICBpc25pbDogJ1JlcXVpcmVkJyxcbiAgICBpc251bGw6ICdSZXF1aXJlZCcsXG4gICAgaXNvODYwMTogJ011c3QgYmUgYSB2YWxpZCBJU084NjAxIGRhdGUnLFxuICAgIGpzb246ICdNdXN0IGJlIGEgdmFsaWQgSlNPTicsXG4gICAgbGVuZ3RoOiAnTXVzdCBoYXZlIGEgbGVuZ3RoIG9mIGF0IGxlYXN0ICR7bWlufScsXG4gICAgbGVuZ3RoX2JldHdlZW46ICdNdXN0IGhhdmUgYSBsZW5ndGggYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fScsXG4gICAgbHQ6ICdNdXN0IGJlIGxlc3MgdGhhbiAke21heH0nLFxuICAgIGx0ZTogJ011c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fScsXG4gICAgbWF0Y2g6ICdNdXN0IG1hdGNoIFwiJHtwYXR0ZXJufVwiJyxcbiAgICBuZWdhdGl2ZTogJ011c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgIG5vdDogJ0NhbiBub3QgYmUgJHt2YWx1ZX0nLFxuICAgIG51bWJlcjogJ011c3QgYmUgYSBudW1iZXInLFxuICAgIG51bWVyaWM6ICdNdXN0IGJlIG51bWVyaWMnLFxuICAgIG9iamVjdDogJ011c3QgYmUgYW4gb2JqZWN0JyxcbiAgICBwb3NpdGl2ZTogJ011c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICAgIHJlcXVpcmVkOiAnUmVxdWlyZWQnLFxuICAgIHNhbWU6ICdNdXN0IGhhdmUgdGhlIHNhbWUgdmFsdWUgYXMgXCIke290aGVyfVwiJyxcbiAgICBzdHJpbmc6ICdNdXN0IGJlIGEgc3RyaW5nJyxcbiAgICB1cmw6ICdNdXN0IGJlIGEgdmFsaWQgVVJMJyxcbiAgICB1dWlkOiAnTXVzdCBiZSBhIHZhbGlkIFVVSUQnXG4gIH1cbiAgLyoqXG4gICAqIFBlcnNpYW4gLSBJc2xhbWljIFJlcHVibGljIG9mIElyYW5cbiAgICovXG5cbn07XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgYXNzZXJ0U3RyaW5nXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnRTdHJpbmc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuXG4gIGlmICghaXNTdHJpbmcpIHtcbiAgICB2YXIgaW52YWxpZFR5cGU7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgIGludmFsaWRUeXBlID0gJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhbGlkVHlwZSA9IF90eXBlb2YoaW5wdXQpO1xuXG4gICAgICBpZiAoaW52YWxpZFR5cGUgPT09ICdvYmplY3QnICYmIGlucHV0LmNvbnN0cnVjdG9yICYmIGlucHV0LmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCduYW1lJykpIHtcbiAgICAgICAgaW52YWxpZFR5cGUgPSBpbnB1dC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZFR5cGUgPSBcImEgXCIuY29uY2F0KGludmFsaWRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCBcIi5jb25jYXQoaW52YWxpZFR5cGUsIFwiLlwiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXNzZXJ0U3RyaW5nXzEpO1xuXG52YXIgYWxwaGFfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29tbWFEZWNpbWFsID0gZXhwb3J0cy5kb3REZWNpbWFsID0gZXhwb3J0cy5hcmFiaWNMb2NhbGVzID0gZXhwb3J0cy5lbmdsaXNoTG9jYWxlcyA9IGV4cG9ydHMuZGVjaW1hbCA9IGV4cG9ydHMuYWxwaGFudW1lcmljID0gZXhwb3J0cy5hbHBoYSA9IHZvaWQgMDtcbnZhciBhbHBoYSA9IHtcbiAgJ2VuLVVTJzogL15bQS1aXSskL2ksXG4gICdiZy1CRyc6IC9eW9CQLdCvXSskL2ksXG4gICdjcy1DWic6IC9eW0EtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0rJC9pLFxuICAnZGEtREsnOiAvXltBLVrDhsOYw4VdKyQvaSxcbiAgJ2RlLURFJzogL15bQS1aw4TDlsOcw59dKyQvaSxcbiAgJ2VsLUdSJzogL15bzpEtz4ldKyQvaSxcbiAgJ2VzLUVTJzogL15bQS1aw4HDicONw5HDk8Oaw5xdKyQvaSxcbiAgJ2ZyLUZSJzogL15bQS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhdKyQvaSxcbiAgJ2l0LUlUJzogL15bQS1aw4DDicOIw4zDjsOTw5LDmV0rJC9pLFxuICAnbmItTk8nOiAvXltBLVrDhsOYw4VdKyQvaSxcbiAgJ25sLU5MJzogL15bQS1aw4HDicOLw4/Dk8OWw5zDml0rJC9pLFxuICAnbm4tTk8nOiAvXltBLVrDhsOYw4VdKyQvaSxcbiAgJ2h1LUhVJzogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXSskL2ksXG4gICdwbC1QTCc6IC9eW0EtWsSExIbEmMWaxYHFg8OTxbvFuV0rJC9pLFxuICAncHQtUFQnOiAvXltBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0rJC9pLFxuICAncnUtUlUnOiAvXlvQkC3Qr9CBXSskL2ksXG4gICdzbC1TSSc6IC9eW0EtWsSMxIbEkMWgxb1dKyQvaSxcbiAgJ3NrLVNLJzogL15bQS1aw4HEjMSOw4nDjcWHw5PFoMWkw5rDncW9xLnFlMS9w4TDlF0rJC9pLFxuICAnc3ItUlNAbGF0aW4nOiAvXltBLVrEjMSGxb3FoMSQXSskL2ksXG4gICdzci1SUyc6IC9eW9CQLdCv0ILQiNCJ0IrQi9CPXSskL2ksXG4gICdzdi1TRSc6IC9eW0EtWsOFw4TDll0rJC9pLFxuICAndHItVFInOiAvXltBLVrDh8SexLDEscOWxZ7DnF0rJC9pLFxuICAndWstVUEnOiAvXlvQkC3QqdCs0K7Qr9CESdCH0pDRll0rJC9pLFxuICAna3UtSVEnOiAvXlvYptin2KjZvtiq2Kzahtit2K7Yr9ix2pXYstqY2LPYtNi52LrZgdqk2YLaqdqv2YTatdmF2YbZiNuG2r7blduM247Ziti32KTYq9ii2KXYo9mD2LbYtdip2LjYsF0rJC9pLFxuICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXSskL1xufTtcbmV4cG9ydHMuYWxwaGEgPSBhbHBoYTtcbnZhciBhbHBoYW51bWVyaWMgPSB7XG4gICdlbi1VUyc6IC9eWzAtOUEtWl0rJC9pLFxuICAnYmctQkcnOiAvXlswLTnQkC3Qr10rJC9pLFxuICAnY3MtQ1onOiAvXlswLTlBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1dKyQvaSxcbiAgJ2RhLURLJzogL15bMC05QS1aw4bDmMOFXSskL2ksXG4gICdkZS1ERSc6IC9eWzAtOUEtWsOEw5bDnMOfXSskL2ksXG4gICdlbC1HUic6IC9eWzAtOc6RLc+JXSskL2ksXG4gICdlcy1FUyc6IC9eWzAtOUEtWsOBw4nDjcORw5PDmsOcXSskL2ksXG4gICdmci1GUic6IC9eWzAtOUEtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSskL2ksXG4gICdpdC1JVCc6IC9eWzAtOUEtWsOAw4nDiMOMw47Dk8OSw5ldKyQvaSxcbiAgJ2h1LUhVJzogL15bMC05QS1aw4HDicONw5PDlsWQw5rDnMWwXSskL2ksXG4gICduYi1OTyc6IC9eWzAtOUEtWsOGw5jDhV0rJC9pLFxuICAnbmwtTkwnOiAvXlswLTlBLVrDgcOJw4vDj8OTw5bDnMOaXSskL2ksXG4gICdubi1OTyc6IC9eWzAtOUEtWsOGw5jDhV0rJC9pLFxuICAncGwtUEwnOiAvXlswLTlBLVrEhMSGxJjFmsWBxYPDk8W7xbldKyQvaSxcbiAgJ3B0LVBUJzogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKyQvaSxcbiAgJ3J1LVJVJzogL15bMC050JAt0K/QgV0rJC9pLFxuICAnc2wtU0knOiAvXlswLTlBLVrEjMSGxJDFoMW9XSskL2ksXG4gICdzay1TSyc6IC9eWzAtOUEtWsOBxIzEjsOJw43Fh8OTxaDFpMOaw53FvcS5xZTEvcOEw5RdKyQvaSxcbiAgJ3NyLVJTQGxhdGluJzogL15bMC05QS1axIzEhsW9xaDEkF0rJC9pLFxuICAnc3ItUlMnOiAvXlswLTnQkC3Qr9CC0IjQidCK0IvQj10rJC9pLFxuICAnc3YtU0UnOiAvXlswLTlBLVrDhcOEw5ZdKyQvaSxcbiAgJ3RyLVRSJzogL15bMC05QS1aw4fEnsSwxLHDlsWew5xdKyQvaSxcbiAgJ3VrLVVBJzogL15bMC050JAt0KnQrNCu0K/QhEnQh9KQ0ZZdKyQvaSxcbiAgJ2t1LUlRJzogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYptin2KjZvtiq2Kzahtit2K7Yr9ix2pXYstqY2LPYtNi52LrZgdqk2YLaqdqv2YTatdmF2YbZiNuG2r7blduM247Ziti32KTYq9ii2KXYo9mD2LbYtdip2LjYsF0rJC9pLFxuICBhcjogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKyQvXG59O1xuZXhwb3J0cy5hbHBoYW51bWVyaWMgPSBhbHBoYW51bWVyaWM7XG52YXIgZGVjaW1hbCA9IHtcbiAgJ2VuLVVTJzogJy4nLFxuICBhcjogJ9mrJ1xufTtcbmV4cG9ydHMuZGVjaW1hbCA9IGRlY2ltYWw7XG52YXIgZW5nbGlzaExvY2FsZXMgPSBbJ0FVJywgJ0dCJywgJ0hLJywgJ0lOJywgJ05aJywgJ1pBJywgJ1pNJ107XG5leHBvcnRzLmVuZ2xpc2hMb2NhbGVzID0gZW5nbGlzaExvY2FsZXM7XG5cbmZvciAodmFyIGxvY2FsZSwgaSA9IDA7IGkgPCBlbmdsaXNoTG9jYWxlcy5sZW5ndGg7IGkrKykge1xuICBsb2NhbGUgPSBcImVuLVwiLmNvbmNhdChlbmdsaXNoTG9jYWxlc1tpXSk7XG4gIGFscGhhW2xvY2FsZV0gPSBhbHBoYVsnZW4tVVMnXTtcbiAgYWxwaGFudW1lcmljW2xvY2FsZV0gPSBhbHBoYW51bWVyaWNbJ2VuLVVTJ107XG4gIGRlY2ltYWxbbG9jYWxlXSA9IGRlY2ltYWxbJ2VuLVVTJ107XG59IC8vIFNvdXJjZTogaHR0cDovL3d3dy5sb2NhbGVwbGFuZXQuY29tL2phdmEvXG5cblxudmFyIGFyYWJpY0xvY2FsZXMgPSBbJ0FFJywgJ0JIJywgJ0RaJywgJ0VHJywgJ0lRJywgJ0pPJywgJ0tXJywgJ0xCJywgJ0xZJywgJ01BJywgJ1FNJywgJ1FBJywgJ1NBJywgJ1NEJywgJ1NZJywgJ1ROJywgJ1lFJ107XG5leHBvcnRzLmFyYWJpY0xvY2FsZXMgPSBhcmFiaWNMb2NhbGVzO1xuXG5mb3IgKHZhciBfbG9jYWxlLCBfaSA9IDA7IF9pIDwgYXJhYmljTG9jYWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgX2xvY2FsZSA9IFwiYXItXCIuY29uY2F0KGFyYWJpY0xvY2FsZXNbX2ldKTtcbiAgYWxwaGFbX2xvY2FsZV0gPSBhbHBoYS5hcjtcbiAgYWxwaGFudW1lcmljW19sb2NhbGVdID0gYWxwaGFudW1lcmljLmFyO1xuICBkZWNpbWFsW19sb2NhbGVdID0gZGVjaW1hbC5hcjtcbn0gLy8gU291cmNlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZWNpbWFsX21hcmtcblxuXG52YXIgZG90RGVjaW1hbCA9IFtdO1xuZXhwb3J0cy5kb3REZWNpbWFsID0gZG90RGVjaW1hbDtcbnZhciBjb21tYURlY2ltYWwgPSBbJ2JnLUJHJywgJ2NzLUNaJywgJ2RhLURLJywgJ2RlLURFJywgJ2VsLUdSJywgJ2VzLUVTJywgJ2ZyLUZSJywgJ2l0LUlUJywgJ2t1LUlRJywgJ2h1LUhVJywgJ25iLU5PJywgJ25uLU5PJywgJ25sLU5MJywgJ3BsLVBMJywgJ3B0LVBUJywgJ3J1LVJVJywgJ3NsLVNJJywgJ3NyLVJTQGxhdGluJywgJ3NyLVJTJywgJ3N2LVNFJywgJ3RyLVRSJywgJ3VrLVVBJ107XG5leHBvcnRzLmNvbW1hRGVjaW1hbCA9IGNvbW1hRGVjaW1hbDtcblxuZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZG90RGVjaW1hbC5sZW5ndGg7IF9pMisrKSB7XG4gIGRlY2ltYWxbZG90RGVjaW1hbFtfaTJdXSA9IGRlY2ltYWxbJ2VuLVVTJ107XG59XG5cbmZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGNvbW1hRGVjaW1hbC5sZW5ndGg7IF9pMysrKSB7XG4gIGRlY2ltYWxbY29tbWFEZWNpbWFsW19pM11dID0gJywnO1xufVxuXG5hbHBoYVsncHQtQlInXSA9IGFscGhhWydwdC1QVCddO1xuYWxwaGFudW1lcmljWydwdC1CUiddID0gYWxwaGFudW1lcmljWydwdC1QVCddO1xuZGVjaW1hbFsncHQtQlInXSA9IGRlY2ltYWxbJ3B0LVBUJ107IC8vIHNlZSAjODYyXG5cbmFscGhhWydwbC1QbCddID0gYWxwaGFbJ3BsLVBMJ107XG5hbHBoYW51bWVyaWNbJ3BsLVBsJ10gPSBhbHBoYW51bWVyaWNbJ3BsLVBMJ107XG5kZWNpbWFsWydwbC1QbCddID0gZGVjaW1hbFsncGwtUEwnXTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFscGhhXzEpO1xudmFyIGFscGhhXzIgPSBhbHBoYV8xLmNvbW1hRGVjaW1hbDtcbnZhciBhbHBoYV8zID0gYWxwaGFfMS5kb3REZWNpbWFsO1xudmFyIGFscGhhXzQgPSBhbHBoYV8xLmFyYWJpY0xvY2FsZXM7XG52YXIgYWxwaGFfNSA9IGFscGhhXzEuZW5nbGlzaExvY2FsZXM7XG52YXIgYWxwaGFfNiA9IGFscGhhXzEuZGVjaW1hbDtcbnZhciBhbHBoYV83ID0gYWxwaGFfMS5hbHBoYW51bWVyaWM7XG52YXIgYWxwaGFfOCA9IGFscGhhXzEuYWxwaGE7XG5cbnZhciBpc0FscGhhXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FscGhhO1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBbHBoYShzdHIpIHtcbiAgdmFyIGxvY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2VuLVVTJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAobG9jYWxlIGluIGFscGhhXzEuYWxwaGEpIHtcbiAgICByZXR1cm4gYWxwaGFfMS5hbHBoYVtsb2NhbGVdLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKGFscGhhXzEuYWxwaGEpO1xuZXhwb3J0cy5sb2NhbGVzID0gbG9jYWxlcztcbn0pO1xuXG52YXIgaXNBbHBoYSA9IHVud3JhcEV4cG9ydHMoaXNBbHBoYV8xKTtcbnZhciBpc0FscGhhXzIgPSBpc0FscGhhXzEubG9jYWxlcztcblxudmFyIGlzQWxwaGFudW1lcmljXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FscGhhbnVtZXJpYztcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuXG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQWxwaGFudW1lcmljKHN0cikge1xuICB2YXIgbG9jYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZW4tVVMnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gYWxwaGFfMS5hbHBoYW51bWVyaWMpIHtcbiAgICByZXR1cm4gYWxwaGFfMS5hbHBoYW51bWVyaWNbbG9jYWxlXS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhhbHBoYV8xLmFscGhhbnVtZXJpYyk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzO1xufSk7XG5cbnZhciBpc0FscGhhbnVtZXJpYyA9IHVud3JhcEV4cG9ydHMoaXNBbHBoYW51bWVyaWNfMSk7XG52YXIgaXNBbHBoYW51bWVyaWNfMiA9IGlzQWxwaGFudW1lcmljXzEubG9jYWxlcztcblxudmFyIGlzQmFzZTY0XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jhc2U2NDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG5vdEJhc2U2NCA9IC9bXkEtWjAtOStcXC89XS9pO1xuXG5mdW5jdGlvbiBpc0Jhc2U2NChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgaWYgKCFsZW4gfHwgbGVuICUgNCAhPT0gMCB8fCBub3RCYXNlNjQudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0UGFkZGluZ0NoYXIgPSBzdHIuaW5kZXhPZignPScpO1xuICByZXR1cm4gZmlyc3RQYWRkaW5nQ2hhciA9PT0gLTEgfHwgZmlyc3RQYWRkaW5nQ2hhciA9PT0gbGVuIC0gMSB8fCBmaXJzdFBhZGRpbmdDaGFyID09PSBsZW4gLSAyICYmIHN0cltsZW4gLSAxXSA9PT0gJz0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzQmFzZTY0ID0gdW53cmFwRXhwb3J0cyhpc0Jhc2U2NF8xKTtcblxudmFyIGlzQ3JlZGl0Q2FyZF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNDcmVkaXRDYXJkO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgY3JlZGl0Q2FyZCA9IC9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fCgyMjJbMS05XXwyMlszLTldWzAtOV18MlszLTZdWzAtOV17Mn18MjdbMDFdWzAtOV18MjcyMClbMC05XXsxMn18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9fDZbMjddWzAtOV17MTR9KSQvO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGlzQ3JlZGl0Q2FyZChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHNhbml0aXplZCA9IHN0ci5yZXBsYWNlKC9bLSBdKy9nLCAnJyk7XG5cbiAgaWYgKCFjcmVkaXRDYXJkLnRlc3Qoc2FuaXRpemVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzdW0gPSAwO1xuICB2YXIgZGlnaXQ7XG4gIHZhciB0bXBOdW07XG4gIHZhciBzaG91bGREb3VibGU7XG5cbiAgZm9yICh2YXIgaSA9IHNhbml0aXplZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGRpZ2l0ID0gc2FuaXRpemVkLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgdG1wTnVtID0gcGFyc2VJbnQoZGlnaXQsIDEwKTtcblxuICAgIGlmIChzaG91bGREb3VibGUpIHtcbiAgICAgIHRtcE51bSAqPSAyO1xuXG4gICAgICBpZiAodG1wTnVtID49IDEwKSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW0gJSAxMCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdW0gKz0gdG1wTnVtO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdW0gKz0gdG1wTnVtO1xuICAgIH1cblxuICAgIHNob3VsZERvdWJsZSA9ICFzaG91bGREb3VibGU7XG4gIH1cblxuICByZXR1cm4gISEoc3VtICUgMTAgPT09IDAgPyBzYW5pdGl6ZWQgOiBmYWxzZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNDcmVkaXRDYXJkID0gdW53cmFwRXhwb3J0cyhpc0NyZWRpdENhcmRfMSk7XG5cbnZhciBtZXJnZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWVyZ2U7XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGRlZmF1bHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudW53cmFwRXhwb3J0cyhtZXJnZV8xKTtcblxudmFyIGlzQnl0ZUxlbmd0aF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCeXRlTGVuZ3RoO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbmZ1bmN0aW9uIGlzQnl0ZUxlbmd0aChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIG1pbjtcbiAgdmFyIG1heDtcblxuICBpZiAoX3R5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcbiAgICBtaW4gPSBvcHRpb25zLm1pbiB8fCAwO1xuICAgIG1heCA9IG9wdGlvbnMubWF4O1xuICB9IGVsc2Uge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpc0J5dGVMZW5ndGgoc3RyLCBtaW4gWywgbWF4XSlcbiAgICBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgdmFyIGxlbiA9IGVuY29kZVVSSShzdHIpLnNwbGl0KC8lLi58Li8pLmxlbmd0aCAtIDE7XG4gIHJldHVybiBsZW4gPj0gbWluICYmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyB8fCBsZW4gPD0gbWF4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXNCeXRlTGVuZ3RoXzEpO1xuXG52YXIgaXNGUUROXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0ZRRE47XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9mcWRuX29wdGlvbnMgPSB7XG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGlzRlFETihzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9mcWRuX29wdGlvbnMpO1xuICAvKiBSZW1vdmUgdGhlIG9wdGlvbmFsIHRyYWlsaW5nIGRvdCBiZWZvcmUgY2hlY2tpbmcgdmFsaWRpdHkgKi9cblxuICBpZiAob3B0aW9ucy5hbGxvd190cmFpbGluZ19kb3QgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJy4nKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnRzW2ldLmxlbmd0aCA+IDYzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVxdWlyZV90bGQpIHtcbiAgICB2YXIgdGxkID0gcGFydHMucG9wKCk7XG5cbiAgICBpZiAoIXBhcnRzLmxlbmd0aCB8fCAhL14oW2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9fHhuW2EtejAtOS1dezIsfSkkL2kudGVzdCh0bGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBkaXNhbGxvdyBzcGFjZXNcblxuXG4gICAgaWYgKC9bXFxzXFx1MjAwMi1cXHUyMDBCXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1RkVGRlxcdURCNDBcXHVEQzIwXS8udGVzdCh0bGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgcGFydCwgX2kgPSAwOyBfaSA8IHBhcnRzLmxlbmd0aDsgX2krKykge1xuICAgIHBhcnQgPSBwYXJ0c1tfaV07XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd191bmRlcnNjb3Jlcykge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKCEvXlthLXpcXHUwMGExLVxcdWZmZmYwLTktXSskL2kudGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gZGlzYWxsb3cgZnVsbC13aWR0aCBjaGFyc1xuXG5cbiAgICBpZiAoL1tcXHVmZjAxLVxcdWZmNWVdLy50ZXN0KHBhcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRbMF0gPT09ICctJyB8fCBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09ICctJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudW53cmFwRXhwb3J0cyhpc0ZRRE5fMSk7XG5cbnZhciBpc0lQXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lQO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaXB2NE1heWJlID0gL14oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSlcXC4oXFxkezEsM30pJC87XG52YXIgaXB2NkJsb2NrID0gL15bMC05QS1GXXsxLDR9JC9pO1xuXG5mdW5jdGlvbiBpc0lQKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG5cbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGlzSVAoc3RyLCA0KSB8fCBpc0lQKHN0ciwgNik7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzQnKSB7XG4gICAgaWYgKCFpcHY0TWF5YmUudGVzdChzdHIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcuJykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0c1szXSA8PSAyNTU7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzYnKSB7XG4gICAgdmFyIGJsb2NrcyA9IHN0ci5zcGxpdCgnOicpO1xuICAgIHZhciBmb3VuZE9taXNzaW9uQmxvY2sgPSBmYWxzZTsgLy8gbWFya2VyIHRvIGluZGljYXRlIDo6XG4gICAgLy8gQXQgbGVhc3Qgc29tZSBPUyBhY2NlcHQgdGhlIGxhc3QgMzIgYml0cyBvZiBhbiBJUHY2IGFkZHJlc3NcbiAgICAvLyAoaS5lLiAyIG9mIHRoZSBibG9ja3MpIGluIElQdjQgbm90YXRpb24sIGFuZCBSRkMgMzQ5MyBzYXlzXG4gICAgLy8gdGhhdCAnOjpmZmZmOmEuYi5jLmQnIGlzIHZhbGlkIGZvciBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3NlcyxcbiAgICAvLyBhbmQgJzo6YS5iLmMuZCcgaXMgZGVwcmVjYXRlZCwgYnV0IGFsc28gdmFsaWQuXG5cbiAgICB2YXIgZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrID0gaXNJUChibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdLCA0KTtcbiAgICB2YXIgZXhwZWN0ZWROdW1iZXJPZkJsb2NrcyA9IGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayA/IDcgOiA4O1xuXG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPiBleHBlY3RlZE51bWJlck9mQmxvY2tzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpbml0aWFsIG9yIGZpbmFsIDo6XG5cblxuICAgIGlmIChzdHIgPT09ICc6OicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xuICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAyKSA9PT0gJzo6Jykge1xuICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gdGVzdCBmb3IgYSA6OiB3aGljaCBjYW4gbm90IGJlIGF0IHRoZSBzdHJpbmcgc3RhcnQvZW5kXG4gICAgICAvLyBzaW5jZSB0aG9zZSBjYXNlcyBoYXZlIGJlZW4gaGFuZGxlZCBhYm92ZVxuICAgICAgaWYgKGJsb2Nrc1tpXSA9PT0gJycgJiYgaSA+IDAgJiYgaSA8IGJsb2Nrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG11bHRpcGxlIDo6IGluIGFkZHJlc3NcbiAgICAgICAgfVxuXG4gICAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayAmJiBpID09PSBibG9ja3MubGVuZ3RoIC0gMSkgOyBlbHNlIGlmICghaXB2NkJsb2NrLnRlc3QoYmxvY2tzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA9PT0gZXhwZWN0ZWROdW1iZXJPZkJsb2NrcztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc0lQID0gdW53cmFwRXhwb3J0cyhpc0lQXzEpO1xuXG52YXIgaXNFbWFpbF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbWFpbDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobWVyZ2VfMSk7XG5cbnZhciBfaXNCeXRlTGVuZ3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0J5dGVMZW5ndGhfMSk7XG5cbnZhciBfaXNGUUROID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0ZRRE5fMSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNJUF8xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfZW1haWxfb3B0aW9ucyA9IHtcbiAgYWxsb3dfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgcmVxdWlyZV9kaXNwbGF5X25hbWU6IGZhbHNlLFxuICBhbGxvd191dGY4X2xvY2FsX3BhcnQ6IHRydWUsXG4gIHJlcXVpcmVfdGxkOiB0cnVlXG59O1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbnZhciBkaXNwbGF5TmFtZSA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwuXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXStbYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXCxcXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHNdKjwoLispPiQvaTtcbnZhciBlbWFpbFVzZXJQYXJ0ID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dKyQvaTtcbnZhciBnbWFpbFVzZXJQYXJ0ID0gL15bYS16XFxkXSskLztcbnZhciBxdW90ZWRFbWFpbFVzZXIgPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZV18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdKSkqJC9pO1xudmFyIGVtYWlsVXNlclV0ZjhQYXJ0ID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKyQvaTtcbnZhciBxdW90ZWRFbWFpbFVzZXJVdGY4ID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKiQvaTtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuZnVuY3Rpb24gaXNFbWFpbChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9lbWFpbF9vcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSB8fCBvcHRpb25zLmFsbG93X2Rpc3BsYXlfbmFtZSkge1xuICAgIHZhciBkaXNwbGF5X2VtYWlsID0gc3RyLm1hdGNoKGRpc3BsYXlOYW1lKTtcblxuICAgIGlmIChkaXNwbGF5X2VtYWlsKSB7XG4gICAgICBzdHIgPSBkaXNwbGF5X2VtYWlsWzFdO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcGFydHMucG9wKCk7XG4gIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xuICB2YXIgbG93ZXJfZG9tYWluID0gZG9tYWluLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG9wdGlvbnMuZG9tYWluX3NwZWNpZmljX3ZhbGlkYXRpb24gJiYgKGxvd2VyX2RvbWFpbiA9PT0gJ2dtYWlsLmNvbScgfHwgbG93ZXJfZG9tYWluID09PSAnZ29vZ2xlbWFpbC5jb20nKSkge1xuICAgIC8qXG4gICAgICBQcmV2aW91c2x5IHdlIHJlbW92ZWQgZG90cyBmb3IgZ21haWwgYWRkcmVzc2VzIGJlZm9yZSB2YWxpZGF0aW5nLlxuICAgICAgVGhpcyB3YXMgcmVtb3ZlZCBiZWNhdXNlIGl0IGFsbG93cyBgbXVsdGlwbGUuLmRvdHNAZ21haWwuY29tYFxuICAgICAgdG8gYmUgcmVwb3J0ZWQgYXMgdmFsaWQsIGJ1dCBpdCBpcyBub3QuXG4gICAgICBHbWFpbCBvbmx5IG5vcm1hbGl6ZXMgc2luZ2xlIGRvdHMsIHJlbW92aW5nIHRoZW0gZnJvbSBoZXJlIGlzIHBvaW50bGVzcyxcbiAgICAgIHNob3VsZCBiZSBkb25lIGluIG5vcm1hbGl6ZUVtYWlsXG4gICAgKi9cbiAgICB1c2VyID0gdXNlci50b0xvd2VyQ2FzZSgpOyAvLyBSZW1vdmluZyBzdWItYWRkcmVzcyBmcm9tIHVzZXJuYW1lIGJlZm9yZSBnbWFpbCB2YWxpZGF0aW9uXG5cbiAgICB2YXIgdXNlcm5hbWUgPSB1c2VyLnNwbGl0KCcrJylbMF07IC8vIERvdHMgYXJlIG5vdCBpbmNsdWRlZCBpbiBnbWFpbCBsZW5ndGggcmVzdHJpY3Rpb25cblxuICAgIGlmICghKDAsIF9pc0J5dGVMZW5ndGguZGVmYXVsdCkodXNlcm5hbWUucmVwbGFjZSgnLicsICcnKSwge1xuICAgICAgbWluOiA2LFxuICAgICAgbWF4OiAzMFxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF91c2VyX3BhcnRzID0gdXNlcm5hbWUuc3BsaXQoJy4nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3VzZXJfcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZ21haWxVc2VyUGFydC50ZXN0KF91c2VyX3BhcnRzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KSh1c2VyLCB7XG4gICAgbWF4OiA2NFxuICB9KSB8fCAhKDAsIF9pc0J5dGVMZW5ndGguZGVmYXVsdCkoZG9tYWluLCB7XG4gICAgbWF4OiAyNTRcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoISgwLCBfaXNGUUROLmRlZmF1bHQpKGRvbWFpbiwge1xuICAgIHJlcXVpcmVfdGxkOiBvcHRpb25zLnJlcXVpcmVfdGxkXG4gIH0pKSB7XG4gICAgaWYgKCFvcHRpb25zLmFsbG93X2lwX2RvbWFpbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKDAsIF9pc0lQLmRlZmF1bHQpKGRvbWFpbikpIHtcbiAgICAgIGlmICghZG9tYWluLnN0YXJ0c1dpdGgoJ1snKSB8fCAhZG9tYWluLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9CcmFja2V0ZG9tYWluID0gZG9tYWluLnN1YnN0cigxLCBkb21haW4ubGVuZ3RoIC0gMik7XG5cbiAgICAgIGlmIChub0JyYWNrZXRkb21haW4ubGVuZ3RoID09PSAwIHx8ICEoMCwgX2lzSVAuZGVmYXVsdCkobm9CcmFja2V0ZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHVzZXJbMF0gPT09ICdcIicpIHtcbiAgICB1c2VyID0gdXNlci5zbGljZSgxLCB1c2VyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IHF1b3RlZEVtYWlsVXNlclV0ZjgudGVzdCh1c2VyKSA6IHF1b3RlZEVtYWlsVXNlci50ZXN0KHVzZXIpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm4gPSBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IGVtYWlsVXNlclV0ZjhQYXJ0IDogZW1haWxVc2VyUGFydDtcbiAgdmFyIHVzZXJfcGFydHMgPSB1c2VyLnNwbGl0KCcuJyk7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHVzZXJfcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tfaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNFbWFpbCA9IHVud3JhcEV4cG9ydHMoaXNFbWFpbF8xKTtcblxudmFyIGlzSVNPODYwMV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJU084NjAxO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vLyBmcm9tIGh0dHA6Ly9nb28uZ2wvMGVqSEhXXG52YXIgaXNvODYwMSA9IC9eKFtcXCstXT9cXGR7NH0oPyFcXGR7Mn1cXGIpKSgoLT8pKCgwWzEtOV18MVswLTJdKShcXDMoWzEyXVxcZHwwWzEtOV18M1swMV0pKT98VyhbMC00XVxcZHw1WzAtM10pKC0/WzEtN10pP3woMDBbMS05XXwwWzEtOV1cXGR8WzEyXVxcZHsyfXwzKFswLTVdXFxkfDZbMS02XSkpKShbVFxcc10oKChbMDFdXFxkfDJbMC0zXSkoKDo/KVswLTVdXFxkKT98MjQ6PzAwKShbXFwuLF1cXGQrKD8hOikpPyk/KFxcMTdbMC01XVxcZChbXFwuLF1cXGQrKT8pPyhbelpdfChbXFwrLV0pKFswMV1cXGR8MlswLTNdKTo/KFswLTVdXFxkKT8pPyk/KT8kLztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNWYWxpZERhdGUgPSBmdW5jdGlvbiBpc1ZhbGlkRGF0ZShzdHIpIHtcbiAgLy8gc3RyIG11c3QgaGF2ZSBwYXNzZWQgdGhlIElTTzg2MDEgY2hlY2tcbiAgLy8gdGhpcyBjaGVjayBpcyBtZWFudCB0byBjYXRjaCBpbnZhbGlkIGRhdGVzXG4gIC8vIGxpa2UgMjAwOS0wMi0zMVxuICAvLyBmaXJzdCBjaGVjayBmb3Igb3JkaW5hbCBkYXRlc1xuICB2YXIgb3JkaW5hbE1hdGNoID0gc3RyLm1hdGNoKC9eKFxcZHs0fSktPyhcXGR7M30pKFsgVF17MX1cXC4qfCQpLyk7XG5cbiAgaWYgKG9yZGluYWxNYXRjaCkge1xuICAgIHZhciBvWWVhciA9IE51bWJlcihvcmRpbmFsTWF0Y2hbMV0pO1xuICAgIHZhciBvRGF5ID0gTnVtYmVyKG9yZGluYWxNYXRjaFsyXSk7IC8vIGlmIGlzIGxlYXAgeWVhclxuXG4gICAgaWYgKG9ZZWFyICUgNCA9PT0gMCAmJiBvWWVhciAlIDEwMCAhPT0gMCkgcmV0dXJuIG9EYXkgPD0gMzY2O1xuICAgIHJldHVybiBvRGF5IDw9IDM2NTtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvKFxcZHs0fSktPyhcXGR7MCwyfSktPyhcXGQqKS8pLm1hcChOdW1iZXIpO1xuICB2YXIgeWVhciA9IG1hdGNoWzFdO1xuICB2YXIgbW9udGggPSBtYXRjaFsyXTtcbiAgdmFyIGRheSA9IG1hdGNoWzNdO1xuICB2YXIgbW9udGhTdHJpbmcgPSBtb250aCA/IFwiMFwiLmNvbmNhdChtb250aCkuc2xpY2UoLTIpIDogbW9udGg7XG4gIHZhciBkYXlTdHJpbmcgPSBkYXkgPyBcIjBcIi5jb25jYXQoZGF5KS5zbGljZSgtMikgOiBkYXk7IC8vIGNyZWF0ZSBhIGRhdGUgb2JqZWN0IGFuZCBjb21wYXJlXG5cbiAgdmFyIGQgPSBuZXcgRGF0ZShcIlwiLmNvbmNhdCh5ZWFyLCBcIi1cIikuY29uY2F0KG1vbnRoU3RyaW5nIHx8ICcwMScsIFwiLVwiKS5jb25jYXQoZGF5U3RyaW5nIHx8ICcwMScpKTtcbiAgaWYgKGlzTmFOKGQuZ2V0VVRDRnVsbFllYXIoKSkpIHJldHVybiBmYWxzZTtcblxuICBpZiAobW9udGggJiYgZGF5KSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSA9PT0geWVhciAmJiBkLmdldFVUQ01vbnRoKCkgKyAxID09PSBtb250aCAmJiBkLmdldFVUQ0RhdGUoKSA9PT0gZGF5O1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpc0lTTzg2MDEoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBjaGVjayA9IGlzbzg2MDEudGVzdChzdHIpO1xuICBpZiAoIW9wdGlvbnMpIHJldHVybiBjaGVjaztcbiAgaWYgKGNoZWNrICYmIG9wdGlvbnMuc3RyaWN0KSByZXR1cm4gaXNWYWxpZERhdGUoc3RyKTtcbiAgcmV0dXJuIGNoZWNrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG59KTtcblxudmFyIGlzSVNPODYwMSA9IHVud3JhcEV4cG9ydHMoaXNJU084NjAxXzEpO1xuXG52YXIgaXNKU09OXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0pTT047XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGlzSlNPTihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICB0cnkge1xuICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gICAgcmV0dXJuICEhb2JqICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBpZ25vcmUgKi9cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc0pTT04gPSB1bndyYXBFeHBvcnRzKGlzSlNPTl8xKTtcblxudmFyIGlzVVJMXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1VSTDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxudmFyIF9pc0ZRRE4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzRlFETl8xKTtcblxudmFyIF9pc0lQID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfdXJsX29wdGlvbnMgPSB7XG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2Z0cCddLFxuICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgcmVxdWlyZV9wcm90b2NvbDogZmFsc2UsXG4gIHJlcXVpcmVfaG9zdDogdHJ1ZSxcbiAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogdHJ1ZSxcbiAgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlLFxuICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlLFxuICBhbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzOiBmYWxzZVxufTtcbnZhciB3cmFwcGVkX2lwdjYgPSAvXlxcWyhbXlxcXV0rKVxcXSg/OjooWzAtOV0rKSk/JC87XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCwgbWF0Y2hlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuXG4gICAgaWYgKGhvc3QgPT09IG1hdGNoIHx8IGlzUmVnRXhwKG1hdGNoKSAmJiBtYXRjaC50ZXN0KGhvc3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVVJMKHVybCwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KSh1cmwpO1xuXG4gIGlmICghdXJsIHx8IHVybC5sZW5ndGggPj0gMjA4MyB8fCAvW1xcczw+XS8udGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHVybC5pbmRleE9mKCdtYWlsdG86JykgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X3VybF9vcHRpb25zKTtcbiAgdmFyIHByb3RvY29sLCBhdXRoLCBob3N0LCBob3N0bmFtZSwgcG9ydCwgcG9ydF9zdHIsIHNwbGl0LCBpcHY2O1xuICBzcGxpdCA9IHVybC5zcGxpdCgnIycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuICBzcGxpdCA9IHVybC5zcGxpdCgnPycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuICBzcGxpdCA9IHVybC5zcGxpdCgnOi8vJyk7XG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICBwcm90b2NvbCA9IHNwbGl0LnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVfdmFsaWRfcHJvdG9jb2wgJiYgb3B0aW9ucy5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9wcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICh1cmwuc3Vic3RyKDAsIDIpID09PSAnLy8nKSB7XG4gICAgaWYgKCFvcHRpb25zLmFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcGxpdFswXSA9IHVybC5zdWJzdHIoMik7XG4gIH1cblxuICB1cmwgPSBzcGxpdC5qb2luKCc6Ly8nKTtcblxuICBpZiAodXJsID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcvJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgaWYgKHVybCA9PT0gJycgJiYgIW9wdGlvbnMucmVxdWlyZV9ob3N0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzcGxpdCA9IHVybC5zcGxpdCgnQCcpO1xuXG4gIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWxsb3dfYXV0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGF1dGggPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgaWYgKGF1dGguaW5kZXhPZignOicpID49IDAgJiYgYXV0aC5zcGxpdCgnOicpLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBob3N0bmFtZSA9IHNwbGl0LmpvaW4oJ0AnKTtcbiAgcG9ydF9zdHIgPSBudWxsO1xuICBpcHY2ID0gbnVsbDtcbiAgdmFyIGlwdjZfbWF0Y2ggPSBob3N0bmFtZS5tYXRjaCh3cmFwcGVkX2lwdjYpO1xuXG4gIGlmIChpcHY2X21hdGNoKSB7XG4gICAgaG9zdCA9ICcnO1xuICAgIGlwdjYgPSBpcHY2X21hdGNoWzFdO1xuICAgIHBvcnRfc3RyID0gaXB2Nl9tYXRjaFsyXSB8fCBudWxsO1xuICB9IGVsc2Uge1xuICAgIHNwbGl0ID0gaG9zdG5hbWUuc3BsaXQoJzonKTtcbiAgICBob3N0ID0gc3BsaXQuc2hpZnQoKTtcblxuICAgIGlmIChzcGxpdC5sZW5ndGgpIHtcbiAgICAgIHBvcnRfc3RyID0gc3BsaXQuam9pbignOicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb3J0X3N0ciAhPT0gbnVsbCkge1xuICAgIHBvcnQgPSBwYXJzZUludChwb3J0X3N0ciwgMTApO1xuXG4gICAgaWYgKCEvXlswLTldKyQvLnRlc3QocG9ydF9zdHIpIHx8IHBvcnQgPD0gMCB8fCBwb3J0ID4gNjU1MzUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoISgwLCBfaXNJUC5kZWZhdWx0KShob3N0KSAmJiAhKDAsIF9pc0ZRRE4uZGVmYXVsdCkoaG9zdCwgb3B0aW9ucykgJiYgKCFpcHY2IHx8ICEoMCwgX2lzSVAuZGVmYXVsdCkoaXB2NiwgNikpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaG9zdCA9IGhvc3QgfHwgaXB2NjtcblxuICBpZiAob3B0aW9ucy5ob3N0X3doaXRlbGlzdCAmJiAhY2hlY2tIb3N0KGhvc3QsIG9wdGlvbnMuaG9zdF93aGl0ZWxpc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaG9zdF9ibGFja2xpc3QgJiYgY2hlY2tIb3N0KGhvc3QsIG9wdGlvbnMuaG9zdF9ibGFja2xpc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbn0pO1xuXG52YXIgaXNVUkwgPSB1bndyYXBFeHBvcnRzKGlzVVJMXzEpO1xuXG52YXIgaXNVVUlEXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1VVSUQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB1dWlkID0ge1xuICAzOiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTNbMC05QS1GXXszfS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2ksXG4gIDQ6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tNFswLTlBLUZdezN9LVs4OUFCXVswLTlBLUZdezN9LVswLTlBLUZdezEyfSQvaSxcbiAgNTogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS01WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pLFxuICBhbGw6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pXG59O1xuXG5mdW5jdGlvbiBpc1VVSUQoc3RyKSB7XG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnYWxsJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHBhdHRlcm4gPSB1dWlkW3ZlcnNpb25dO1xuICByZXR1cm4gcGF0dGVybiAmJiBwYXR0ZXJuLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xufSk7XG5cbnZhciBpc1VVSUQgPSB1bndyYXBFeHBvcnRzKGlzVVVJRF8xKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG52YXIgX2ZyZWVHbG9iYWwgPSBmcmVlR2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBfZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgX3Jvb3QgPSByb290O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IF9yb290LlN5bWJvbDtcblxudmFyIF9TeW1ib2wgPSBTeW1ib2wkMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZ2V0UmF3VGFnID0gZ2V0UmF3VGFnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xufVxuXG52YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyQxID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWckMSAmJiBzeW1Ub1N0cmluZ1RhZyQxIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBfZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogX29iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbnZhciBpc09iamVjdF8xID0gaXNPYmplY3Q7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdF8xKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBfYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbnZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IF9yb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxudmFyIF9jb3JlSnNEYXRhID0gY29yZUpzRGF0YTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhfY29yZUpzRGF0YSAmJiBfY29yZUpzRGF0YS5rZXlzICYmIF9jb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxudmFyIF9pc01hc2tlZCA9IGlzTWFza2VkO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciBfdG9Tb3VyY2UgPSB0b1NvdXJjZTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8kMSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byQyID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyQxID0gZnVuY1Byb3RvJDEudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nJDEuY2FsbChoYXNPd25Qcm9wZXJ0eSQxKS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdF8xKHZhbHVlKSB8fCBfaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbl8xKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QoX3RvU291cmNlKHZhbHVlKSk7XG59XG5cbnZhciBfYmFzZUlzTmF0aXZlID0gYmFzZUlzTmF0aXZlO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxudmFyIF9nZXRWYWx1ZSA9IGdldFZhbHVlO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gX2dldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIF9iYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBfZ2V0TmF0aXZlID0gZ2V0TmF0aXZlO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBfZGVmaW5lUHJvcGVydHkpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG52YXIgX2Jhc2VBc3NpZ25WYWx1ZSA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbnZhciBlcV8xID0gZXE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQzID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMiA9IG9iamVjdFByb3RvJDMuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5JDIuY2FsbChvYmplY3QsIGtleSkgJiYgZXFfMShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBfYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIF9hc3NpZ25WYWx1ZSA9IGFzc2lnblZhbHVlO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBfYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgX2NvcHlPYmplY3QgPSBjb3B5T2JqZWN0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaWRlbnRpdHlfMSA9IGlkZW50aXR5O1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbnZhciBfYXBwbHkgPSBhcHBseTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gX2FwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbnZhciBfb3ZlclJlc3QgPSBvdmVyUmVzdDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbnZhciBjb25zdGFudF8xID0gY29uc3RhbnQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFfZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eV8xIDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnRfMShzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG52YXIgX2Jhc2VTZXRUb1N0cmluZyA9IGJhc2VTZXRUb1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3Nob3J0T3V0ID0gc2hvcnRPdXQ7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IF9zaG9ydE91dChfYmFzZVNldFRvU3RyaW5nKTtcblxudmFyIF9zZXRUb1N0cmluZyA9IHNldFRvU3RyaW5nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gX3NldFRvU3RyaW5nKF9vdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHlfMSksIGZ1bmMgKyAnJyk7XG59XG5cbnZhciBfYmFzZVJlc3QgPSBiYXNlUmVzdDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG52YXIgaXNMZW5ndGhfMSA9IGlzTGVuZ3RoO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aF8xKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb25fMSh2YWx1ZSk7XG59XG5cbnZhciBpc0FycmF5TGlrZV8xID0gaXNBcnJheUxpa2U7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbnZhciBfaXNJbmRleCA9IGlzSW5kZXg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZV8xKG9iamVjdCkgJiYgX2lzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcV8xKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfaXNJdGVyYXRlZUNhbGwgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gX2Jhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIF9pc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG52YXIgX2NyZWF0ZUFzc2lnbmVyID0gY3JlYXRlQXNzaWduZXI7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byQ0O1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbnZhciBfaXNQcm90b3R5cGUgPSBpc1Byb3RvdHlwZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlVGltZXMgPSBiYXNlVGltZXM7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG52YXIgaXNPYmplY3RMaWtlXzEgPSBpc09iamVjdExpa2U7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbnZhciBfYmFzZUlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQ1Lmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvJDUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IF9iYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBfYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eSQzLmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG52YXIgaXNBcmd1bWVudHNfMSA9IGlzQXJndW1lbnRzO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHN0dWJGYWxzZV8xID0gc3R1YkZhbHNlO1xuXG52YXIgaXNCdWZmZXJfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gX3Jvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZV8xO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xufSk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoXzEodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW19iYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbnZhciBfYmFzZUlzVHlwZWRBcnJheSA9IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlVW5hcnkgPSBiYXNlVW5hcnk7XG5cbnZhciBfbm9kZVV0aWwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiAnb2JqZWN0JyA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIF9mcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xufSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IF9ub2RlVXRpbCAmJiBfbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IF9iYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBfYmFzZUlzVHlwZWRBcnJheTtcblxudmFyIGlzVHlwZWRBcnJheV8xID0gaXNUeXBlZEFycmF5O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ2Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheV8xKHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzXzEodmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcl8xKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXlfMSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IF9iYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5JDQuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBfaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG52YXIgX292ZXJBcmcgPSBvdmVyQXJnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IF9vdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG52YXIgX25hdGl2ZUtleXMgPSBuYXRpdmVLZXlzO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDUgPSBvYmplY3RQcm90byQ3Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghX2lzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gX25hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ1LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzID0gYmFzZUtleXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlXzEob2JqZWN0KSA/IF9hcnJheUxpa2VLZXlzKG9iamVjdCkgOiBfYmFzZUtleXMob2JqZWN0KTtcbn1cblxudmFyIGtleXNfMSA9IGtleXM7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ4ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNiA9IG9iamVjdFByb3RvJDguaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbkluXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBCYXIoKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIGFzc2lnbiA9IF9jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICBpZiAoX2lzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2VfMShzb3VyY2UpKSB7XG4gICAgX2NvcHlPYmplY3Qoc291cmNlLCBrZXlzXzEoc291cmNlKSwgb2JqZWN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ2LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICBfYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgYXNzaWduXzEgPSBhc3NpZ247XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9hcnJheVB1c2ggPSBhcnJheVB1c2g7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBfU3ltYm9sID8gX1N5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheV8xKHZhbHVlKSB8fCBpc0FyZ3VtZW50c18xKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG52YXIgX2lzRmxhdHRlbmFibGUgPSBpc0ZsYXR0ZW5hYmxlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gX2lzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VGbGF0dGVuID0gYmFzZUZsYXR0ZW47XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX2NvcHlBcnJheSA9IGNvcHlBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICogYW5kL29yIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5ID0gWzFdO1xuICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXkpO1xuICogLy8gPT4gWzFdXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gX2FycmF5UHVzaChpc0FycmF5XzEoYXJyYXkpID8gX2NvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBfYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xufVxuXG52YXIgY29uY2F0XzEgPSBjb25jYXQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxudmFyIF9iYXNlUHJvcGVydHlPZiA9IGJhc2VQcm9wZXJ0eU9mO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBfYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxudmFyIF9kZWJ1cnJMZXR0ZXIgPSBkZWJ1cnJMZXR0ZXI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlNYXAgPSBhcnJheU1hcDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG52YXIgaXNTeW1ib2xfMSA9IGlzU3ltYm9sO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IF9TeW1ib2wgPyBfU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBfYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxudmFyIF9iYXNlVG9TdHJpbmcgPSBiYXNlVG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogX2Jhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciB0b1N0cmluZ18xID0gdG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZ18xKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgX2RlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG52YXIgZGVidXJyXzEgPSBkZWJ1cnI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9hcnJheUVhY2ggPSBhcnJheUVhY2g7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG52YXIgX2NyZWF0ZUJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBfY3JlYXRlQmFzZUZvcigpO1xuXG52YXIgX2Jhc2VGb3IgPSBiYXNlRm9yO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIF9iYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNfMSk7XG59XG5cbnZhciBfYmFzZUZvck93biA9IGJhc2VGb3JPd247XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZV8xKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxudmFyIF9jcmVhdGVCYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBfY3JlYXRlQmFzZUVhY2goX2Jhc2VGb3JPd24pO1xuXG52YXIgX2Jhc2VFYWNoID0gYmFzZUVhY2g7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHlfMTtcbn1cblxudmFyIF9jYXN0RnVuY3Rpb24gPSBjYXN0RnVuY3Rpb247XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5XzEoY29sbGVjdGlvbikgPyBfYXJyYXlFYWNoIDogX2Jhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBfY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbnZhciBmb3JFYWNoXzEgPSBmb3JFYWNoO1xuXG52YXIgZWFjaCA9IGZvckVhY2hfMTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxudmFyIF9pc0tleSA9IGlzS2V5O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gX2dldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxudmFyIF9uYXRpdmVDcmVhdGUgPSBuYXRpdmVDcmVhdGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IF9uYXRpdmVDcmVhdGUgPyBfbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfaGFzaENsZWFyID0gaGFzaENsZWFyO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2hhc2hEZWxldGUgPSBoYXNoRGVsZXRlO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ5ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNyA9IG9iamVjdFByb3RvJDkuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChfbmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkkNy5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbnZhciBfaGFzaEdldCA9IGhhc2hHZXQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRhID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkOCA9IG9iamVjdFByb3RvJGEuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gX25hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQ4LmNhbGwoZGF0YSwga2V5KTtcbn1cblxudmFyIF9oYXNoSGFzID0gaGFzaEhhcztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChfbmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQkMSA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9oYXNoU2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IF9oYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IF9oYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gX2hhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBfaGFzaFNldDtcblxudmFyIF9IYXNoID0gSGFzaDtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2xpc3RDYWNoZUNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcV8xKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIF9hc3NvY0luZGV4T2YgPSBhc3NvY0luZGV4T2Y7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBfbGlzdENhY2hlRGVsZXRlID0gbGlzdENhY2hlRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxudmFyIF9saXN0Q2FjaGVHZXQgPSBsaXN0Q2FjaGVHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxudmFyIF9saXN0Q2FjaGVIYXMgPSBsaXN0Q2FjaGVIYXM7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbGlzdENhY2hlU2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9saXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2xpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX2xpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gX2xpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gX2xpc3RDYWNoZVNldDtcblxudmFyIF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBfZ2V0TmF0aXZlKF9yb290LCAnTWFwJyk7XG5cbnZhciBfTWFwID0gTWFwO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IF9IYXNoLFxuICAgICdtYXAnOiBuZXcgKF9NYXAgfHwgX0xpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBfSGFzaFxuICB9O1xufVxuXG52YXIgX21hcENhY2hlQ2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbnZhciBfaXNLZXlhYmxlID0gaXNLZXlhYmxlO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gX2lzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG52YXIgX2dldE1hcERhdGEgPSBnZXRNYXBEYXRhO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gX2dldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxudmFyIF9tYXBDYWNoZUdldCA9IG1hcENhY2hlR2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gX2dldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxudmFyIF9tYXBDYWNoZUhhcyA9IG1hcENhY2hlSGFzO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX21hcENhY2hlU2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBfbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX21hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IF9tYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbWFwQ2FjaGVTZXQ7XG5cbnZhciBfTWFwQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgX01hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBfTWFwQ2FjaGU7XG5cbnZhciBtZW1vaXplXzEgPSBtZW1vaXplO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplXzEoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tZW1vaXplQ2FwcGVkID0gbWVtb2l6ZUNhcHBlZDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBfbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIF9zdHJpbmdUb1BhdGggPSBzdHJpbmdUb1BhdGg7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBfaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogX3N0cmluZ1RvUGF0aCh0b1N0cmluZ18xKHZhbHVlKSk7XG59XG5cbnZhciBfY2FzdFBhdGggPSBjYXN0UGF0aDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkkMSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQxKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfdG9LZXkgPSB0b0tleTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W190b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2Jhc2VHZXQgPSBiYXNlR2V0O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogX2Jhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG52YXIgZ2V0XzEgPSBnZXQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG59XG5cbnZhciBfYmFzZUd0ID0gYmFzZUd0O1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdF8xKHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0XzEob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbnZhciB0b051bWJlcl8xID0gdG9OdW1iZXI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyXzEodmFsdWUpO1xuICAgICAgb3RoZXIgPSB0b051bWJlcl8xKG90aGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb247XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjkuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQHNlZSBfLmx0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZ3QoMywgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5ndCgzLCAzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5ndCgxLCAzKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBndCA9IF9jcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKF9iYXNlR3QpO1xuXG52YXIgZ3RfMSA9IGd0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy45LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAqIEBzZWUgXy5sdGVcbiAqIEBleGFtcGxlXG4gKlxuICogXy5ndGUoMywgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5ndGUoMywgMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5ndGUoMSwgMyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgZ3RlID0gX2NyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbn0pO1xuXG52YXIgZ3RlXzEgPSBndGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Jhc2VGaW5kSW5kZXggPSBiYXNlRmluZEluZGV4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG52YXIgX2Jhc2VJc05hTiA9IGJhc2VJc05hTjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX3N0cmljdEluZGV4T2YgPSBzdHJpY3RJbmRleE9mO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBfc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IF9iYXNlRmluZEluZGV4KGFycmF5LCBfYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG52YXIgX2Jhc2VJbmRleE9mID0gYmFzZUluZGV4T2Y7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWckMSA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5XzEodmFsdWUpICYmIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnJDEpO1xufVxuXG52YXIgaXNTdHJpbmdfMSA9IGlzU3RyaW5nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSQyID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcl8xKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSQyIHx8IHZhbHVlID09PSAtSU5GSU5JVFkkMikge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG52YXIgdG9GaW5pdGVfMSA9IHRvRmluaXRlO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlXzEodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbnZhciB0b0ludGVnZXJfMSA9IHRvSW50ZWdlcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gX2FycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG52YXIgX2Jhc2VWYWx1ZXMgPSBiYXNlVmFsdWVzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBfYmFzZVZhbHVlcyhvYmplY3QsIGtleXNfMShvYmplY3QpKTtcbn1cblxudmFyIHZhbHVlc18xID0gdmFsdWVzO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4JDEgPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZV8xKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlc18xKGNvbGxlY3Rpb24pO1xuICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXJfMShmcm9tSW5kZXgpIDogMDtcblxuICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4JDEobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gaXNTdHJpbmdfMShjb2xsZWN0aW9uKVxuICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgOiAoISFsZW5ndGggJiYgX2Jhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xufVxuXG52YXIgaW5jbHVkZXNfMSA9IGluY2x1ZGVzO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyQxID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQm9vbGVhbihudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyQxKTtcbn1cblxudmFyIGlzQm9vbGVhbl8xID0gaXNCb29sZWFuO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBfZ2V0TmF0aXZlKF9yb290LCAnRGF0YVZpZXcnKTtcblxudmFyIF9EYXRhVmlldyA9IERhdGFWaWV3O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IF9nZXROYXRpdmUoX3Jvb3QsICdQcm9taXNlJyk7XG5cbnZhciBfUHJvbWlzZSA9IFByb21pc2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBfZ2V0TmF0aXZlKF9yb290LCAnU2V0Jyk7XG5cbnZhciBfU2V0ID0gU2V0O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IF9nZXROYXRpdmUoX3Jvb3QsICdXZWFrTWFwJyk7XG5cbnZhciBfV2Vha01hcCA9IFdlYWtNYXA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWckMSA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyQxID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWckMSA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWckMSA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnJDEgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IF90b1NvdXJjZShfRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX01hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX1Byb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX1NldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX1dlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gX2Jhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoX0RhdGFWaWV3ICYmIGdldFRhZyhuZXcgX0RhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnJDEpIHx8XG4gICAgKF9NYXAgJiYgZ2V0VGFnKG5ldyBfTWFwKSAhPSBtYXBUYWckMSkgfHxcbiAgICAoX1Byb21pc2UgJiYgZ2V0VGFnKF9Qcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoX1NldCAmJiBnZXRUYWcobmV3IF9TZXQpICE9IHNldFRhZyQxKSB8fFxuICAgIChfV2Vha01hcCAmJiBnZXRUYWcobmV3IF9XZWFrTWFwKSAhPSB3ZWFrTWFwVGFnJDEpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IF9iYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWckMSA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IF90b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnJDE7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZyQxO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnJDE7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnJDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbnZhciBfZ2V0VGFnID0gZ2V0VGFnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnJDIgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWckMiA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kYiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDkgPSBvYmplY3RQcm90byRiLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2VfMSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5XzEodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXJfMSh2YWx1ZSkgfHwgaXNUeXBlZEFycmF5XzEodmFsdWUpIHx8IGlzQXJndW1lbnRzXzEodmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBfZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWckMiB8fCB0YWcgPT0gc2V0VGFnJDIpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKF9pc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIV9iYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBpc0VtcHR5XzEgPSBpc0VtcHR5O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgX0xpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9zdGFja0NsZWFyID0gc3RhY2tDbGVhcjtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX3N0YWNrRGVsZXRlID0gc3RhY2tEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxudmFyIF9zdGFja0dldCA9IHN0YWNrR2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG52YXIgX3N0YWNrSGFzID0gc3RhY2tIYXM7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9MaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghX01hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBfTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX3N0YWNrU2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IF9MaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IF9zdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IF9zdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBfc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gX3N0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IF9zdGFja1NldDtcblxudmFyIF9TdGFjayA9IFN0YWNrO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMiA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCQyKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfc2V0Q2FjaGVBZGQgPSBzZXRDYWNoZUFkZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG52YXIgX3NldENhY2hlSGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IF9NYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gX3NldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IF9zZXRDYWNoZUhhcztcblxudmFyIF9TZXRDYWNoZSA9IFNldENhY2hlO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2FycmF5U29tZSA9IGFycmF5U29tZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbnZhciBfY2FjaGVIYXMgPSBjYWNoZUhhcztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IF9TZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIV9hcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFfY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbEFycmF5cyA9IGVxdWFsQXJyYXlzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gX3Jvb3QuVWludDhBcnJheTtcblxudmFyIF9VaW50OEFycmF5ID0gVWludDhBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tYXBUb0FycmF5ID0gbWFwVG9BcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9zZXRUb0FycmF5ID0gc2V0VG9BcnJheTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMSA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQxID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWckMiA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnJDEgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWckMSA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnJDMgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWckMSA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyQxID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnJDMgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWckMiA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyQxID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyQxID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyQyID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8kMSA9IF9TeW1ib2wgPyBfU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8kMSA/IHN5bWJvbFByb3RvJDEudmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnJDI6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWckMTpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBfVWludDhBcnJheShvYmplY3QpLCBuZXcgX1VpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZyQyOlxuICAgIGNhc2UgZGF0ZVRhZyQxOlxuICAgIGNhc2UgbnVtYmVyVGFnJDE6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcV8xKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnJDE6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWckMTpcbiAgICBjYXNlIHN0cmluZ1RhZyQyOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnJDM6XG4gICAgICB2YXIgY29udmVydCA9IF9tYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWckMzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMTtcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBfc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDE7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IF9lcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnJDE6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfZXF1YWxCeVRhZyA9IGVxdWFsQnlUYWc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5XzEob2JqZWN0KSA/IHJlc3VsdCA6IF9hcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxudmFyIF9iYXNlR2V0QWxsS2V5cyA9IGJhc2VHZXRBbGxLZXlzO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlGaWx0ZXIgPSBhcnJheUZpbHRlcjtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxudmFyIHN0dWJBcnJheV8xID0gc3R1YkFycmF5O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kYyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBvYmplY3RQcm90byRjLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5XzEgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gX2FycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxudmFyIF9nZXRTeW1ib2xzID0gZ2V0U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gX2Jhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c18xLCBfZ2V0U3ltYm9scyk7XG59XG5cbnZhciBfZ2V0QWxsS2V5cyA9IGdldEFsbEtleXM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDIgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kZCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JGEgPSBvYmplY3RQcm90byRkLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDIsXG4gICAgICBvYmpQcm9wcyA9IF9nZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IF9nZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5JGEuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZXF1YWxPYmplY3RzID0gZXF1YWxPYmplY3RzO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQzID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMiA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnJDEgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyQyID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYiA9IG9iamVjdFByb3RvJGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheV8xKG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXlfMShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnJDEgOiBfZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnJDEgOiBfZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyQyID8gb2JqZWN0VGFnJDIgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnJDIgPyBvYmplY3RUYWckMiA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnJDIsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWckMixcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcl8xKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyXzEob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IF9TdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXlfMShvYmplY3QpKVxuICAgICAgPyBfZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogX2VxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkkYi5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5JGIuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IF9TdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBfU3RhY2spO1xuICByZXR1cm4gX2VxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbERlZXAgPSBiYXNlSXNFcXVhbERlZXA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZV8xKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gX2Jhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbnZhciBfYmFzZUlzRXF1YWwgPSBiYXNlSXNFcXVhbDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIF9iYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG52YXIgaXNFcXVhbF8xID0gaXNFcXVhbDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzRmluaXRlID0gX3Jvb3QuaXNGaW5pdGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Zpbml0ZSgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRmluaXRlKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbn1cblxudmFyIF9pc0Zpbml0ZSA9IGlzRmluaXRlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNJbnRlZ2VyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXJfMSh2YWx1ZSk7XG59XG5cbnZhciBpc0ludGVnZXJfMSA9IGlzSW50ZWdlcjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyQyID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyQyKTtcbn1cblxudmFyIGlzTnVtYmVyXzEgPSBpc051bWJlcjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmFOKE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hTih1bmRlZmluZWQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYU4kMSh2YWx1ZSkge1xuICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICByZXR1cm4gaXNOdW1iZXJfMSh2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xufVxuXG52YXIgX2lzTmFOID0gaXNOYU4kMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmlsKG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOaWwodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmlsKE5hTik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxudmFyIGlzTmlsXzEgPSBpc05pbDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOdWxsKG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufVxuXG52YXIgaXNOdWxsXzEgPSBpc051bGw7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxudmFyIGlzVW5kZWZpbmVkXzEgPSBpc1VuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbn1cblxudmFyIF9iYXNlTHQgPSBiYXNlTHQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjkuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQHNlZSBfLmd0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubHQoMSwgMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5sdCgzLCAzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5sdCgzLCAxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBsdCA9IF9jcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKF9iYXNlTHQpO1xuXG52YXIgbHRfMSA9IGx0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy45LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAqIEBzZWUgXy5ndGVcbiAqIEBleGFtcGxlXG4gKlxuICogXy5sdGUoMSwgMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5sdGUoMywgMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5sdGUoMywgMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgbHRlID0gX2NyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbn0pO1xuXG52YXIgbHRlXzEgPSBsdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gX3RvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdF8xKG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChfaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9hc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBfYmFzZVNldCA9IGJhc2VTZXQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IF9iYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgX2Jhc2VTZXQocmVzdWx0LCBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VQaWNrQnkgPSBiYXNlUGlja0J5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxudmFyIF9iYXNlSGFzSW4gPSBiYXNlSGFzSW47XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gX3RvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGhfMShsZW5ndGgpICYmIF9pc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5XzEob2JqZWN0KSB8fCBpc0FyZ3VtZW50c18xKG9iamVjdCkpO1xufVxuXG52YXIgX2hhc1BhdGggPSBoYXNQYXRoO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgX2hhc1BhdGgob2JqZWN0LCBwYXRoLCBfYmFzZUhhc0luKTtcbn1cblxudmFyIGhhc0luXzEgPSBoYXNJbjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBfYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbl8xKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG52YXIgX2Jhc2VQaWNrID0gYmFzZVBpY2s7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IF9iYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxudmFyIGZsYXR0ZW5fMSA9IGZsYXR0ZW47XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gX3NldFRvU3RyaW5nKF9vdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW5fMSksIGZ1bmMgKyAnJyk7XG59XG5cbnZhciBfZmxhdFJlc3QgPSBmbGF0UmVzdDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IF9mbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogX2Jhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xufSk7XG5cbnZhciBwaWNrXzEgPSBwaWNrO1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICogYHBhdGhgIGNyZWF0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAqIC8vID0+IDRcbiAqXG4gKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gKiAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IF9iYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG52YXIgc2V0XzEgPSBzZXQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbnZhciBfYmFzZVByb3BlcnR5ID0gYmFzZVByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbnZhciBhc2NpaVNpemUgPSBfYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxudmFyIF9hc2NpaVNpemUgPSBhc2NpaVNpemU7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlJDEgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSQxID0gcnNDb21ib01hcmtzUmFuZ2UkMSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxICsgcnNDb21ib1N5bWJvbHNSYW5nZSQxLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlJDEgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIF9oYXNVbmljb2RlID0gaGFzVW5pY29kZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UkMSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSQyID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQyID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMiA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UkMiA9IHJzQ29tYm9NYXJrc1JhbmdlJDIgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMiArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMixcbiAgICByc1ZhclJhbmdlJDEgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSQxICsgJ10nLFxuICAgIHJzQ29tYm8kMSA9ICdbJyArIHJzQ29tYm9SYW5nZSQyICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8kMSArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlJDEgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0okMSA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlJDEgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0okMSArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8kMSArICc/JywgcnNDb21ibyQxLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICsrcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfdW5pY29kZVNpemUgPSB1bmljb2RlU2l6ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIF9oYXNVbmljb2RlKHN0cmluZylcbiAgICA/IF91bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBfYXNjaWlTaXplKHN0cmluZyk7XG59XG5cbnZhciBfc3RyaW5nU2l6ZSA9IHN0cmluZ1NpemU7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWckNCA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyQ0ID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaXplKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5zaXplKCdwZWJibGVzJyk7XG4gKiAvLyA9PiA3XG4gKi9cbmZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlXzEoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMShjb2xsZWN0aW9uKSA/IF9zdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IF9nZXRUYWcoY29sbGVjdGlvbik7XG4gIGlmICh0YWcgPT0gbWFwVGFnJDQgfHwgdGFnID09IHNldFRhZyQ0KSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gX2Jhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbn1cblxudmFyIHNpemVfMSA9IHNpemU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlU2xpY2UgPSBiYXNlU2xpY2U7XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IF9iYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG52YXIgX2Nhc3RTbGljZSA9IGNhc3RTbGljZTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHJlZ2V4cFRhZyQyID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWckMjtcbn1cblxudmFyIF9iYXNlSXNSZWdFeHAgPSBiYXNlSXNSZWdFeHA7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzUmVnRXhwID0gX25vZGVVdGlsICYmIF9ub2RlVXRpbC5pc1JlZ0V4cDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBfYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBfYmFzZUlzUmVnRXhwO1xuXG52YXIgaXNSZWdFeHBfMSA9IGlzUmVnRXhwO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG52YXIgX2FzY2lpVG9BcnJheSA9IGFzY2lpVG9BcnJheTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UkMiA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSQzID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQzID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMyA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UkMyA9IHJzQ29tYm9NYXJrc1JhbmdlJDMgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMyxcbiAgICByc1ZhclJhbmdlJDIgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsJDEgPSAnWycgKyByc0FzdHJhbFJhbmdlJDIgKyAnXScsXG4gICAgcnNDb21ibyQyID0gJ1snICsgcnNDb21ib1JhbmdlJDMgKyAnXScsXG4gICAgcnNGaXR6JDEgPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyJDEgPSAnKD86JyArIHJzQ29tYm8kMiArICd8JyArIHJzRml0eiQxICsgJyknLFxuICAgIHJzTm9uQXN0cmFsJDEgPSAnW14nICsgcnNBc3RyYWxSYW5nZSQyICsgJ10nLFxuICAgIHJzUmVnaW9uYWwkMSA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyJDEgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiQyID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kJDEgPSByc01vZGlmaWVyJDEgKyAnPycsXG4gICAgcnNPcHRWYXIkMSA9ICdbJyArIHJzVmFyUmFuZ2UkMiArICddPycsXG4gICAgcnNPcHRKb2luJDEgPSAnKD86JyArIHJzWldKJDIgKyAnKD86JyArIFtyc05vbkFzdHJhbCQxLCByc1JlZ2lvbmFsJDEsIHJzU3VyclBhaXIkMV0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIkMSArIHJlT3B0TW9kJDEgKyAnKSonLFxuICAgIHJzU2VxJDEgPSByc09wdFZhciQxICsgcmVPcHRNb2QkMSArIHJzT3B0Sm9pbiQxLFxuICAgIHJzU3ltYm9sJDEgPSAnKD86JyArIFtyc05vbkFzdHJhbCQxICsgcnNDb21ibyQyICsgJz8nLCByc0NvbWJvJDIsIHJzUmVnaW9uYWwkMSwgcnNTdXJyUGFpciQxLCByc0FzdHJhbCQxXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlJDEgPSBSZWdFeHAocnNGaXR6JDEgKyAnKD89JyArIHJzRml0eiQxICsgJyl8JyArIHJzU3ltYm9sJDEgKyByc1NlcSQxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlJDEpIHx8IFtdO1xufVxuXG52YXIgX3VuaWNvZGVUb0FycmF5ID0gdW5pY29kZVRvQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBfaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyBfdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogX2FzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG52YXIgX3N0cmluZ1RvQXJyYXkgPSBzdHJpbmdUb0FycmF5O1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xudmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1O1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKi9cbmZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIF9pc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICBpZiAoIWxpbWl0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nXzEoc3RyaW5nKTtcbiAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cF8xKHNlcGFyYXRvcikpXG4gICAgICApKSB7XG4gICAgc2VwYXJhdG9yID0gX2Jhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgIGlmICghc2VwYXJhdG9yICYmIF9oYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBfY2FzdFNsaWNlKF9zdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbn1cblxudmFyIHNwbGl0XzEgPSBzcGxpdDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICovXG5mdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBzdHViVHJ1ZV8xID0gc3R1YlRydWU7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX25hdGl2ZUtleXNJbiA9IG5hdGl2ZUtleXNJbjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGYgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRjID0gb2JqZWN0UHJvdG8kZi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdF8xKG9iamVjdCkpIHtcbiAgICByZXR1cm4gX25hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gX2lzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5JGMuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlS2V5c0luID0gYmFzZUtleXNJbjtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlXzEob2JqZWN0KSA/IF9hcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBfYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG52YXIga2V5c0luXzEgPSBrZXlzSW47XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gX2NyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBfY29weU9iamVjdChzb3VyY2UsIGtleXNJbl8xKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxudmFyIGFzc2lnbkluV2l0aF8xID0gYXNzaWduSW5XaXRoO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBfb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbnZhciBfZ2V0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnJDMgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byQyID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvJGcgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nJDIgPSBmdW5jUHJvdG8kMi50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkZCA9IG9iamVjdFByb3RvJGcuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nJDIuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlXzEodmFsdWUpIHx8IF9iYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWckMykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBfZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eSRkLmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZyQyLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxudmFyIGlzUGxhaW5PYmplY3RfMSA9IGlzUGxhaW5PYmplY3Q7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICBlcnJvclRhZyQyID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZV8xKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnJDIgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdF8xKHZhbHVlKSk7XG59XG5cbnZhciBpc0Vycm9yXzEgPSBpc0Vycm9yO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gX2Jhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gX2FwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gaXNFcnJvcl8xKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbnZhciBhdHRlbXB0XzEgPSBhdHRlbXB0O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kaCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JGUgPSBvYmplY3RQcm90byRoLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxXzEob2JqVmFsdWUsIG9iamVjdFByb3RvJGhba2V5XSkgJiYgIWhhc093blByb3BlcnR5JGUuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxudmFyIF9jdXN0b21EZWZhdWx0c0Fzc2lnbkluID0gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbjtcblxuLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG52YXIgX2VzY2FwZVN0cmluZ0NoYXIgPSBlc2NhcGVTdHJpbmdDaGFyO1xuXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxudmFyIF9yZUludGVycG9sYXRlID0gcmVJbnRlcnBvbGF0ZTtcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBfYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG52YXIgX2VzY2FwZUh0bWxDaGFyID0gZXNjYXBlSHRtbENoYXI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmdfMShzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBfZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbnZhciBfZXNjYXBlID0gZXNjYXBlO1xuXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbnZhciBfcmVFc2NhcGUgPSByZUVzY2FwZTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxudmFyIF9yZUV2YWx1YXRlID0gcmVFdmFsdWF0ZTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IF9yZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IF9yZUV2YWx1YXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2ludGVycG9sYXRlJzogX3JlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBfZXNjYXBlIH1cbiAgfVxufTtcblxudmFyIHRlbXBsYXRlU2V0dGluZ3NfMSA9IHRlbXBsYXRlU2V0dGluZ3M7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaFxuICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAqL1xudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kaSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JGYgPSBvYmplY3RQcm90byRpLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gKlxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXG4gKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICpcbiAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICpcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gKlxuICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gKlxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAqIGNvbXBpbGVkKGRhdGEpO1xuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAqXG4gKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAqIGNvbXBpbGVkLnNvdXJjZTtcbiAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAqIC8vICAgcmV0dXJuIF9fcDtcbiAqIC8vIH1cbiAqXG4gKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAqICAgdmFyIEpTVCA9IHtcXFxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gKiAgIH07XFxcbiAqICcpO1xuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgdmFyIHNldHRpbmdzID0gdGVtcGxhdGVTZXR0aW5nc18xLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3NfMTtcblxuICBpZiAoZ3VhcmQgJiYgX2lzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZ18xKHN0cmluZyk7XG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGhfMSh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIF9jdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aF8xKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIF9jdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5c18xKGltcG9ydHMpLFxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IF9iYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICB2YXIgaXNFc2NhcGluZyxcbiAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAoaW50ZXJwb2xhdGUgPT09IF9yZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHdpdGggbG9va3VwIChpbiBjYXNlIG9mIGUuZy4gcHJvdG90eXBlIHBvbGx1dGlvbiksIGFuZCBzdHJpcCBuZXdsaW5lcyBpZiBhbnkuXG4gIC8vIEEgbmV3bGluZSB3b3VsZG4ndCBiZSBhIHZhbGlkIHNvdXJjZVVSTCBhbnl3YXksIGFuZCBpdCdkIGVuYWJsZSBjb2RlIGluamVjdGlvbi5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5JGYuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICA/ICgnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKSArXG4gICAgICAgJ1xcbicpXG4gICAgOiAnJztcblxuICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgX2VzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgLy8gYXMgdGhpcyBjb25maWd1cmF0aW9uIGlzIGEgY29kZSBpbmplY3Rpb24gdmVjdG9yLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eSRmLmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgaWYgKCF2YXJpYWJsZSkge1xuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICB9XG4gIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgKHZhcmlhYmxlXG4gICAgICA/ICcnXG4gICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgKSArXG4gICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAoaXNFc2NhcGluZ1xuICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgOiAnJ1xuICAgICkgK1xuICAgIChpc0V2YWx1YXRpbmdcbiAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgIDogJztcXG4nXG4gICAgKSArXG4gICAgc291cmNlICtcbiAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0XzEoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yXzEocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgdGVtcGxhdGVfMSA9IHRlbXBsYXRlO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAqIC8vID0+ICctLWZvby1iYXItLSdcbiAqXG4gKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ2Zvb2JhcidcbiAqXG4gKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnX19mb29fYmFyX18nXG4gKi9cbmZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nXzEodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG59XG5cbnZhciB0b0xvd2VyXzEgPSB0b0xvd2VyO1xuXG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuZnVuY3Rpb24gdG9EYXRlKGFyZ3VtZW50KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgYXJnU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KTsgLy8gQ2xvbmUgdGhlIGRhdGVcblxuICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgYXJnU3RyID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmICgodHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IFN0cmluZ10nKSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJTdGFydGluZyB3aXRoIHYyLjAuMC1iZXRhLjEgZGF0ZS1mbnMgZG9lc24ndCBhY2NlcHQgc3RyaW5ncyBhcyBhcmd1bWVudHMuIFBsZWFzZSB1c2UgYHBhcnNlSVNPYCB0byBwYXJzZSBzdHJpbmdzLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2ZqdWxlXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCkuc3RhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvSW50ZWdlciQxKGRpcnR5TnVtYmVyKSB7XG4gIGlmIChkaXJ0eU51bWJlciA9PT0gbnVsbCB8fCBkaXJ0eU51bWJlciA9PT0gdHJ1ZSB8fCBkaXJ0eU51bWJlciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XG5cbiAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgcmV0dXJuIG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKTtcbn1cblxuLyoqXG4gKiBAbmFtZSBhZGRNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgYWRkZWRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA3NTAgbWlsbGlzZWNvbmRzIHRvIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiB2YXIgcmVzdWx0ID0gYWRkTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MzAuNzUwXG4gKi9cblxuZnVuY3Rpb24gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgdGltZXN0YW1wID0gdG9EYXRlKGRpcnR5RGF0ZSkuZ2V0VGltZSgpO1xuICB2YXIgYW1vdW50ID0gdG9JbnRlZ2VyJDEoZGlydHlBbW91bnQpO1xuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgYW1vdW50KTtcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMDtcbi8qKlxuICogR29vZ2xlIENocm9tZSBhcyBvZiA2Ny4wLjMzOTYuODcgaW50cm9kdWNlZCB0aW1lem9uZXMgd2l0aCBvZmZzZXQgdGhhdCBpbmNsdWRlcyBzZWNvbmRzLlxuICogVGhleSB1c3VhbGx5IGFwcGVhciBmb3IgZGF0ZXMgdGhhdCBkZW5vdGUgdGltZSBiZWZvcmUgdGhlIHRpbWV6b25lcyB3ZXJlIGludHJvZHVjZWRcbiAqIChlLmcuIGZvciAnRXVyb3BlL1ByYWd1ZScgdGltZXpvbmUgdGhlIG9mZnNldCBpcyBHTVQrMDA6NTc6NDQgYmVmb3JlIDEgT2N0b2JlciAxODkxXG4gKiBhbmQgR01UKzAxOjAwOjAwIGFmdGVyIHRoYXQgZGF0ZSlcbiAqXG4gKiBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBpbiBtaW51dGVzIGFuZCB3b3VsZCByZXR1cm4gNTcgZm9yIHRoZSBleGFtcGxlIGFib3ZlLFxuICogd2hpY2ggd291bGQgbGVhZCB0byBpbmNvcnJlY3QgY2FsY3VsYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcyB0aGF0IHRha2VzIHNlY29uZHMgaW4gYWNjb3VudC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRpcnR5RGF0ZS5nZXRUaW1lKCkpO1xuICB2YXIgYmFzZVRpbWV6b25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBkYXRlLnNldFNlY29uZHMoMCwgMCk7XG4gIHZhciBtaWxsaXNlY29uZHNQYXJ0T2ZUaW1lem9uZU9mZnNldCA9IGRhdGUuZ2V0VGltZSgpICUgTUlMTElTRUNPTkRTX0lOX01JTlVURTtcbiAgcmV0dXJuIGJhc2VUaW1lem9uZU9mZnNldCAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUgKyBtaWxsaXNlY29uZHNQYXJ0T2ZUaW1lem9uZU9mZnNldDtcbn1cblxuLyoqXG4gKiBAbmFtZSBpc1ZhbGlkXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIHZhbGlkP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyBmYWxzZSBpZiBhcmd1bWVudCBpcyBJbnZhbGlkIERhdGUgYW5kIHRydWUgb3RoZXJ3aXNlLlxuICogQXJndW1lbnQgaXMgY29udmVydGVkIHRvIERhdGUgdXNpbmcgYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICpcbiAqIFRpbWUgdmFsdWUgb2YgRGF0ZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS45LjEuMVxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogLSBOb3cgYGlzVmFsaWRgIGRvZXNuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uXG4gKiAgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqICAgSW5zdGVhZCwgYXJndW1lbnQgaXMgY29udmVydGVkIGJlZm9yZWhhbmQgdXNpbmcgYHRvRGF0ZWAuXG4gKlxuICogICBFeGFtcGxlczpcbiAqXG4gKiAgIHwgYGlzVmFsaWRgIGFyZ3VtZW50ICAgICAgICB8IEJlZm9yZSB2Mi4wLjAgfCB2Mi4wLjAgb253YXJkIHxcbiAqICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tfFxuICogICB8IGBuZXcgRGF0ZSgpYCAgICAgICAgICAgICAgfCBgdHJ1ZWAgICAgICAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKCcyMDE2LTAxLTAxJylgICB8IGB0cnVlYCAgICAgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoJycpYCAgICAgICAgICAgIHwgYGZhbHNlYCAgICAgICB8IGBmYWxzZWAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZSgxNDg4MzcwODM1MDgxKWAgfCBgdHJ1ZWAgICAgICAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKE5hTilgICAgICAgICAgICB8IGBmYWxzZWAgICAgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgJzIwMTYtMDEtMDEnYCAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGAnJ2AgICAgICAgICAgICAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYDE0ODgzNzA4MzUwODFgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgTmFOYCAgICAgICAgICAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGBmYWxzZWAgICAgICAgfFxuICpcbiAqICAgV2UgaW50cm9kdWNlIHRoaXMgY2hhbmdlIHRvIG1ha2UgKmRhdGUtZm5zKiBjb25zaXN0ZW50IHdpdGggRUNNQVNjcmlwdCBiZWhhdmlvclxuICogICB0aGF0IHRyeSB0byBjb2VyY2UgYXJndW1lbnRzIHRvIHRoZSBleHBlY3RlZCB0eXBlXG4gKiAgICh3aGljaCBpcyBhbHNvIHRoZSBjYXNlIHdpdGggb3RoZXIgKmRhdGUtZm5zKiBmdW5jdGlvbnMpLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGUgaXMgdmFsaWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbGlkIGRhdGU6XG4gKiB2YXIgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgyMDE0LCAxLCAzMSkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWx1ZSwgY29udmVydGFibGUgaW50byBhIGRhdGU6XG4gKiB2YXIgcmVzdWx0ID0gaXNWYWxpZCgxMzkzODA0ODAwMDAwKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgaW52YWxpZCBkYXRlOlxuICogdmFyIHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoJycpKVxuICogLy89PiBmYWxzZVxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWQoZGlydHlEYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICByZXR1cm4gIWlzTmFOKGRhdGUpO1xufVxuXG52YXIgZm9ybWF0RGlzdGFuY2VMb2NhbGUgPSB7XG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcbiAgICBvbmU6ICdsZXNzIHRoYW4gYSBzZWNvbmQnLFxuICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBzZWNvbmRzJ1xuICB9LFxuICB4U2Vjb25kczoge1xuICAgIG9uZTogJzEgc2Vjb25kJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBzZWNvbmRzJ1xuICB9LFxuICBoYWxmQU1pbnV0ZTogJ2hhbGYgYSBtaW51dGUnLFxuICBsZXNzVGhhblhNaW51dGVzOiB7XG4gICAgb25lOiAnbGVzcyB0aGFuIGEgbWludXRlJyxcbiAgICBvdGhlcjogJ2xlc3MgdGhhbiB7e2NvdW50fX0gbWludXRlcydcbiAgfSxcbiAgeE1pbnV0ZXM6IHtcbiAgICBvbmU6ICcxIG1pbnV0ZScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gbWludXRlcydcbiAgfSxcbiAgYWJvdXRYSG91cnM6IHtcbiAgICBvbmU6ICdhYm91dCAxIGhvdXInLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IGhvdXJzJ1xuICB9LFxuICB4SG91cnM6IHtcbiAgICBvbmU6ICcxIGhvdXInLFxuICAgIG90aGVyOiAne3tjb3VudH19IGhvdXJzJ1xuICB9LFxuICB4RGF5czoge1xuICAgIG9uZTogJzEgZGF5JyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBkYXlzJ1xuICB9LFxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBvbmU6ICcxIG1vbnRoJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIGFib3V0WFllYXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSB5ZWFyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgb3ZlclhZZWFyczoge1xuICAgIG9uZTogJ292ZXIgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ292ZXIge3tjb3VudH19IHllYXJzJ1xuICB9LFxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBvbmU6ICdhbG1vc3QgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXG4gIH1cbn07XG5mdW5jdGlvbiBmb3JtYXREaXN0YW5jZSh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKHR5cGVvZiBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dO1xuICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0ub3RoZXIucmVwbGFjZSgne3tjb3VudH19JywgY291bnQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiA+IDApIHtcbiAgICAgIHJldHVybiAnaW4gJyArIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdCArICcgYWdvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBidWlsZEZvcm1hdExvbmdGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuICAgIHZhciBmb3JtYXQgPSBhcmdzLmZvcm1hdHNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0c1thcmdzLmRlZmF1bHRXaWR0aF07XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfTtcbn1cblxudmFyIGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiAnRUVFRSwgTU1NTSBkbywgeScsXG4gIGxvbmc6ICdNTU1NIGRvLCB5JyxcbiAgbWVkaXVtOiAnTU1NIGQsIHknLFxuICBzaG9ydDogJ01NL2RkL3l5eXknXG59O1xudmFyIHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAnaDptbTpzcyBhIHp6enonLFxuICBsb25nOiAnaDptbTpzcyBhIHonLFxuICBtZWRpdW06ICdoOm1tOnNzIGEnLFxuICBzaG9ydDogJ2g6bW0gYSdcbn07XG52YXIgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIG1lZGl1bTogJ3t7ZGF0ZX19LCB7e3RpbWV9fScsXG4gIHNob3J0OiAne3tkYXRlfX0sIHt7dGltZX19J1xufTtcbnZhciBmb3JtYXRMb25nID0ge1xuICBkYXRlOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiB0aW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgZGF0ZVRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlVGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSlcbn07XG5cbnZhciBmb3JtYXRSZWxhdGl2ZUxvY2FsZSA9IHtcbiAgbGFzdFdlZWs6IFwiJ2xhc3QnIGVlZWUgJ2F0JyBwXCIsXG4gIHllc3RlcmRheTogXCIneWVzdGVyZGF5IGF0JyBwXCIsXG4gIHRvZGF5OiBcIid0b2RheSBhdCcgcFwiLFxuICB0b21vcnJvdzogXCIndG9tb3Jyb3cgYXQnIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAnYXQnIHBcIixcbiAgb3RoZXI6ICdQJ1xufTtcbmZ1bmN0aW9uIGZvcm1hdFJlbGF0aXZlKHRva2VuLCBfZGF0ZSwgX2Jhc2VEYXRlLCBfb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dO1xufVxuXG5mdW5jdGlvbiBidWlsZExvY2FsaXplRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5SW5kZXgsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0ID8gU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgOiAnc3RhbmRhbG9uZSc7XG4gICAgdmFyIHZhbHVlc0FycmF5O1xuXG4gICAgaWYgKGNvbnRleHQgPT09ICdmb3JtYXR0aW5nJyAmJiBhcmdzLmZvcm1hdHRpbmdWYWx1ZXMpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRGb3JtYXR0aW5nV2lkdGggfHwgYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogZGVmYXVsdFdpZHRoO1xuICAgICAgdmFsdWVzQXJyYXkgPSBhcmdzLmZvcm1hdHRpbmdWYWx1ZXNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1tkZWZhdWx0V2lkdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2RlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YXIgX3dpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MudmFsdWVzW193aWR0aF0gfHwgYXJncy52YWx1ZXNbX2RlZmF1bHRXaWR0aF07XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gYXJncy5hcmd1bWVudENhbGxiYWNrID8gYXJncy5hcmd1bWVudENhbGxiYWNrKGRpcnR5SW5kZXgpIDogZGlydHlJbmRleDtcbiAgICByZXR1cm4gdmFsdWVzQXJyYXlbaW5kZXhdO1xuICB9O1xufVxuXG52YXIgZXJhVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnQicsICdBJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0JDJywgJ0FEJ10sXG4gIHdpZGU6IFsnQmVmb3JlIENocmlzdCcsICdBbm5vIERvbWluaSddXG59O1xudmFyIHF1YXJ0ZXJWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWycxJywgJzInLCAnMycsICc0J10sXG4gIGFiYnJldmlhdGVkOiBbJ1ExJywgJ1EyJywgJ1EzJywgJ1E0J10sXG4gIHdpZGU6IFsnMXN0IHF1YXJ0ZXInLCAnMm5kIHF1YXJ0ZXInLCAnM3JkIHF1YXJ0ZXInLCAnNHRoIHF1YXJ0ZXInXSAvLyBOb3RlOiBpbiBFbmdsaXNoLCB0aGUgbmFtZXMgb2YgZGF5cyBvZiB0aGUgd2VlayBhbmQgbW9udGhzIGFyZSBjYXBpdGFsaXplZC5cbiAgLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4gIC8vIEdlbmVyYWxseSwgZm9ybWF0dGVkIGRhdGVzIHNob3VsZCBsb29rIGxpa2UgdGhleSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHNlbnRlbmNlLFxuICAvLyBlLmcuIGluIFNwYW5pc2ggbGFuZ3VhZ2UgdGhlIHdlZWtkYXlzIGFuZCBtb250aHMgc2hvdWxkIGJlIGluIHRoZSBsb3dlcmNhc2UuXG5cbn07XG52YXIgbW9udGhWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydKJywgJ0YnLCAnTScsICdBJywgJ00nLCAnSicsICdKJywgJ0EnLCAnUycsICdPJywgJ04nLCAnRCddLFxuICBhYmJyZXZpYXRlZDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICB3aWRlOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXVxufTtcbnZhciBkYXlWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gIHNob3J0OiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXG4gIGFiYnJldmlhdGVkOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICB3aWRlOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J11cbn07XG52YXIgZGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ2EnLFxuICAgIHBtOiAncCcsXG4gICAgbWlkbmlnaHQ6ICdtaScsXG4gICAgbm9vbjogJ24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAnQU0nLFxuICAgIHBtOiAnUE0nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAnYS5tLicsXG4gICAgcG06ICdwLm0uJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH1cbn07XG52YXIgZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06ICdhJyxcbiAgICBwbTogJ3AnLFxuICAgIG1pZG5pZ2h0OiAnbWknLFxuICAgIG5vb246ICduJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogJ0FNJyxcbiAgICBwbTogJ1BNJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ2EubS4nLFxuICAgIHBtOiAncC5tLicsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcmRpbmFsTnVtYmVyKGRpcnR5TnVtYmVyLCBfZGlydHlPcHRpb25zKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpOyAvLyBJZiBvcmRpbmFsIG51bWJlcnMgZGVwZW5kIG9uIGNvbnRleHQsIGZvciBleGFtcGxlLFxuICAvLyBpZiB0aGV5IGFyZSBkaWZmZXJlbnQgZm9yIGRpZmZlcmVudCBncmFtbWF0aWNhbCBnZW5kZXJzLFxuICAvLyB1c2UgYG9wdGlvbnMudW5pdGA6XG4gIC8vXG4gIC8vICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge31cbiAgLy8gICB2YXIgdW5pdCA9IFN0cmluZyhvcHRpb25zLnVuaXQpXG4gIC8vXG4gIC8vIHdoZXJlIGB1bml0YCBjYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RhdGUnLCAnZGF5T2ZZZWFyJyxcbiAgLy8gJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnXG5cbiAgdmFyIHJlbTEwMCA9IG51bWJlciAlIDEwMDtcblxuICBpZiAocmVtMTAwID4gMjAgfHwgcmVtMTAwIDwgMTApIHtcbiAgICBzd2l0Y2ggKHJlbTEwMCAlIDEwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnc3QnO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnbmQnO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAncmQnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1iZXIgKyAndGgnO1xufVxuXG52YXIgbG9jYWxpemUgPSB7XG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXG4gIGVyYTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGVyYVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZScsXG4gICAgYXJndW1lbnRDYWxsYmFjazogZnVuY3Rpb24gKHF1YXJ0ZXIpIHtcbiAgICAgIHJldHVybiBOdW1iZXIocXVhcnRlcikgLSAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogJ3dpZGUnXG4gIH0pXG59O1xuXG5mdW5jdGlvbiBidWlsZE1hdGNoUGF0dGVybkZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eVN0cmluZywgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhkaXJ0eVN0cmluZyk7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MubWF0Y2hQYXR0ZXJuKTtcblxuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MucGFyc2VQYXR0ZXJuKTtcblxuICAgIGlmICghcGFyc2VSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayhwYXJzZVJlc3VsdFswXSkgOiBwYXJzZVJlc3VsdFswXTtcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFjayA/IG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcmVzdDogc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKVxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWF0Y2hGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoZGlydHlTdHJpbmcpO1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgdmFyIG1hdGNoUGF0dGVybiA9IHdpZHRoICYmIGFyZ3MubWF0Y2hQYXR0ZXJuc1t3aWR0aF0gfHwgYXJncy5tYXRjaFBhdHRlcm5zW2FyZ3MuZGVmYXVsdE1hdGNoV2lkdGhdO1xuICAgIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChtYXRjaFBhdHRlcm4pO1xuXG4gICAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcbiAgICB2YXIgcGFyc2VQYXR0ZXJucyA9IHdpZHRoICYmIGFyZ3MucGFyc2VQYXR0ZXJuc1t3aWR0aF0gfHwgYXJncy5wYXJzZVBhdHRlcm5zW2FyZ3MuZGVmYXVsdFBhcnNlV2lkdGhdO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGFyc2VQYXR0ZXJucykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VQYXR0ZXJucy5maW5kSW5kZXgoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChzdHJpbmcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gZmluZEtleShwYXJzZVBhdHRlcm5zLCBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHN0cmluZyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFjayA/IG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcmVzdDogc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKVxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBwcmVkaWNhdGUob2JqZWN0W2tleV0pKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxufVxuXG52YXIgbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaTtcbnZhciBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcbnZhciBtYXRjaEVyYVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGJ8YSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGJcXC4/XFxzP2NcXC4/fGJcXC4/XFxzP2NcXC4/XFxzP2VcXC4/fGFcXC4/XFxzP2RcXC4/fGNcXC4/XFxzP2VcXC4/KS9pLFxuICB3aWRlOiAvXihiZWZvcmUgY2hyaXN0fGJlZm9yZSBjb21tb24gZXJhfGFubm8gZG9taW5pfGNvbW1vbiBlcmEpL2lcbn07XG52YXIgcGFyc2VFcmFQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15iL2ksIC9eKGF8YykvaV1cbn07XG52YXIgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9ecVsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XSh0aHxzdHxuZHxyZCk/IHF1YXJ0ZXIvaVxufTtcbnZhciBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV1cbn07XG52YXIgbWF0Y2hNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW2pmbWFzb25kXS9pLFxuICBhYmJyZXZpYXRlZDogL14oamFufGZlYnxtYXJ8YXByfG1heXxqdW58anVsfGF1Z3xzZXB8b2N0fG5vdnxkZWMpL2ksXG4gIHdpZGU6IC9eKGphbnVhcnl8ZmVicnVhcnl8bWFyY2h8YXByaWx8bWF5fGp1bmV8anVseXxhdWd1c3R8c2VwdGVtYmVyfG9jdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2lcbn07XG52YXIgcGFyc2VNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXmovaSwgL15mL2ksIC9ebS9pLCAvXmEvaSwgL15tL2ksIC9eai9pLCAvXmovaSwgL15hL2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXSxcbiAgYW55OiBbL15qYS9pLCAvXmYvaSwgL15tYXIvaSwgL15hcC9pLCAvXm1heS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxufTtcbnZhciBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW3NtdHdmXS9pLFxuICBzaG9ydDogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihzdW58bW9ufHR1ZXx3ZWR8dGh1fGZyaXxzYXQpL2ksXG4gIHdpZGU6IC9eKHN1bmRheXxtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5KS9pXG59O1xudmFyIHBhcnNlRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9ecy9pLCAvXm0vaSwgL150L2ksIC9edy9pLCAvXnQvaSwgL15mL2ksIC9ecy9pXSxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxufTtcbnZhciBtYXRjaERheVBlcmlvZFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGF8cHxtaXxufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaSxcbiAgYW55OiAvXihbYXBdXFwuP1xccz9tXFwuP3xtaWRuaWdodHxub29ufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaVxufTtcbnZhciBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xuICBhbnk6IHtcbiAgICBhbTogL15hL2ksXG4gICAgcG06IC9ecC9pLFxuICAgIG1pZG5pZ2h0OiAvXm1pL2ksXG4gICAgbm9vbjogL15uby9pLFxuICAgIG1vcm5pbmc6IC9tb3JuaW5nL2ksXG4gICAgYWZ0ZXJub29uOiAvYWZ0ZXJub29uL2ksXG4gICAgZXZlbmluZzogL2V2ZW5pbmcvaSxcbiAgICBuaWdodDogL25pZ2h0L2lcbiAgfVxufTtcbnZhciBtYXRjaCA9IHtcbiAgb3JkaW5hbE51bWJlcjogYnVpbGRNYXRjaFBhdHRlcm5Gbih7XG4gICAgbWF0Y2hQYXR0ZXJuOiBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfSksXG4gIGVyYTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaEVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueScsXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnYW55JyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KVxufTtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAqIEBsYW5ndWFnZSBFbmdsaXNoXG4gKiBAaXNvLTYzOS0yIGVuZ1xuICogQGF1dGhvciBTYXNoYSBLb3NzIFtAa29zc25vY29ycF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tvc3Nub2NvcnB9XG4gKiBAYXV0aG9yIExlc2hhIEtvc3MgW0BsZXNoYWtvc3Nde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNoYWtvc3N9XG4gKi9cblxudmFyIGxvY2FsZSA9IHtcbiAgZm9ybWF0RGlzdGFuY2U6IGZvcm1hdERpc3RhbmNlLFxuICBmb3JtYXRMb25nOiBmb3JtYXRMb25nLFxuICBmb3JtYXRSZWxhdGl2ZTogZm9ybWF0UmVsYXRpdmUsXG4gIGxvY2FsaXplOiBsb2NhbGl6ZSxcbiAgbWF0Y2g6IG1hdGNoLFxuICBvcHRpb25zOiB7XG4gICAgd2Vla1N0YXJ0c09uOiAwXG4gICAgLyogU3VuZGF5ICovXG4gICAgLFxuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogMVxuICB9XG59O1xuXG4vKipcbiAqIEBuYW1lIHN1Yk1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIHN1YnRyYWN0ZWRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIHN1YnRyYWN0ZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgNzUwIG1pbGxpc2Vjb25kcyBmcm9tIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiB2YXIgcmVzdWx0ID0gc3ViTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MjkuMjUwXG4gKi9cblxuZnVuY3Rpb24gc3ViTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgYW1vdW50ID0gdG9JbnRlZ2VyJDEoZGlydHlBbW91bnQpO1xuICByZXR1cm4gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgLWFtb3VudCk7XG59XG5cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvcyhudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgPyAnLScgOiAnJztcbiAgdmFyIG91dHB1dCA9IE1hdGguYWJzKG51bWJlcikudG9TdHJpbmcoKTtcblxuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBzaWduICsgb3V0cHV0O1xufVxuXG4vKlxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHtcbiAgLy8gWWVhclxuICB5OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICAvLyBGcm9tIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzEvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X3Rva2Vuc1xuICAgIC8vIHwgWWVhciAgICAgfCAgICAgeSB8IHl5IHwgICB5eXkgfCAgeXl5eSB8IHl5eXl5IHxcbiAgICAvLyB8LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAgLy8gfCBBRCAxICAgICB8ICAgICAxIHwgMDEgfCAgIDAwMSB8ICAwMDAxIHwgMDAwMDEgfFxuICAgIC8vIHwgQUQgMTIgICAgfCAgICAxMiB8IDEyIHwgICAwMTIgfCAgMDAxMiB8IDAwMDEyIHxcbiAgICAvLyB8IEFEIDEyMyAgIHwgICAxMjMgfCAyMyB8ICAgMTIzIHwgIDAxMjMgfCAwMDEyMyB8XG4gICAgLy8gfCBBRCAxMjM0ICB8ICAxMjM0IHwgMzQgfCAgMTIzNCB8ICAxMjM0IHwgMDEyMzQgfFxuICAgIC8vIHwgQUQgMTIzNDUgfCAxMjM0NSB8IDQ1IHwgMTIzNDUgfCAxMjM0NSB8IDEyMzQ1IHxcbiAgICB2YXIgc2lnbmVkWWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTsgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcblxuICAgIHZhciB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0b2tlbiA9PT0gJ3l5JyA/IHllYXIgJSAxMDAgOiB5ZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNb250aFxuICBNOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgcmV0dXJuIHRva2VuID09PSAnTScgPyBTdHJpbmcobW9udGggKyAxKSA6IGFkZExlYWRpbmdaZXJvcyhtb250aCArIDEsIDIpO1xuICB9LFxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENEYXRlKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXRlLmdldFVUQ0hvdXJzKCkgLyAxMiA+PSAxID8gJ3BtJyA6ICdhbSc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdhJzpcbiAgICAgIGNhc2UgJ2FhJzpcbiAgICAgIGNhc2UgJ2FhYSc6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgY2FzZSAnYWFhYWEnOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlWzBdO1xuXG4gICAgICBjYXNlICdhYWFhJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWUgPT09ICdhbScgPyAnYS5tLicgOiAncC5tLic7XG4gICAgfVxuICB9LFxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDSG91cnMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENNaW51dGVzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIFNlY29uZFxuICBzOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDU2Vjb25kcygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUzogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIG51bWJlck9mRGlnaXRzID0gdG9rZW4ubGVuZ3RoO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHZhciBmcmFjdGlvbmFsU2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzICogTWF0aC5wb3coMTAsIG51bWJlck9mRGlnaXRzIC0gMykpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZnJhY3Rpb25hbFNlY29uZHMsIHRva2VuLmxlbmd0aCk7XG4gIH1cbn07XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fREFZID0gODY0MDAwMDA7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBnZXRVVENEYXlPZlllYXIoZGlydHlEYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mWWVhclRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICB2YXIgZGlmZmVyZW5jZSA9IHRpbWVzdGFtcCAtIHN0YXJ0T2ZZZWFyVGltZXN0YW1wO1xuICByZXR1cm4gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gTUlMTElTRUNPTkRTX0lOX0RBWSkgKyAxO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHN0YXJ0T2ZVVENJU09XZWVrKGRpcnR5RGF0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIHdlZWtTdGFydHNPbiA9IDE7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuICB2YXIgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBnZXRVVENJU09XZWVrWWVhcihkaXJ0eURhdGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciA9IG5ldyBEYXRlKDApO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIgKyAxLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIpO1xuICB2YXIgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciA9IG5ldyBEYXRlKDApO1xuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZlRoaXNZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhcik7XG5cbiAgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDE7XG4gIH0gZWxzZSBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB5ZWFyIC0gMTtcbiAgfVxufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHN0YXJ0T2ZVVENJU09XZWVrWWVhcihkaXJ0eURhdGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciB5ZWFyID0gZ2V0VVRDSVNPV2Vla1llYXIoZGlydHlEYXRlKTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeSA9IG5ldyBEYXRlKDApO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIGRhdGUgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnkpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9XRUVLID0gNjA0ODAwMDAwOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gZ2V0VVRDSVNPV2VlayhkaXJ0eURhdGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkaWZmID0gc3RhcnRPZlVUQ0lTT1dlZWsoZGF0ZSkuZ2V0VGltZSgpIC0gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRhdGUpLmdldFRpbWUoKTsgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gIC8vIChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdClcblxuICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gTUlMTElTRUNPTkRTX0lOX1dFRUspICsgMTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzdGFydE9mVVRDV2VlayhkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZVdlZWtTdGFydHNPbiA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyJDEobG9jYWxlV2Vla1N0YXJ0c09uKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyJDEob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuICB2YXIgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBnZXRVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU7XG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyAxIDogdG9JbnRlZ2VyJDEobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyJDEob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBmaXJzdFdlZWtPZk5leHRZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWtPZk5leHRZZWFyLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZmlyc3RXZWVrT2ZUaGlzWWVhciA9IG5ldyBEYXRlKDApO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWtPZlRoaXNZZWFyLCBkaXJ0eU9wdGlvbnMpO1xuXG4gIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxO1xuICB9IGVsc2UgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzdGFydE9mVVRDV2Vla1llYXIoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlciQxKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA6IHRvSW50ZWdlciQxKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIHllYXIgPSBnZXRVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmaXJzdFdlZWsgPSBuZXcgRGF0ZSgwKTtcbiAgZmlyc3RXZWVrLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vlay5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIGRhdGUgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWssIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUskMSA9IDYwNDgwMDAwMDsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIGdldFVUQ1dlZWsoZGlydHlEYXRlLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGlmZiA9IHN0YXJ0T2ZVVENXZWVrKGRhdGUsIG9wdGlvbnMpLmdldFRpbWUoKSAtIHN0YXJ0T2ZVVENXZWVrWWVhcihkYXRlLCBvcHRpb25zKS5nZXRUaW1lKCk7IC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG4gIC8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudFxuICAvLyAoZS5nLiBpdCdzIGRpZmZlcmVudCBpbiB0aGUgd2VlayBvZiB0aGUgZGF5bGlnaHQgc2F2aW5nIHRpbWUgY2xvY2sgc2hpZnQpXG5cbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLJDEpICsgMTtcbn1cblxudmFyIGRheVBlcmlvZEVudW0gPSB7XG4gIGFtOiAnYW0nLFxuICBwbTogJ3BtJyxcbiAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gIG5vb246ICdub29uJyxcbiAgbW9ybmluZzogJ21vcm5pbmcnLFxuICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICBldmVuaW5nOiAnZXZlbmluZycsXG4gIG5pZ2h0OiAnbmlnaHQnXG4gIC8qXG4gICAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8IE1pbGxpc2Vjb25kcyBpbiBkYXkgICAgICAgICAgICB8XG4gICAqIHwgIGIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgIHwgIEIgIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgIHxcbiAgICogfCAgYyAgfCBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2VlayAgfCAgQyogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfFxuICAgKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIGUgIHwgTG9jYWwgZGF5IG9mIHdlZWsgICAgICAgICAgICAgIHwgIEUgIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgZiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgRiogfCBEYXkgb2Ygd2VlayBpbiBtb250aCAgICAgICAgICAgfFxuICAgKiB8ICBnKiB8IE1vZGlmaWVkIEp1bGlhbiBkYXkgICAgICAgICAgICB8ICBHICB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgaSEgfCBJU08gZGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgfCAgSSEgfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgfFxuICAgKiB8ICBqKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8ICBKKiB8IExvY2FsaXplZCBob3VyIHcvbyBkYXkgcGVyaW9kICB8XG4gICAqIHwgIGsgIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgIHwgIEsgIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgbCogfCAoZGVwcmVjYXRlZCkgICAgICAgICAgICAgICAgICAgfCAgTCAgfCBTdGFuZC1hbG9uZSBtb250aCAgICAgICAgICAgICAgfFxuICAgKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgIG4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgbyEgfCBPcmRpbmFsIG51bWJlciBtb2RpZmllciAgICAgICAgfCAgTyAgfCBUaW1lem9uZSAoR01UKSAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICBwISB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICB8ICBQISB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICB8XG4gICAqIHwgIHEgIHwgU3RhbmQtYWxvbmUgcXVhcnRlciAgICAgICAgICAgIHwgIFEgIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgciogfCBSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyICAgICAgICAgfCAgUiEgfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgfFxuICAgKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gICAqIHwgIHQhIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgIHwgIFQhIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgIHxcbiAgICogfCAgdSAgfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgfCAgVSogfCBDeWNsaWMgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICB2KiB8IFRpbWV6b25lIChnZW5lcmljIG5vbi1sb2NhdC4pICB8ICBWKiB8IFRpbWV6b25lIChsb2NhdGlvbikgICAgICAgICAgICB8XG4gICAqIHwgIHcgIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgIHwgIFcqIHwgV2VlayBvZiBtb250aCAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgeCAgfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgfCAgWCAgfCBUaW1lem9uZSAoSVNPLTg2MDEpICAgICAgICAgICAgfFxuICAgKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICB8XG4gICAqIHwgIHogIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pIHwgIFoqIHwgVGltZXpvbmUgKGFsaWFzZXMpICAgICAgICAgICAgIHxcbiAgICpcbiAgICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICAgKlxuICAgKiBMZXR0ZXJzIG1hcmtlZCBieSAhIGFyZSBub24tc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBkYXRlLWZuczpcbiAgICogLSBgb2AgbW9kaWZpZXMgdGhlIHByZXZpb3VzIHRva2VuIHRvIHR1cm4gaXQgaW50byBhbiBvcmRpbmFsIChzZWUgYGZvcm1hdGAgZG9jcylcbiAgICogLSBgaWAgaXMgSVNPIGRheSBvZiB3ZWVrLiBGb3IgYGlgIGFuZCBgaWlgIGlzIHJldHVybnMgbnVtZXJpYyBJU08gd2VlayBkYXlzLFxuICAgKiAgIGkuZS4gNyBmb3IgU3VuZGF5LCAxIGZvciBNb25kYXksIGV0Yy5cbiAgICogLSBgSWAgaXMgSVNPIHdlZWsgb2YgeWVhciwgYXMgb3Bwb3NlZCB0byBgd2Agd2hpY2ggaXMgbG9jYWwgd2VlayBvZiB5ZWFyLlxuICAgKiAtIGBSYCBpcyBJU08gd2Vlay1udW1iZXJpbmcgeWVhciwgYXMgb3Bwb3NlZCB0byBgWWAgd2hpY2ggaXMgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAgICogICBgUmAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBJYCBhbmQgYGlgXG4gICAqICAgZm9yIHVuaXZlcnNhbCBJU08gd2Vlay1udW1iZXJpbmcgZGF0ZSwgd2hlcmVhc1xuICAgKiAgIGBZYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdgIGFuZCBgZWBcbiAgICogICBmb3Igd2Vlay1udW1iZXJpbmcgZGF0ZSBzcGVjaWZpYyB0byB0aGUgbG9jYWxlLlxuICAgKiAtIGBQYCBpcyBsb25nIGxvY2FsaXplZCBkYXRlIGZvcm1hdFxuICAgKiAtIGBwYCBpcyBsb25nIGxvY2FsaXplZCB0aW1lIGZvcm1hdFxuICAgKi9cblxufTtcbnZhciBmb3JtYXR0ZXJzJDEgPSB7XG4gIC8vIEVyYVxuICBHOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGVyYSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+IDAgPyAxIDogMDtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEFELCBCQ1xuICAgICAgY2FzZSAnRyc6XG4gICAgICBjYXNlICdHRyc6XG4gICAgICBjYXNlICdHR0cnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnXG4gICAgICAgIH0pO1xuICAgICAgLy8gQSwgQlxuXG4gICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnXG4gICAgICAgIH0pO1xuICAgICAgLy8gQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3RcblxuICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICAvLyBPcmRpbmFsIG51bWJlclxuICAgIGlmICh0b2tlbiA9PT0gJ3lvJykge1xuICAgICAgdmFyIHNpZ25lZFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7IC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG5cbiAgICAgIHZhciB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih5ZWFyLCB7XG4gICAgICAgIHVuaXQ6ICd5ZWFyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMueShkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgWTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBzaWduZWRXZWVrWWVhciA9IGdldFVUQ1dlZWtZZWFyKGRhdGUsIG9wdGlvbnMpOyAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuXG4gICAgdmFyIHdlZWtZZWFyID0gc2lnbmVkV2Vla1llYXIgPiAwID8gc2lnbmVkV2Vla1llYXIgOiAxIC0gc2lnbmVkV2Vla1llYXI7IC8vIFR3byBkaWdpdCB5ZWFyXG5cbiAgICBpZiAodG9rZW4gPT09ICdZWScpIHtcbiAgICAgIHZhciB0d29EaWdpdFllYXIgPSB3ZWVrWWVhciAlIDEwMDtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModHdvRGlnaXRZZWFyLCAyKTtcbiAgICB9IC8vIE9yZGluYWwgbnVtYmVyXG5cblxuICAgIGlmICh0b2tlbiA9PT0gJ1lvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIod2Vla1llYXIsIHtcbiAgICAgICAgdW5pdDogJ3llYXInXG4gICAgICB9KTtcbiAgICB9IC8vIFBhZGRpbmdcblxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh3ZWVrWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgUjogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIGlzb1dlZWtZZWFyID0gZ2V0VVRDSVNPV2Vla1llYXIoZGF0ZSk7IC8vIFBhZGRpbmdcblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvV2Vla1llYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEV4dGVuZGVkIHllYXIuIFRoaXMgaXMgYSBzaW5nbGUgbnVtYmVyIGRlc2lnbmF0aW5nIHRoZSB5ZWFyIG9mIHRoaXMgY2FsZW5kYXIgc3lzdGVtLlxuICAvLyBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgbG9jYWxpemVycyBhcmUgQi5DLiB5ZWFyczpcbiAgLy8gfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAgLy8gfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAgLy8gfCBBQyAxIHwgICAxIHwgICAxIHxcbiAgLy8gfCBCQyAxIHwgICAxIHwgICAwIHxcbiAgLy8gfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAgLy8gQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICAvLyB3aGlsZSBgdXVgIHBhZHMgc2luZ2xlIGRpZ2l0IHllYXJzIHRvIDIgY2hhcmFjdGVycyBhbmQgcmV0dXJucyBvdGhlciB5ZWFycyB1bmNoYW5nZWQuXG4gIHU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gUXVhcnRlclxuICBROiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMyk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKTtcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG5cbiAgICAgIGNhc2UgJ1FRJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICBjYXNlICdRbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICBjYXNlICdRUVEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgIGNhc2UgJ1FRUVFRJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICBjYXNlICdRUVFRJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIHF1YXJ0ZXJcbiAgcTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSAvIDMpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSAncSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuXG4gICAgICBjYXNlICdxcSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MocXVhcnRlciwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgY2FzZSAncW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7XG4gICAgICAgICAgdW5pdDogJ3F1YXJ0ZXInXG4gICAgICAgIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgY2FzZSAncXFxJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICBjYXNlICdxcXFxcSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cblxuICAgICAgY2FzZSAncXFxcSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBNb250aFxuICBNOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICBjYXNlICdNTSc6XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLk0oZGF0ZSwgdG9rZW4pO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuXG4gICAgICBjYXNlICdNbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoICsgMSwge1xuICAgICAgICAgIHVuaXQ6ICdtb250aCdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgIGNhc2UgJ01NTU1NJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG5cbiAgICAgIGNhc2UgJ01NTU0nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBtb250aFxuICBMOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgLi4uLCAxMlxuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIHJldHVybiBTdHJpbmcobW9udGggKyAxKTtcbiAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuXG4gICAgICBjYXNlICdMTCc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgY2FzZSAnTG8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHtcbiAgICAgICAgICB1bml0OiAnbW9udGgnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgIGNhc2UgJ0xMTCc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICBjYXNlICdMTExMTCc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICBjYXNlICdMTExMJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gTG9jYWwgd2VlayBvZiB5ZWFyXG4gIHc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2VlayA9IGdldFVUQ1dlZWsoZGF0ZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodG9rZW4gPT09ICd3bycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHdlZWssIHtcbiAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWssIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIElTTyB3ZWVrIG9mIHllYXJcbiAgSTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBpc29XZWVrID0gZ2V0VVRDSVNPV2VlayhkYXRlKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0lvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaXNvV2Vlaywge1xuICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnZG8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ0RhdGUoKSwge1xuICAgICAgICB1bml0OiAnZGF0ZSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLmQoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBEYXkgb2YgeWVhclxuICBEOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGRheU9mWWVhciA9IGdldFVUQ0RheU9mWWVhcihkYXRlKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0RvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF5T2ZZZWFyLCB7XG4gICAgICAgIHVuaXQ6ICdkYXlPZlllYXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRheU9mWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHdlZWtcbiAgRTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gVHVlXG4gICAgICBjYXNlICdFJzpcbiAgICAgIGNhc2UgJ0VFJzpcbiAgICAgIGNhc2UgJ0VFRSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdFRUVFRSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ0VFRUVFRSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdFRUVFJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBMb2NhbCBkYXkgb2Ygd2Vla1xuICBlOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgdmFyIGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKE50aCBkYXkgb2Ygd2VlayB3aXRoIGN1cnJlbnQgbG9jYWxlIG9yIHdlZWtTdGFydHNPbilcbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcblxuICAgICAgY2FzZSAnZWUnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuXG4gICAgICBjYXNlICdlbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7XG4gICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2VlZSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdlZWVlZSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ2VlZWVlZSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdlZWVlJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2Vla1xuICBjOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgdmFyIGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKHNhbWUgYXMgaW4gYGVgKVxuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIHJldHVybiBTdHJpbmcobG9jYWxEYXlPZldlZWspO1xuICAgICAgLy8gUGFkZGVkIG51bWVyaWNhbCB2YWx1ZVxuXG4gICAgICBjYXNlICdjYyc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobG9jYWxEYXlPZldlZWssIHRva2VuLmxlbmd0aCk7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcblxuICAgICAgY2FzZSAnY28nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihsb2NhbERheU9mV2Vlaywge1xuICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdjY2MnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnY2NjY2MnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdjY2NjY2MnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnY2NjYyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gSVNPIGRheSBvZiB3ZWVrXG4gIGk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgaXNvRGF5T2ZXZWVrID0gZGF5T2ZXZWVrID09PSAwID8gNyA6IGRheU9mV2VlaztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDJcbiAgICAgIGNhc2UgJ2knOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGlzb0RheU9mV2Vlayk7XG4gICAgICAvLyAwMlxuXG4gICAgICBjYXNlICdpaSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvRGF5T2ZXZWVrLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgLy8gMm5kXG5cbiAgICAgIGNhc2UgJ2lvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaXNvRGF5T2ZXZWVrLCB7XG4gICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVcblxuICAgICAgY2FzZSAnaWlpJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ2lpaWlpJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnaWlpaWlpJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ2lpaWknOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/ICdwbScgOiAnYW0nO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnYSc6XG4gICAgICBjYXNlICdhYSc6XG4gICAgICBjYXNlICdhYWEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYWFhYWEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2FhYWEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEFNLCBQTSwgbWlkbmlnaHQsIG5vb25cbiAgYjogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlO1xuXG4gICAgaWYgKGhvdXJzID09PSAxMikge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5ub29uO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPT09IDApIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubWlkbmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/ICdwbScgOiAnYW0nO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ2InOlxuICAgICAgY2FzZSAnYmInOlxuICAgICAgY2FzZSAnYmJiJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2JiYmJiJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdiYmJiJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBpbiB0aGUgbW9ybmluZywgaW4gdGhlIGFmdGVybm9vbiwgaW4gdGhlIGV2ZW5pbmcsIGF0IG5pZ2h0XG4gIEI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZTtcblxuICAgIGlmIChob3VycyA+PSAxNykge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5ldmVuaW5nO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPj0gMTIpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uYWZ0ZXJub29uO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPj0gNCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5tb3JuaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5pZ2h0O1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ0InOlxuICAgICAgY2FzZSAnQkInOlxuICAgICAgY2FzZSAnQkJCJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ0JCQkJCJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdCQkJCJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnaG8nKSB7XG4gICAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMjtcbiAgICAgIGlmIChob3VycyA9PT0gMCkgaG91cnMgPSAxMjtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMuaChkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdIbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDSG91cnMoKSwge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLkgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBIb3VyIFswLTExXVxuICBLOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpICUgMTI7XG5cbiAgICBpZiAodG9rZW4gPT09ICdLbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSG91ciBbMS0yNF1cbiAgazogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBpZiAoaG91cnMgPT09IDApIGhvdXJzID0gMjQ7XG5cbiAgICBpZiAodG9rZW4gPT09ICdrbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdtbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDTWludXRlcygpLCB7XG4gICAgICAgIHVuaXQ6ICdtaW51dGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycy5tKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gU2Vjb25kXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdzbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDU2Vjb25kcygpLCB7XG4gICAgICAgIHVuaXQ6ICdzZWNvbmQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycy5zKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBmb3JtYXR0ZXJzLlMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEuIElmIG9mZnNldCBpcyAwLCBvdXRwdXQgaXMgYWx3YXlzIGAnWidgKVxuICBYOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIGlmICh0aW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdaJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSAnWCc6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXModGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhgXG5cbiAgICAgIGNhc2UgJ1hYWFgnOlxuICAgICAgY2FzZSAnWFgnOlxuICAgICAgICAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYWGBcblxuICAgICAgY2FzZSAnWFhYWFgnOlxuICAgICAgY2FzZSAnWFhYJzogLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aCBgOmAgZGVsaW1pdGVyXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBgJyswMDowMCdgIG9yIGVxdWl2YWxlbnQpXG4gIHg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4YFxuXG4gICAgICBjYXNlICd4eHh4JzpcbiAgICAgIGNhc2UgJ3h4JzpcbiAgICAgICAgLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRoIGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGB4eHhgXG5cbiAgICAgIGNhc2UgJ3h4eHh4JzpcbiAgICAgIGNhc2UgJ3h4eCc6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoR01UKVxuICBPOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFNob3J0XG4gICAgICBjYXNlICdPJzpcbiAgICAgIGNhc2UgJ09PJzpcbiAgICAgIGNhc2UgJ09PTyc6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgICAvLyBMb25nXG5cbiAgICAgIGNhc2UgJ09PT08nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0aW9uKVxuICB6OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFNob3J0XG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ3p6JzpcbiAgICAgIGNhc2UgJ3p6eic6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgICAvLyBMb25nXG5cbiAgICAgIGNhc2UgJ3p6enonOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBTZWNvbmRzIHRpbWVzdGFtcFxuICB0OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXN0YW1wID0gTWF0aC5mbG9vcihvcmlnaW5hbERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0aW1lc3RhbXAsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAgVDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWVzdGFtcCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0aW1lc3RhbXAsIHRva2VuLmxlbmd0aCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lU2hvcnQob2Zmc2V0LCBkaXJ0eURlbGltaXRlcikge1xuICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKGFic09mZnNldCAvIDYwKTtcbiAgdmFyIG1pbnV0ZXMgPSBhYnNPZmZzZXQgJSA2MDtcblxuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKTtcbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBkaXJ0eURlbGltaXRlciB8fCAnJztcbiAgcmV0dXJuIHNpZ24gKyBTdHJpbmcoaG91cnMpICsgZGVsaW1pdGVyICsgYWRkTGVhZGluZ1plcm9zKG1pbnV0ZXMsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXMob2Zmc2V0LCBkaXJ0eURlbGltaXRlcikge1xuICBpZiAob2Zmc2V0ICUgNjAgPT09IDApIHtcbiAgICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gICAgcmV0dXJuIHNpZ24gKyBhZGRMZWFkaW5nWmVyb3MoTWF0aC5hYnMob2Zmc2V0KSAvIDYwLCAyKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkaXJ0eURlbGltaXRlcikge1xuICB2YXIgZGVsaW1pdGVyID0gZGlydHlEZWxpbWl0ZXIgfHwgJyc7XG4gIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIHZhciBob3VycyA9IGFkZExlYWRpbmdaZXJvcyhNYXRoLmZsb29yKGFic09mZnNldCAvIDYwKSwgMik7XG4gIHZhciBtaW51dGVzID0gYWRkTGVhZGluZ1plcm9zKGFic09mZnNldCAlIDYwLCAyKTtcbiAgcmV0dXJuIHNpZ24gKyBob3VycyArIGRlbGltaXRlciArIG1pbnV0ZXM7XG59XG5cbmZ1bmN0aW9uIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpIHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSAnUCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdzaG9ydCdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUFAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnbWVkaXVtJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdQUFAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnbG9uZydcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUFBQUCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ2Z1bGwnXG4gICAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aW1lTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKSB7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgJ3AnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnc2hvcnQnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ3BwJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ21lZGl1bSdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAncHBwJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ2xvbmcnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ3BwcHAnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdmdWxsJ1xuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZVRpbWVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpIHtcbiAgdmFyIG1hdGNoUmVzdWx0ID0gcGF0dGVybi5tYXRjaCgvKFArKShwKyk/Lyk7XG4gIHZhciBkYXRlUGF0dGVybiA9IG1hdGNoUmVzdWx0WzFdO1xuICB2YXIgdGltZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsyXTtcblxuICBpZiAoIXRpbWVQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpO1xuICB9XG5cbiAgdmFyIGRhdGVUaW1lRm9ybWF0O1xuXG4gIHN3aXRjaCAoZGF0ZVBhdHRlcm4pIHtcbiAgICBjYXNlICdQJzpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnc2hvcnQnXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUFAnOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdtZWRpdW0nXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUFBQJzpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnbG9uZydcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQUFBQJzpcbiAgICBkZWZhdWx0OlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdmdWxsJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBkYXRlVGltZUZvcm1hdC5yZXBsYWNlKCd7e2RhdGV9fScsIGRhdGVMb25nRm9ybWF0dGVyKGRhdGVQYXR0ZXJuLCBmb3JtYXRMb25nKSkucmVwbGFjZSgne3t0aW1lfX0nLCB0aW1lTG9uZ0Zvcm1hdHRlcih0aW1lUGF0dGVybiwgZm9ybWF0TG9uZykpO1xufVxuXG52YXIgbG9uZ0Zvcm1hdHRlcnMgPSB7XG4gIHA6IHRpbWVMb25nRm9ybWF0dGVyLFxuICBQOiBkYXRlVGltZUxvbmdGb3JtYXR0ZXJcbn07XG5cbnZhciBwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMgPSBbJ0QnLCAnREQnXTtcbnZhciBwcm90ZWN0ZWRXZWVrWWVhclRva2VucyA9IFsnWVknLCAnWVlZWSddO1xuZnVuY3Rpb24gaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbih0b2tlbikge1xuICByZXR1cm4gcHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW5zLmluZGV4T2YodG9rZW4pICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbih0b2tlbikge1xuICByZXR1cm4gcHJvdGVjdGVkV2Vla1llYXJUb2tlbnMuaW5kZXhPZih0b2tlbikgIT09IC0xO1xufVxuZnVuY3Rpb24gdGhyb3dQcm90ZWN0ZWRFcnJvcih0b2tlbikge1xuICBpZiAodG9rZW4gPT09ICdZWVlZJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdVc2UgYHl5eXlgIGluc3RlYWQgb2YgYFlZWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyJyk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdZWScpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyJyk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdEJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdVc2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyJyk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdERCcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVXNlIGBkZGAgaW5zdGVhZCBvZiBgRERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyJyk7XG4gIH1cbn1cblxuLy8gLSBbeVlRcU1Md0lkRGVjaWhIS2ttc11vIG1hdGNoZXMgYW55IGF2YWlsYWJsZSBvcmRpbmFsIG51bWJlciB0b2tlblxuLy8gICAob25lIG9mIHRoZSBjZXJ0YWluIGxldHRlcnMgZm9sbG93ZWQgYnkgYG9gKVxuLy8gLSAoXFx3KVxcMSogbWF0Y2hlcyBhbnkgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIGxldHRlclxuLy8gLSAnJyBtYXRjaGVzIHR3byBxdW90ZSBjaGFyYWN0ZXJzIGluIGEgcm93XG4vLyAtICcoJyd8W14nXSkrKCd8JCkgbWF0Y2hlcyBhbnl0aGluZyBzdXJyb3VuZGVkIGJ5IHR3byBxdW90ZSBjaGFyYWN0ZXJzICgnKSxcbi8vICAgZXhjZXB0IGEgc2luZ2xlIHF1b3RlIHN5bWJvbCwgd2hpY2ggZW5kcyB0aGUgc2VxdWVuY2UuXG4vLyAgIFR3byBxdW90ZSBjaGFyYWN0ZXJzIGRvIG5vdCBlbmQgdGhlIHNlcXVlbmNlLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBzaW5nbGUgcXVvdGVcbi8vICAgdGhlbiB0aGUgc2VxdWVuY2Ugd2lsbCBjb250aW51ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4vLyAtIC4gbWF0Y2hlcyBhbnkgc2luZ2xlIGNoYXJhY3RlciB1bm1hdGNoZWQgYnkgcHJldmlvdXMgcGFydHMgb2YgdGhlIFJlZ0V4cHNcblxudmFyIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFx3KVxcMSp8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7IC8vIFRoaXMgUmVnRXhwIGNhdGNoZXMgc3ltYm9scyBlc2NhcGVkIGJ5IHF1b3RlcywgYW5kIGFsc29cbi8vIHNlcXVlbmNlcyBvZiBzeW1ib2xzIFAsIHAsIGFuZCB0aGUgY29tYmluYXRpb25zIGxpa2UgYFBQUFBQUFBwcHBwcGBcblxudmFyIGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gL1ArcCt8UCt8cCt8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XG52YXIgZXNjYXBlZFN0cmluZ1JlZ0V4cCA9IC9eJyguKj8pJz8kLztcbnZhciBkb3VibGVRdW90ZVJlZ0V4cCA9IC8nJy9nO1xudmFyIHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwID0gL1thLXpBLVpdLztcbi8qKlxuICogQG5hbWUgZm9ybWF0XG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGluIHRoZSBnaXZlbiBmb3JtYXQuIFRoZSByZXN1bHQgbWF5IHZhcnkgYnkgbG9jYWxlLlxuICpcbiAqID4g4pqg77iPIFBsZWFzZSBub3RlIHRoYXQgdGhlIGBmb3JtYXRgIHRva2VucyBkaWZmZXIgZnJvbSBNb21lbnQuanMgYW5kIG90aGVyIGxpYnJhcmllcy5cbiAqID4gU2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICpcbiAqIFRoZSBjaGFyYWN0ZXJzIHdyYXBwZWQgYmV0d2VlbiB0d28gc2luZ2xlIHF1b3RlcyBjaGFyYWN0ZXJzICgnKSBhcmUgZXNjYXBlZC5cbiAqIFR3byBzaW5nbGUgcXVvdGVzIGluIGEgcm93LCB3aGV0aGVyIGluc2lkZSBvciBvdXRzaWRlIGEgcXVvdGVkIHNlcXVlbmNlLCByZXByZXNlbnQgYSAncmVhbCcgc2luZ2xlIHF1b3RlLlxuICogKHNlZSB0aGUgbGFzdCBleGFtcGxlKVxuICpcbiAqIEZvcm1hdCBvZiB0aGUgc3RyaW5nIGlzIGJhc2VkIG9uIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIHdpdGggYSBmZXcgYWRkaXRpb25zIChzZWUgbm90ZSA3IGJlbG93IHRoZSB0YWJsZSkuXG4gKlxuICogQWNjZXB0ZWQgcGF0dGVybnM6XG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQYXR0ZXJuIHwgUmVzdWx0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHwgTm90ZXMgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLXxcbiAqIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEcuLkdHRyAgfCBBRCwgQkMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHICAgIHwgQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3QgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHR0cgICB8IEEsIEIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQ2FsZW5kYXIgeWVhciAgICAgICAgICAgICAgICAgICB8IHkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5byAgICAgIHwgNDR0aCwgMXN0LCAwdGgsIDE3dGggICAgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXkgICAgICB8IDQ0LCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eSAgICAgfCAwNDQsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXl5ICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eXkgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSAgIHxcbiAqIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICB8IFkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZbyAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDIwMTd0aCAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVkgICAgICB8IDQ0LCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWSAgICAgfCAwNDQsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWVkgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgICB8IFIgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUiAgICAgIHwgLTQzLCAwMCwgMDEsIDE5MDAsIDIwMTcgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSICAgICB8IC0wNDMsIDAwMCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUlIgICAgfCAtMDA0MywgMDAwMCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlJSUiAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1LDcgfFxuICogfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgIHwgdSAgICAgICB8IC00MywgMCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1ICAgICAgfCAtNDMsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXUgICAgIHwgLTA0MywgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1dSAgICB8IC0wMDQzLCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXV1ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IFF1YXJ0ZXIgKGZvcm1hdHRpbmcpICAgICAgICAgICAgfCBRICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUW8gICAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRUSAgICB8IDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVFRICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8IFF1YXJ0ZXIgKHN0YW5kLWFsb25lKSAgICAgICAgICAgfCBxICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcW8gICAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxcSAgICB8IDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXFxICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8IE1vbnRoIChmb3JtYXR0aW5nKSAgICAgICAgICAgICAgfCBNICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU0gICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NTSAgICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU1NICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1vbnRoIChzdGFuZC1hbG9uZSkgICAgICAgICAgICAgfCBMICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTEwgICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMTCAgICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTExMICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgfCB3ICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgd28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDUzdGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHd3ICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICAgfCBJICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDUzdGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElJICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICAgfCBkICAgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDMxc3QgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRkICAgICAgfCAwMSwgMDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICAgfCBEICAgICAgIHwgMSwgMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICAgIHwgOSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDM2NXRoLCAzNjZ0aCAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREICAgICAgfCAwMSwgMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgfCA5ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREQgICAgIHwgMDAxLCAwMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRERERCAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgICAgICB8IEUuLkVFRSAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRUUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFRSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XG4gKiB8IElTTyBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgfCBpICAgICAgIHwgMSwgMiwgMywgLi4uLCA3ICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDd0aCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpICAgICAgfCAwMSwgMDIsIC4uLiwgMDcgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWkgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWlpICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpaWkgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgNyAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgIHwgZSAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZSAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlZSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWVlICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKHN0YW5kLWFsb25lKSB8IGMgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2MgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjYyAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjY2MgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjYyAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhLi5hYWEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgfCBiLi5iYmIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtLICAgICAgfCAxLCAyLCAuLi4sIDExLCAwICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgICB8IE8uLi5PT08gfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBPT09PICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgIHwgei4uLnp6eiB8IEdNVC04LCBHTVQrNTozMCwgR01UKzAgICAgICAgICAgICB8IDYgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHp6enogICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyLDYgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgUCAgICAgICB8IDA1LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQICAgICAgfCBNYXkgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFAgICAgIHwgTWF5IDI5dGgsIDE0NTMgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUCAgICB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgICAgICAgICAgICB8IDIsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHBwICAgICB8IDEyOjAwOjAwIEFNIEdNVCsyICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcHAgICAgfCAxMjowMDowMCBBTSBHTVQrMDI6MDAgICAgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCBQcCAgICAgIHwgMDUvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBwcCAgICB8IE1heSAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUHBwcCAgfCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQcHBwcHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgIHwgMiw3ICAgfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhcjpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlIChlLmcuIGBFRUVFRUVFRUVFRWApXG4gKiAgICB0aGUgb3V0cHV0IHdpbGwgYmUgdGhlIHNhbWUgYXMgZGVmYXVsdCBwYXR0ZXJuIGZvciB0aGlzIHVuaXQsIHVzdWFsbHlcbiAqICAgIHRoZSBsb25nZXN0IG9uZSAoaW4gY2FzZSBvZiBJU08gd2Vla2RheXMsIGBFRUVFYCkuIERlZmF1bHQgcGF0dGVybnMgZm9yIHVuaXRzXG4gKiAgICBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTScpIC8vPT4gJ05vdidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU0nKSAvLz0+ICdOJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogMy4gU29tZSBwYXR0ZXJucyBjb3VsZCBiZSB1bmxpbWl0ZWQgbGVuZ3RoIChzdWNoIGFzIGB5eXl5eXl5eWApLlxuICogICAgVGhlIG91dHB1dCB3aWxsIGJlIHBhZGRlZCB3aXRoIHplcm9zIHRvIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICd5eXl5eXl5eScpIC8vPT4gJzAwMDAyMDE3J2BcbiAqXG4gKiA0LiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA1LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICogICAgd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkOlxuICpcbiAqICAgIHwgWWVhciB8IGB5eWAgfCBgdXVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS0tfC0tLS0tLXxcbiAqICAgIHwgMSAgICB8ICAgMDEgfCAgIDAxIHxcbiAqICAgIHwgMTQgICB8ICAgMTQgfCAgIDE0IHxcbiAqICAgIHwgMzc2ICB8ICAgNzYgfCAgMzc2IHxcbiAqICAgIHwgMTQ1MyB8ICAgNTMgfCAxNDUzIHxcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtnZXRJU09XZWVrWWVhcl17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9nZXRJU09XZWVrWWVhcn1cbiAqICAgIGFuZCBbZ2V0V2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0V2Vla1llYXJ9KS5cbiAqXG4gKiA2LiBTcGVjaWZpYyBub24tbG9jYXRpb24gdGltZXpvbmVzIGFyZSBjdXJyZW50bHkgdW5hdmFpbGFibGUgaW4gYGRhdGUtZm5zYCxcbiAqICAgIHNvIHJpZ2h0IG5vdyB0aGVzZSB0b2tlbnMgZmFsbCBiYWNrIHRvIEdNVCB0aW1lem9uZXMuXG4gKlxuICogNy4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgdGA6IHNlY29uZHMgdGltZXN0YW1wXG4gKiAgICAtIGBUYDogbWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA4LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiA5LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRoZW4gY29uZnVzZWQgd2l0aCBkYXlzIG9mIHRoZSBtb250aC5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgbm93IHJlcXVpcmVkIGZvciB0aGUgc2FrZSBvZiBleHBsaWNpdG5lc3MuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgZm9ybWF0KG5ldyBEYXRlKDIwMTYsIDAsIDEpKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICogICBmb3JtYXQobmV3IERhdGUoMjAxNiwgMCwgMSksIFwieXl5eS1NTS1kZCdUJ0hIOm1tOnNzLlNTU3h4eFwiKVxuICogICBgYGBcbiAqXG4gKiAtIE5ldyBmb3JtYXQgc3RyaW5nIEFQSSBmb3IgYGZvcm1hdGAgZnVuY3Rpb25cbiAqICAgd2hpY2ggaXMgYmFzZWQgb24gW1VuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNV0oaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0ZpZWxkX1N5bWJvbF9UYWJsZSkuXG4gKiAgIFNlZSBbdGhpcyBwb3N0XShodHRwczovL2Jsb2cuZGF0ZS1mbnMub3JnL3Bvc3QvdW5pY29kZS10b2tlbnMtaW4tZGF0ZS1mbnMtdjItc3JlYXR5a2k5MWpnKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIC0gQ2hhcmFjdGVycyBhcmUgbm93IGVzY2FwZWQgdXNpbmcgc2luZ2xlIHF1b3RlIHN5bWJvbHMgKGAnYCkgaW5zdGVhZCBvZiBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gKiBAcGFyYW0gezB8MXwyfDN8NHw1fDZ9IFtvcHRpb25zLndlZWtTdGFydHNPbj0wXSAtIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwIC0gU3VuZGF5KVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZT0xXSAtIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiB0aGUgd2Vlay1udW1iZXJpbmcgeWVhciB0b2tlbnMgYFlZYCBhbmQgYFlZWVlgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSBkYXkgb2YgeWVhciB0b2tlbnMgYERgIGFuZCBgRERgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbG9jYWxpemVgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLndlZWtTdGFydHNPbmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDZcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDdcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnM7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgeXlgIGluc3RlYWQgb2YgYFlZYCBmb3IgZm9ybWF0dGluZyB5ZWFyczsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGBkZGAgaW5zdGVhZCBvZiBgRERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBmb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDExIEZlYnJ1YXJ5IDIwMTQgaW4gbWlkZGxlLWVuZGlhbiBmb3JtYXQ6XG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDEsIDExKSwgJ01NL2RkL3l5eXknKVxuICogLy89PiAnMDIvMTEvMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDIgSnVseSAyMDE0IGluIEVzcGVyYW50bzpcbiAqIGltcG9ydCB7IGVvTG9jYWxlIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogdmFyIHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgXCJkbyAnZGUnIE1NTU0geXl5eVwiLCB7XG4gKiAgIGxvY2FsZTogZW9Mb2NhbGVcbiAqIH0pXG4gKiAvLz0+ICcyLWEgZGUganVsaW8gMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXNjYXBlIHN0cmluZyBieSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyczpcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQobmV3IERhdGUoMjAxNCwgNiwgMiwgMTUpLCBcImggJ28nJ2Nsb2NrJ1wiKVxuICogLy89PiBcIjMgbydjbG9ja1wiXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0KGRpcnR5RGF0ZSwgZGlydHlGb3JtYXRTdHIsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBmb3JtYXRTdHIgPSBTdHJpbmcoZGlydHlGb3JtYXRTdHIpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSQxID0gb3B0aW9ucy5sb2NhbGUgfHwgbG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlJDEub3B0aW9ucyAmJiBsb2NhbGUkMS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIkMShsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIkMShvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMSBhbmQgNyBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEoZmlyc3RXZWVrQ29udGFpbnNEYXRlID49IDEgJiYgZmlyc3RXZWVrQ29udGFpbnNEYXRlIDw9IDcpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZpcnN0V2Vla0NvbnRhaW5zRGF0ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNyBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGxvY2FsZVdlZWtTdGFydHNPbiA9IGxvY2FsZSQxLm9wdGlvbnMgJiYgbG9jYWxlJDEub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyJDEobG9jYWxlV2Vla1N0YXJ0c09uKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyJDEob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIGlmICghbG9jYWxlJDEubG9jYWxpemUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBsb2NhbGl6ZSBwcm9wZXJ0eScpO1xuICB9XG5cbiAgaWYgKCFsb2NhbGUkMS5mb3JtYXRMb25nKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gZm9ybWF0TG9uZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsRGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuXG4gIGlmICghaXNWYWxpZChvcmlnaW5hbERhdGUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB9IC8vIENvbnZlcnQgdGhlIGRhdGUgaW4gc3lzdGVtIHRpbWV6b25lIHRvIHRoZSBzYW1lIGRhdGUgaW4gVVRDKzAwOjAwIHRpbWV6b25lLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxuICAvLyBTZWUgYW4gaXNzdWUgYWJvdXQgVVRDIGZ1bmN0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuXG4gIHZhciB0aW1lem9uZU9mZnNldCA9IGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMob3JpZ2luYWxEYXRlKTtcbiAgdmFyIHV0Y0RhdGUgPSBzdWJNaWxsaXNlY29uZHMob3JpZ2luYWxEYXRlLCB0aW1lem9uZU9mZnNldCk7XG4gIHZhciBmb3JtYXR0ZXJPcHRpb25zID0ge1xuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogZmlyc3RXZWVrQ29udGFpbnNEYXRlLFxuICAgIHdlZWtTdGFydHNPbjogd2Vla1N0YXJ0c09uLFxuICAgIGxvY2FsZTogbG9jYWxlJDEsXG4gICAgX29yaWdpbmFsRGF0ZTogb3JpZ2luYWxEYXRlXG4gIH07XG4gIHZhciByZXN1bHQgPSBmb3JtYXRTdHIubWF0Y2gobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHApLm1hcChmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gc3Vic3RyaW5nWzBdO1xuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSAncCcgfHwgZmlyc3RDaGFyYWN0ZXIgPT09ICdQJykge1xuICAgICAgdmFyIGxvbmdGb3JtYXR0ZXIgPSBsb25nRm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG4gICAgICByZXR1cm4gbG9uZ0Zvcm1hdHRlcihzdWJzdHJpbmcsIGxvY2FsZSQxLmZvcm1hdExvbmcsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzdHJpbmc7XG4gIH0pLmpvaW4oJycpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHApLm1hcChmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgLy8gUmVwbGFjZSB0d28gc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlclxuICAgIGlmIChzdWJzdHJpbmcgPT09IFwiJydcIikge1xuICAgICAgcmV0dXJuIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcblxuICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVycyQxW2ZpcnN0Q2hhcmFjdGVyXTtcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHN1YnN0cmluZykpIHtcbiAgICAgICAgdGhyb3dQcm90ZWN0ZWRFcnJvcihzdWJzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2VucyAmJiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHN1YnN0cmluZykpIHtcbiAgICAgICAgdGhyb3dQcm90ZWN0ZWRFcnJvcihzdWJzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHV0Y0RhdGUsIHN1YnN0cmluZywgbG9jYWxlJDEubG9jYWxpemUsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChmaXJzdENoYXJhY3Rlci5tYXRjaCh1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdGb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXIgYCcgKyBmaXJzdENoYXJhY3RlciArICdgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnN0cmluZztcbiAgfSkuam9pbignJyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cClbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ24kMSh0YXJnZXQsIGRpcnR5T2JqZWN0KSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Fzc2lnbiByZXF1aXJlcyB0aGF0IGlucHV0IHBhcmFtZXRlciBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGRpcnR5T2JqZWN0ID0gZGlydHlPYmplY3QgfHwge307XG5cbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gZGlydHlPYmplY3QpIHtcbiAgICBpZiAoZGlydHlPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICB0YXJnZXRbcHJvcGVydHldID0gZGlydHlPYmplY3RbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQG5hbWUgaXNBZnRlclxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBmaXJzdCBkYXRlIGFmdGVyIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGFmdGVyIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVUb0NvbXBhcmUgLSB0aGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBhZnRlciB0aGUgc2Vjb25kIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMTAgSnVseSAxOTg5IGFmdGVyIDExIEZlYnJ1YXJ5IDE5ODc/XG4gKiB2YXIgcmVzdWx0ID0gaXNBZnRlcihuZXcgRGF0ZSgxOTg5LCA2LCAxMCksIG5ldyBEYXRlKDE5ODcsIDEsIDExKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5cbmZ1bmN0aW9uIGlzQWZ0ZXIoZGlydHlEYXRlLCBkaXJ0eURhdGVUb0NvbXBhcmUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUpO1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPiBkYXRlVG9Db21wYXJlLmdldFRpbWUoKTtcbn1cblxuLyoqXG4gKiBAbmFtZSBpc0JlZm9yZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZmlyc3QgZGF0ZSBiZWZvcmUgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZmlyc3QgZGF0ZSBiZWZvcmUgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVUb0NvbXBhcmUgLSB0aGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBiZWZvcmUgdGhlIHNlY29uZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEwIEp1bHkgMTk4OSBiZWZvcmUgMTEgRmVicnVhcnkgMTk4Nz9cbiAqIHZhciByZXN1bHQgPSBpc0JlZm9yZShuZXcgRGF0ZSgxOTg5LCA2LCAxMCksIG5ldyBEYXRlKDE5ODcsIDEsIDExKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc0JlZm9yZShkaXJ0eURhdGUsIGRpcnR5RGF0ZVRvQ29tcGFyZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXRlVG9Db21wYXJlID0gdG9EYXRlKGRpcnR5RGF0ZVRvQ29tcGFyZSk7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSA8IGRhdGVUb0NvbXBhcmUuZ2V0VGltZSgpO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHNldFVUQ0RheShkaXJ0eURhdGUsIGRpcnR5RGF5LCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLndlZWtTdGFydHNPbjtcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIkMShsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIkMShvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRheSA9IHRvSW50ZWdlciQxKGRpcnR5RGF5KTtcbiAgdmFyIGN1cnJlbnREYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcbiAgdmFyIGRheUluZGV4ID0gKHJlbWFpbmRlciArIDcpICUgNztcbiAgdmFyIGRpZmYgPSAoZGF5SW5kZXggPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSBjdXJyZW50RGF5O1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZnVuY3Rpb24gc2V0VVRDSVNPRGF5KGRpcnR5RGF0ZSwgZGlydHlEYXkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF5ID0gdG9JbnRlZ2VyJDEoZGlydHlEYXkpO1xuXG4gIGlmIChkYXkgJSA3ID09PSAwKSB7XG4gICAgZGF5ID0gZGF5IC0gNztcbiAgfVxuXG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciByZW1haW5kZXIgPSBkYXkgJSA3O1xuICB2YXIgZGF5SW5kZXggPSAocmVtYWluZGVyICsgNykgJSA3O1xuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5mdW5jdGlvbiBzZXRVVENJU09XZWVrKGRpcnR5RGF0ZSwgZGlydHlJU09XZWVrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGlzb1dlZWsgPSB0b0ludGVnZXIkMShkaXJ0eUlTT1dlZWspO1xuICB2YXIgZGlmZiA9IGdldFVUQ0lTT1dlZWsoZGF0ZSkgLSBpc29XZWVrO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmICogNyk7XG4gIHJldHVybiBkYXRlO1xufVxuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmZ1bmN0aW9uIHNldFVUQ1dlZWsoZGlydHlEYXRlLCBkaXJ0eVdlZWssIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgd2VlayA9IHRvSW50ZWdlciQxKGRpcnR5V2Vlayk7XG4gIHZhciBkaWZmID0gZ2V0VVRDV2VlayhkYXRlLCBvcHRpb25zKSAtIHdlZWs7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYgKiA3KTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fSE9VUiA9IDM2MDAwMDA7XG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSQxID0gNjAwMDA7XG52YXIgTUlMTElTRUNPTkRTX0lOX1NFQ09ORCA9IDEwMDA7XG52YXIgbnVtZXJpY1BhdHRlcm5zID0ge1xuICBtb250aDogL14oMVswLTJdfDA/XFxkKS8sXG4gIC8vIDAgdG8gMTJcbiAgZGF0ZTogL14oM1swLTFdfFswLTJdP1xcZCkvLFxuICAvLyAwIHRvIDMxXG4gIGRheU9mWWVhcjogL14oMzZbMC02XXwzWzAtNV1cXGR8WzAtMl0/XFxkP1xcZCkvLFxuICAvLyAwIHRvIDM2NlxuICB3ZWVrOiAvXig1WzAtM118WzAtNF0/XFxkKS8sXG4gIC8vIDAgdG8gNTNcbiAgaG91cjIzaDogL14oMlswLTNdfFswLTFdP1xcZCkvLFxuICAvLyAwIHRvIDIzXG4gIGhvdXIyNGg6IC9eKDJbMC00XXxbMC0xXT9cXGQpLyxcbiAgLy8gMCB0byAyNFxuICBob3VyMTFoOiAvXigxWzAtMV18MD9cXGQpLyxcbiAgLy8gMCB0byAxMVxuICBob3VyMTJoOiAvXigxWzAtMl18MD9cXGQpLyxcbiAgLy8gMCB0byAxMlxuICBtaW51dGU6IC9eWzAtNV0/XFxkLyxcbiAgLy8gMCB0byA1OVxuICBzZWNvbmQ6IC9eWzAtNV0/XFxkLyxcbiAgLy8gMCB0byA1OVxuICBzaW5nbGVEaWdpdDogL15cXGQvLFxuICAvLyAwIHRvIDlcbiAgdHdvRGlnaXRzOiAvXlxcZHsxLDJ9LyxcbiAgLy8gMCB0byA5OVxuICB0aHJlZURpZ2l0czogL15cXGR7MSwzfS8sXG4gIC8vIDAgdG8gOTk5XG4gIGZvdXJEaWdpdHM6IC9eXFxkezEsNH0vLFxuICAvLyAwIHRvIDk5OTlcbiAgYW55RGlnaXRzU2lnbmVkOiAvXi0/XFxkKy8sXG4gIHNpbmdsZURpZ2l0U2lnbmVkOiAvXi0/XFxkLyxcbiAgLy8gMCB0byA5LCAtMCB0byAtOVxuICB0d29EaWdpdHNTaWduZWQ6IC9eLT9cXGR7MSwyfS8sXG4gIC8vIDAgdG8gOTksIC0wIHRvIC05OVxuICB0aHJlZURpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDN9LyxcbiAgLy8gMCB0byA5OTksIC0wIHRvIC05OTlcbiAgZm91ckRpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDR9LyAvLyAwIHRvIDk5OTksIC0wIHRvIC05OTk5XG5cbn07XG52YXIgdGltZXpvbmVQYXR0ZXJucyA9IHtcbiAgYmFzaWNPcHRpb25hbE1pbnV0ZXM6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KT98Wi8sXG4gIGJhc2ljOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSl8Wi8sXG4gIGJhc2ljT3B0aW9uYWxTZWNvbmRzOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSkoKFxcZHsyfSkpP3xaLyxcbiAgZXh0ZW5kZWQ6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSl8Wi8sXG4gIGV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzOiAvXihbKy1dKShcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KSk/fFovXG59O1xuXG5mdW5jdGlvbiBwYXJzZU51bWVyaWNQYXR0ZXJuKHBhdHRlcm4sIHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xuICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gocGF0dGVybik7XG5cbiAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMF0sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWVDYWxsYmFjayA/IHZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWUsXG4gICAgcmVzdDogc3RyaW5nLnNsaWNlKG1hdGNoUmVzdWx0WzBdLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZVBhdHRlcm4ocGF0dGVybiwgc3RyaW5nKSB7XG4gIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChwYXR0ZXJuKTtcblxuICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSW5wdXQgaXMgJ1onXG5cblxuICBpZiAobWF0Y2hSZXN1bHRbMF0gPT09ICdaJykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogMCxcbiAgICAgIHJlc3Q6IHN0cmluZy5zbGljZSgxKVxuICAgIH07XG4gIH1cblxuICB2YXIgc2lnbiA9IG1hdGNoUmVzdWx0WzFdID09PSAnKycgPyAxIDogLTE7XG4gIHZhciBob3VycyA9IG1hdGNoUmVzdWx0WzJdID8gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMl0sIDEwKSA6IDA7XG4gIHZhciBtaW51dGVzID0gbWF0Y2hSZXN1bHRbM10gPyBwYXJzZUludChtYXRjaFJlc3VsdFszXSwgMTApIDogMDtcbiAgdmFyIHNlY29uZHMgPSBtYXRjaFJlc3VsdFs1XSA/IHBhcnNlSW50KG1hdGNoUmVzdWx0WzVdLCAxMCkgOiAwO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBzaWduICogKGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQxICsgc2Vjb25kcyAqIE1JTExJU0VDT05EU19JTl9TRUNPTkQpLFxuICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaFJlc3VsdFswXS5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQW55RGlnaXRzU2lnbmVkKHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xuICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuYW55RGlnaXRzU2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5EaWdpdHMobiwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKSB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5zaW5nbGVEaWdpdCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50d29EaWdpdHMsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudGhyZWVEaWdpdHMsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuZm91ckRpZ2l0cywgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihuZXcgUmVnRXhwKCdeXFxcXGR7MSwnICsgbiArICd9JyksIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VORGlnaXRzU2lnbmVkKG4sIHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuc2luZ2xlRGlnaXRTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudHdvRGlnaXRzU2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnRocmVlRGlnaXRzU2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmZvdXJEaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obmV3IFJlZ0V4cCgnXi0/XFxcXGR7MSwnICsgbiArICd9JyksIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF5UGVyaW9kRW51bVRvSG91cnMoZW51bVZhbHVlKSB7XG4gIHN3aXRjaCAoZW51bVZhbHVlKSB7XG4gICAgY2FzZSAnbW9ybmluZyc6XG4gICAgICByZXR1cm4gNDtcblxuICAgIGNhc2UgJ2V2ZW5pbmcnOlxuICAgICAgcmV0dXJuIDE3O1xuXG4gICAgY2FzZSAncG0nOlxuICAgIGNhc2UgJ25vb24nOlxuICAgIGNhc2UgJ2FmdGVybm9vbic6XG4gICAgICByZXR1cm4gMTI7XG5cbiAgICBjYXNlICdhbSc6XG4gICAgY2FzZSAnbWlkbmlnaHQnOlxuICAgIGNhc2UgJ25pZ2h0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHdvRGlnaXRZZWFyKHR3b0RpZ2l0WWVhciwgY3VycmVudFllYXIpIHtcbiAgdmFyIGlzQ29tbW9uRXJhID0gY3VycmVudFllYXIgPiAwOyAvLyBBYnNvbHV0ZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgeWVhcjpcbiAgLy8gMSAtPiAxIEFDXG4gIC8vIDAgLT4gMSBCQ1xuICAvLyAtMSAtPiAyIEJDXG5cbiAgdmFyIGFic0N1cnJlbnRZZWFyID0gaXNDb21tb25FcmEgPyBjdXJyZW50WWVhciA6IDEgLSBjdXJyZW50WWVhcjtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoYWJzQ3VycmVudFllYXIgPD0gNTApIHtcbiAgICByZXN1bHQgPSB0d29EaWdpdFllYXIgfHwgMTAwO1xuICB9IGVsc2Uge1xuICAgIHZhciByYW5nZUVuZCA9IGFic0N1cnJlbnRZZWFyICsgNTA7XG4gICAgdmFyIHJhbmdlRW5kQ2VudHVyeSA9IE1hdGguZmxvb3IocmFuZ2VFbmQgLyAxMDApICogMTAwO1xuICAgIHZhciBpc1ByZXZpb3VzQ2VudHVyeSA9IHR3b0RpZ2l0WWVhciA+PSByYW5nZUVuZCAlIDEwMDtcbiAgICByZXN1bHQgPSB0d29EaWdpdFllYXIgKyByYW5nZUVuZENlbnR1cnkgLSAoaXNQcmV2aW91c0NlbnR1cnkgPyAxMDAgOiAwKTtcbiAgfVxuXG4gIHJldHVybiBpc0NvbW1vbkVyYSA/IHJlc3VsdCA6IDEgLSByZXN1bHQ7XG59XG5cbnZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xudmFyIERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdOyAvLyBVc2VyIGZvciB2YWxpZGF0aW9uXG5cbmZ1bmN0aW9uIGlzTGVhcFllYXJJbmRleCh5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNDAwID09PSAwIHx8IHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDA7XG59XG4vKlxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCBNaWxsaXNlY29uZHMgaW4gZGF5ICAgICAgICAgICAgfFxuICogfCAgYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgfCAgQiAgfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgfFxuICogfCAgYyAgfCBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2VlayAgfCAgQyogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfFxuICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZSAgfCBMb2NhbCBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgfCAgRSAgfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgRiogfCBEYXkgb2Ygd2VlayBpbiBtb250aCAgICAgICAgICAgfFxuICogfCAgZyogfCBNb2RpZmllZCBKdWxpYW4gZGF5ICAgICAgICAgICAgfCAgRyAgfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaSEgfCBJU08gZGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgfCAgSSEgfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgfFxuICogfCAgaiogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfCAgSiogfCBMb2NhbGl6ZWQgaG91ciB3L28gZGF5IHBlcmlvZCAgfFxuICogfCAgayAgfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgfCAgSyAgfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbCogfCAoZGVwcmVjYXRlZCkgICAgICAgICAgICAgICAgICAgfCAgTCAgfCBTdGFuZC1hbG9uZSBtb250aCAgICAgICAgICAgICAgfFxuICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbyEgfCBPcmRpbmFsIG51bWJlciBtb2RpZmllciAgICAgICAgfCAgTyogfCBUaW1lem9uZSAoR01UKSAgICAgICAgICAgICAgICAgfFxuICogfCAgcCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgcSAgfCBTdGFuZC1hbG9uZSBxdWFydGVyICAgICAgICAgICAgfCAgUSAgfCBRdWFydGVyICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgciogfCBSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyICAgICAgICAgfCAgUiEgfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgfFxuICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICogfCAgdCEgfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgfCAgVCEgfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgfFxuICogfCAgdSAgfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgfCAgVSogfCBDeWNsaWMgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgdiogfCBUaW1lem9uZSAoZ2VuZXJpYyBub24tbG9jYXQuKSAgfCAgViogfCBUaW1lem9uZSAobG9jYXRpb24pICAgICAgICAgICAgfFxuICogfCAgdyAgfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgfCAgVyogfCBXZWVrIG9mIG1vbnRoICAgICAgICAgICAgICAgICAgfFxuICogfCAgeCAgfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgfCAgWCAgfCBUaW1lem9uZSAoSVNPLTg2MDEpICAgICAgICAgICAgfFxuICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgfFxuICogfCAgeiogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgfCAgWiogfCBUaW1lem9uZSAoYWxpYXNlcykgICAgICAgICAgICAgfFxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAhIGFyZSBub24tc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBkYXRlLWZuczpcbiAqIC0gYG9gIG1vZGlmaWVzIHRoZSBwcmV2aW91cyB0b2tlbiB0byB0dXJuIGl0IGludG8gYW4gb3JkaW5hbCAoc2VlIGBwYXJzZWAgZG9jcylcbiAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcbiAqICAgaS5lLiA3IGZvciBTdW5kYXksIDEgZm9yIE1vbmRheSwgZXRjLlxuICogLSBgSWAgaXMgSVNPIHdlZWsgb2YgeWVhciwgYXMgb3Bwb3NlZCB0byBgd2Agd2hpY2ggaXMgbG9jYWwgd2VlayBvZiB5ZWFyLlxuICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXG4gKiAgIGBSYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYElgIGFuZCBgaWBcbiAqICAgZm9yIHVuaXZlcnNhbCBJU08gd2Vlay1udW1iZXJpbmcgZGF0ZSwgd2hlcmVhc1xuICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXG4gKiAgIGZvciB3ZWVrLW51bWJlcmluZyBkYXRlIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUuXG4gKi9cblxuXG52YXIgcGFyc2VycyA9IHtcbiAgLy8gRXJhXG4gIEc6IHtcbiAgICBwcmlvcml0eTogMTQwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIEFELCBCQ1xuICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgY2FzZSAnR0cnOlxuICAgICAgICBjYXNlICdHR0cnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93J1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBBLCBCXG5cbiAgICAgICAgY2FzZSAnR0dHR0cnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3RcblxuICAgICAgICBjYXNlICdHR0dHJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBmbGFncy5lcmEgPSB2YWx1ZTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIodmFsdWUsIDAsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1InLCAndScsICd0JywgJ1QnXVxuICB9LFxuICAvLyBZZWFyXG4gIHk6IHtcbiAgICAvLyBGcm9tIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzEvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG4gICAgLy8gfCBZZWFyICAgICB8ICAgICB5IHwgeXkgfCAgIHl5eSB8ICB5eXl5IHwgeXl5eXkgfFxuICAgIC8vIHwtLS0tLS0tLS0tfC0tLS0tLS18LS0tLXwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLXxcbiAgICAvLyB8IEFEIDEgICAgIHwgICAgIDEgfCAwMSB8ICAgMDAxIHwgIDAwMDEgfCAwMDAwMSB8XG4gICAgLy8gfCBBRCAxMiAgICB8ICAgIDEyIHwgMTIgfCAgIDAxMiB8ICAwMDEyIHwgMDAwMTIgfFxuICAgIC8vIHwgQUQgMTIzICAgfCAgIDEyMyB8IDIzIHwgICAxMjMgfCAgMDEyMyB8IDAwMTIzIHxcbiAgICAvLyB8IEFEIDEyMzQgIHwgIDEyMzQgfCAzNCB8ICAxMjM0IHwgIDEyMzQgfCAwMTIzNCB8XG4gICAgLy8gfCBBRCAxMjM0NSB8IDEyMzQ1IHwgNDUgfCAxMjM0NSB8IDEyMzQ1IHwgMTIzNDUgfFxuICAgIHByaW9yaXR5OiAxMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIGlzVHdvRGlnaXRZZWFyOiB0b2tlbiA9PT0gJ3l5J1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKDQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICAgICAgY2FzZSAneW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3llYXInLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pc1R3b0RpZ2l0WWVhciB8fCB2YWx1ZS55ZWFyID4gMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIGZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblxuICAgICAgaWYgKHZhbHVlLmlzVHdvRGlnaXRZZWFyKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkVHdvRGlnaXRZZWFyID0gbm9ybWFsaXplVHdvRGlnaXRZZWFyKHZhbHVlLnllYXIsIGN1cnJlbnRZZWFyKTtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcihub3JtYWxpemVkVHdvRGlnaXRZZWFyLCAwLCAxKTtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gISgnZXJhJyBpbiBmbGFncykgfHwgZmxhZ3MuZXJhID09PSAxID8gdmFsdWUueWVhciA6IDEgLSB2YWx1ZS55ZWFyO1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAndScsICd3JywgJ0knLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhclxuICBZOiB7XG4gICAgcHJpb3JpdHk6IDEzMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgaXNUd29EaWdpdFllYXI6IHRva2VuID09PSAnWVknXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHMoNCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgICAgICBjYXNlICdZbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAneWVhcicsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlLmlzVHdvRGlnaXRZZWFyIHx8IHZhbHVlLnllYXIgPiAwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSBnZXRVVENXZWVrWWVhcihkYXRlLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHZhbHVlLmlzVHdvRGlnaXRZZWFyKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkVHdvRGlnaXRZZWFyID0gbm9ybWFsaXplVHdvRGlnaXRZZWFyKHZhbHVlLnllYXIsIGN1cnJlbnRZZWFyKTtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcihub3JtYWxpemVkVHdvRGlnaXRZZWFyLCAwLCBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHJldHVybiBzdGFydE9mVVRDV2VlayhkYXRlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHllYXIgPSAhKCdlcmEnIGluIGZsYWdzKSB8fCBmbGFncy5lcmEgPT09IDEgPyB2YWx1ZS55ZWFyIDogMSAtIHZhbHVlLnllYXI7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdSJywgJ3UnLCAnUScsICdxJywgJ00nLCAnTCcsICdJJywgJ2QnLCAnRCcsICdpJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFI6IHtcbiAgICBwcmlvcml0eTogMTMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgaWYgKHRva2VuID09PSAnUicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCg0LCBzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VORGlnaXRzU2lnbmVkKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKF9kYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGZpcnN0V2Vla09mWWVhciA9IG5ldyBEYXRlKDApO1xuICAgICAgZmlyc3RXZWVrT2ZZZWFyLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCA0KTtcbiAgICAgIGZpcnN0V2Vla09mWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBzdGFydE9mVVRDSVNPV2VlayhmaXJzdFdlZWtPZlllYXIpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ0cnLCAneScsICdZJywgJ3UnLCAnUScsICdxJywgJ00nLCAnTCcsICd3JywgJ2QnLCAnRCcsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gRXh0ZW5kZWQgeWVhclxuICB1OiB7XG4gICAgcHJpb3JpdHk6IDEzMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gJ3UnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQoNCwgc3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih2YWx1ZSwgMCwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnRycsICd5JywgJ1knLCAnUicsICd3JywgJ0knLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gUXVhcnRlclxuICBROiB7XG4gICAgcHJpb3JpdHk6IDEyMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICBjYXNlICdRUSc6XG4gICAgICAgICAgLy8gMDEsIDAyLCAwMywgMDRcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG5cbiAgICAgICAgY2FzZSAnUW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3F1YXJ0ZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG5cbiAgICAgICAgY2FzZSAnUVFRJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcblxuICAgICAgICBjYXNlICdRUVFRUSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cblxuICAgICAgICBjYXNlICdRUVFRJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNb250aCgodmFsdWUgLSAxKSAqIDMsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdxJywgJ00nLCAnTCcsICd3JywgJ0knLCAnZCcsICdEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIHF1YXJ0ZXJcbiAgcToge1xuICAgIHByaW9yaXR5OiAxMjAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgY2FzZSAncXEnOlxuICAgICAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICAgIGNhc2UgJ3FvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICAgIGNhc2UgJ3FxcSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgICAgY2FzZSAncXFxcXEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgICAgY2FzZSAncXFxcSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAnUScsICdNJywgJ0wnLCAndycsICdJJywgJ2QnLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBNb250aFxuICBNOiB7XG4gICAgcHJpb3JpdHk6IDExMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gMTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMSwgMiwgLi4uLCAxMlxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMubW9udGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuXG4gICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKDIsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgICBjYXNlICdNbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnbW9udGgnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgICBjYXNlICdNTU0nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgICAgY2FzZSAnTU1NTU0nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICAgIGNhc2UgJ01NTU0nOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNb250aCh2YWx1ZSwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnUScsICdMJywgJ3cnLCAnSScsICdEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIG1vbnRoXG4gIEw6IHtcbiAgICBwcmlvcml0eTogMTEwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLSAxO1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5tb250aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgICAgLy8gMDEsIDAyLCAuLi4sIDEyXG5cbiAgICAgICAgY2FzZSAnTEwnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHMoMiwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuXG4gICAgICAgIGNhc2UgJ0xvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdtb250aCcsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuXG4gICAgICAgIGNhc2UgJ0xMTCc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKLCBGLCAuLi4sIERcblxuICAgICAgICBjYXNlICdMTExMTCc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG5cbiAgICAgICAgY2FzZSAnTExMTCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKHZhbHVlLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdRJywgJ00nLCAndycsICdJJywgJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTG9jYWwgd2VlayBvZiB5ZWFyXG4gIHc6IHtcbiAgICBwcmlvcml0eTogMTAwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy53ZWVrLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3dvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3ZWVrJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDUzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZVVENXZWVrKHNldFVUQ1dlZWsoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1InLCAndScsICdxJywgJ1EnLCAnTScsICdMJywgJ0knLCAnZCcsICdEJywgJ2knLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSVNPIHdlZWsgb2YgeWVhclxuICBJOiB7XG4gICAgcHJpb3JpdHk6IDEwMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMud2Vlaywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdJbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1MztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdGFydE9mVVRDSVNPV2VlayhzZXRVVENJU09XZWVrKGRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdZJywgJ3UnLCAncScsICdRJywgJ00nLCAnTCcsICd3JywgJ2QnLCAnRCcsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5kYXRlLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ2RvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXRlJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKTtcbiAgICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcblxuICAgICAgaWYgKGlzTGVhcFllYXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gREFZU19JTl9NT05USF9MRUFQX1lFQVJbbW9udGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gREFZU19JTl9NT05USFttb250aF07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKHZhbHVlKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdRJywgJ3cnLCAnSScsICdEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIERheSBvZiB5ZWFyXG4gIEQ6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGNhc2UgJ0REJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuZGF5T2ZZZWFyLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ0RvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXRlJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKTtcblxuICAgICAgaWYgKGlzTGVhcFllYXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMzY2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMzY1O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgdmFsdWUpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdxJywgJ1EnLCAnTScsICdMJywgJ3cnLCAnSScsICdkJywgJ0UnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gRGF5IG9mIHdlZWtcbiAgRToge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyBUdWVcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgIGNhc2UgJ0VFJzpcbiAgICAgICAgY2FzZSAnRUVFJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUXG5cbiAgICAgICAgY2FzZSAnRUVFRUUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVcblxuICAgICAgICBjYXNlICdFRUVFRUUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVzZGF5XG5cbiAgICAgICAgY2FzZSAnRUVFRSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gc2V0VVRDRGF5KGRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdob2xlV2Vla0RheXMgPSBNYXRoLmZsb29yKCh2YWx1ZSAtIDEpIC8gNykgKiA3O1xuICAgICAgICByZXR1cm4gKHZhbHVlICsgb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA2KSAlIDcgKyB3aG9sZVdlZWtEYXlzO1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAzXG4gICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBjYXNlICdlZSc6XG4gICAgICAgICAgLy8gMDNcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICAgICAgLy8gM3JkXG5cbiAgICAgICAgY2FzZSAnZW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2RheScsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZVxuXG4gICAgICAgIGNhc2UgJ2VlZSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVFxuXG4gICAgICAgIGNhc2UgJ2VlZWVlJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1XG5cbiAgICAgICAgY2FzZSAnZWVlZWVlJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlc2RheVxuXG4gICAgICAgIGNhc2UgJ2VlZWUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdSJywgJ3UnLCAncScsICdRJywgJ00nLCAnTCcsICdJJywgJ2QnLCAnRCcsICdFJywgJ2knLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2Vla1xuICBjOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB3aG9sZVdlZWtEYXlzID0gTWF0aC5mbG9vcigodmFsdWUgLSAxKSAvIDcpICogNztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSArIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgNikgJSA3ICsgd2hvbGVXZWVrRGF5cztcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gM1xuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgY2FzZSAnY2MnOlxuICAgICAgICAgIC8vIDAzXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDNyZFxuXG4gICAgICAgIGNhc2UgJ2NvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXknLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVcblxuICAgICAgICBjYXNlICdjY2MnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRcblxuICAgICAgICBjYXNlICdjY2NjYyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdVxuXG4gICAgICAgIGNhc2UgJ2NjY2NjYyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgICBjYXNlICdjY2NjJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSBzZXRVVENEYXkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnUicsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAnSScsICdkJywgJ0QnLCAnRScsICdpJywgJ2UnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSVNPIGRheSBvZiB3ZWVrXG4gIGk6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyAyXG4gICAgICAgIGNhc2UgJ2knOlxuICAgICAgICBjYXNlICdpaSc6XG4gICAgICAgICAgLy8gMDJcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgICAgLy8gMm5kXG5cbiAgICAgICAgY2FzZSAnaW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlXG5cbiAgICAgICAgY2FzZSAnaWlpJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUXG5cbiAgICAgICAgY2FzZSAnaWlpaWknOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1XG5cbiAgICAgICAgY2FzZSAnaWlpaWlpJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVzZGF5XG5cbiAgICAgICAgY2FzZSAnaWlpaSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZycsXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA3O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHNldFVUQ0lTT0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdZJywgJ3UnLCAncScsICdRJywgJ00nLCAnTCcsICd3JywgJ2QnLCAnRCcsICdFJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBBTSBvciBQTVxuICBhOiB7XG4gICAgcHJpb3JpdHk6IDgwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBjYXNlICdhYSc6XG4gICAgICAgIGNhc2UgJ2FhYSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnYWFhYWEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdhYWFhJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycyhkYXlQZXJpb2RFbnVtVG9Ib3Vycyh2YWx1ZSksIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYicsICdCJywgJ0gnLCAnSycsICdrJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEFNLCBQTSwgbWlkbmlnaHRcbiAgYjoge1xuICAgIHByaW9yaXR5OiA4MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnYmInOlxuICAgICAgICBjYXNlICdiYmInOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ2JiYmJiJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnYmJiYic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoZGF5UGVyaW9kRW51bVRvSG91cnModmFsdWUpLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2EnLCAnQicsICdIJywgJ0snLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBpbiB0aGUgbW9ybmluZywgaW4gdGhlIGFmdGVybm9vbiwgaW4gdGhlIGV2ZW5pbmcsIGF0IG5pZ2h0XG4gIEI6IHtcbiAgICBwcmlvcml0eTogODAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnQic6XG4gICAgICAgIGNhc2UgJ0JCJzpcbiAgICAgICAgY2FzZSAnQkJCJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdCQkJCQic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ0JCQkInOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGRheVBlcmlvZEVudW1Ub0hvdXJzKHZhbHVlKSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ2InLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuaG91cjEyaCwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdobyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnaG91cidcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAxMjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgaXNQTSA9IGRhdGUuZ2V0VVRDSG91cnMoKSA+PSAxMjtcblxuICAgICAgaWYgKGlzUE0gJiYgdmFsdWUgPCAxMikge1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlICsgMTIsIDAsIDAsIDApO1xuICAgICAgfSBlbHNlIGlmICghaXNQTSAmJiB2YWx1ZSA9PT0gMTIpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydIJywgJ0snLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiB7XG4gICAgcHJpb3JpdHk6IDcwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMjNoLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ0hvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDIzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdiJywgJ2gnLCAnSycsICdrJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEhvdXIgWzAtMTFdXG4gIEs6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnSyc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIxMWgsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnS28nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGlzUE0gPSBkYXRlLmdldFVUQ0hvdXJzKCkgPj0gMTI7XG5cbiAgICAgIGlmIChpc1BNICYmIHZhbHVlIDwgMTIpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSArIDEyLCAwLCAwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ2InLCAnaCcsICdIJywgJ2snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSG91ciBbMS0yNF1cbiAgazoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdrJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuaG91cjI0aCwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdrbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnaG91cidcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAyNDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgaG91cnMgPSB2YWx1ZSA8PSAyNCA/IHZhbHVlICUgMjQgOiB2YWx1ZTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoaG91cnMsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdiJywgJ2gnLCAnSCcsICdLJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIE1pbnV0ZVxuICBtOiB7XG4gICAgcHJpb3JpdHk6IDYwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5taW51dGUsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnbW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ21pbnV0ZSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA1OTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01pbnV0ZXModmFsdWUsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsndCcsICdUJ11cbiAgfSxcbiAgLy8gU2Vjb25kXG4gIHM6IHtcbiAgICBwcmlvcml0eTogNTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnNlY29uZCwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdzbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnc2Vjb25kJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDU5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDU2Vjb25kcyh2YWx1ZSwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnXVxuICB9LFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUzoge1xuICAgIHByaW9yaXR5OiAzMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICogTWF0aC5wb3coMTAsIC10b2tlbi5sZW5ndGggKyAzKSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01pbGxpc2Vjb25kcyh2YWx1ZSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnXVxuICB9LFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEuICswMDowMCBpcyBgJ1onYClcbiAgWDoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbE1pbnV0ZXMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnWFgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ1hYWFgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxTZWNvbmRzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ1hYWFhYJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZE9wdGlvbmFsU2Vjb25kcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdYWFgnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgaWYgKGZsYWdzLnRpbWVzdGFtcElzU2V0KSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgLSB2YWx1ZSk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsndCcsICdUJywgJ3gnXVxuICB9LFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEpXG4gIHg6IHtcbiAgICBwcmlvcml0eTogMTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxNaW51dGVzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3h4JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpYywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd4eHh4JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsU2Vjb25kcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd4eHh4eCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWRPcHRpb25hbFNlY29uZHMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAneHh4JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIGZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGlmIChmbGFncy50aW1lc3RhbXBJc1NldCkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gdmFsdWUpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCcsICdYJ11cbiAgfSxcbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXBcbiAgdDoge1xuICAgIHByaW9yaXR5OiA0MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgX3Rva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gcGFyc2VBbnlEaWdpdHNTaWduZWQoc3RyaW5nKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKF9kYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtuZXcgRGF0ZSh2YWx1ZSAqIDEwMDApLCB7XG4gICAgICAgIHRpbWVzdGFtcElzU2V0OiB0cnVlXG4gICAgICB9XTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogJyonXG4gIH0sXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAgVDoge1xuICAgIHByaW9yaXR5OiAyMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgX3Rva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gcGFyc2VBbnlEaWdpdHNTaWduZWQoc3RyaW5nKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKF9kYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtuZXcgRGF0ZSh2YWx1ZSksIHtcbiAgICAgICAgdGltZXN0YW1wSXNTZXQ6IHRydWVcbiAgICAgIH1dO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiAnKidcbiAgfVxufTtcblxudmFyIFRJTUVaT05FX1VOSVRfUFJJT1JJVFkgPSAxMDsgLy8gVGhpcyBSZWdFeHAgY29uc2lzdHMgb2YgdGhyZWUgcGFydHMgc2VwYXJhdGVkIGJ5IGB8YDpcbi8vIC0gW3lZUXFNTHdJZERlY2loSEtrbXNdbyBtYXRjaGVzIGFueSBhdmFpbGFibGUgb3JkaW5hbCBudW1iZXIgdG9rZW5cbi8vICAgKG9uZSBvZiB0aGUgY2VydGFpbiBsZXR0ZXJzIGZvbGxvd2VkIGJ5IGBvYClcbi8vIC0gKFxcdylcXDEqIG1hdGNoZXMgYW55IHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBsZXR0ZXJcbi8vIC0gJycgbWF0Y2hlcyB0d28gcXVvdGUgY2hhcmFjdGVycyBpbiBhIHJvd1xuLy8gLSAnKCcnfFteJ10pKygnfCQpIG1hdGNoZXMgYW55dGhpbmcgc3Vycm91bmRlZCBieSB0d28gcXVvdGUgY2hhcmFjdGVycyAoJyksXG4vLyAgIGV4Y2VwdCBhIHNpbmdsZSBxdW90ZSBzeW1ib2wsIHdoaWNoIGVuZHMgdGhlIHNlcXVlbmNlLlxuLy8gICBUd28gcXVvdGUgY2hhcmFjdGVycyBkbyBub3QgZW5kIHRoZSBzZXF1ZW5jZS5cbi8vICAgSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc2luZ2xlIHF1b3RlXG4vLyAgIHRoZW4gdGhlIHNlcXVlbmNlIHdpbGwgY29udGludWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuLy8gLSAuIG1hdGNoZXMgYW55IHNpbmdsZSBjaGFyYWN0ZXIgdW5tYXRjaGVkIGJ5IHByZXZpb3VzIHBhcnRzIG9mIHRoZSBSZWdFeHBzXG5cbnZhciBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwJDEgPSAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFx3KVxcMSp8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7IC8vIFRoaXMgUmVnRXhwIGNhdGNoZXMgc3ltYm9scyBlc2NhcGVkIGJ5IHF1b3RlcywgYW5kIGFsc29cbi8vIHNlcXVlbmNlcyBvZiBzeW1ib2xzIFAsIHAsIGFuZCB0aGUgY29tYmluYXRpb25zIGxpa2UgYFBQUFBQUFBwcHBwcGBcblxudmFyIGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwJDEgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcbnZhciBlc2NhcGVkU3RyaW5nUmVnRXhwJDEgPSAvXicoLio/KSc/JC87XG52YXIgZG91YmxlUXVvdGVSZWdFeHAkMSA9IC8nJy9nO1xudmFyIG5vdFdoaXRlc3BhY2VSZWdFeHAgPSAvXFxTLztcbnZhciB1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCQxID0gL1thLXpBLVpdLztcbi8qKlxuICogQG5hbWUgcGFyc2VcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGRhdGUgcGFyc2VkIGZyb20gc3RyaW5nIHVzaW5nIHRoZSBnaXZlbiBmb3JtYXQgc3RyaW5nLlxuICpcbiAqID4g4pqg77iPIFBsZWFzZSBub3RlIHRoYXQgdGhlIGBmb3JtYXRgIHRva2VucyBkaWZmZXIgZnJvbSBNb21lbnQuanMgYW5kIG90aGVyIGxpYnJhcmllcy5cbiAqID4gU2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICpcbiAqIFRoZSBjaGFyYWN0ZXJzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHdyYXBwZWQgYmV0d2VlbiB0d28gc2luZ2xlIHF1b3RlcyBjaGFyYWN0ZXJzICgnKSBhcmUgZXNjYXBlZC5cbiAqIFR3byBzaW5nbGUgcXVvdGVzIGluIGEgcm93LCB3aGV0aGVyIGluc2lkZSBvciBvdXRzaWRlIGEgcXVvdGVkIHNlcXVlbmNlLCByZXByZXNlbnQgYSAncmVhbCcgc2luZ2xlIHF1b3RlLlxuICpcbiAqIEZvcm1hdCBvZiB0aGUgZm9ybWF0IHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNSBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIE5vdCBhbGwgdG9rZW5zIGFyZSBjb21wYXRpYmxlLiBDb21iaW5hdGlvbnMgdGhhdCBkb24ndCBtYWtlIHNlbnNlIG9yIGNvdWxkIGxlYWQgdG8gYnVncyBhcmUgcHJvaGliaXRlZFxuICogYW5kIHdpbGwgdGhyb3cgYFJhbmdlRXJyb3JgLiBGb3IgZXhhbXBsZSB1c2FnZSBvZiAyNC1ob3VyIGZvcm1hdCB0b2tlbiB3aXRoIEFNL1BNIHRva2VuIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHBhcnNlKCcyMyBBTScsICdISCBhJywgbmV3IERhdGUoKSlcbiAqIC8vPT4gUmFuZ2VFcnJvcjogVGhlIGZvcm1hdCBzdHJpbmcgbXVzdG4ndCBjb250YWluIGBISGAgYW5kIGBhYCBhdCB0aGUgc2FtZSB0aW1lXG4gKiBgYGBcbiAqXG4gKiBTZWUgdGhlIGNvbXBhdGliaWxpdHkgdGFibGU6IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kL2UvMlBBQ1gtMXZRT1BVM3hVaHBsbGw2ZHlvTW1WVVhIS2xfOENSRHM2X3VlTG1leDNTb3F3aHVvbGt1TjNPMDVsNHJxeDVoMWRLWDhlYjQ2VWwtQ0NTcnEvcHViaHRtbD9naWQ9MCZzaW5nbGU9dHJ1ZVxuICpcbiAqIEFjY2VwdGVkIGZvcm1hdCBzdHJpbmcgcGF0dGVybnM6XG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFByaW9yfCBQYXR0ZXJuIHwgUmVzdWx0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHwgTm90ZXMgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLXxcbiAqIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDE0MCB8IEcuLkdHRyAgfCBBRCwgQkMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBHR0dHICAgIHwgQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3QgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgR0dHR0cgICB8IEEsIEIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQ2FsZW5kYXIgeWVhciAgICAgICAgICAgICAgICAgICB8IDEzMCB8IHkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNywgOTk5OSAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5byAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDk5OTk5OTl0aCAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXkgICAgICB8IDQ0LCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eSAgICAgfCAwNDQsIDAwMSwgMTIzLCA5OTkgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXl5ICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5eXkgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcbiAqIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICB8IDEzMCB8IFkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNywgOTAwMCAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZbyAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDk5OTk5OTl0aCAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVkgICAgICB8IDQ0LCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgICB8IDQsNiAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWSAgICAgfCAwNDQsIDAwMSwgMTIzLCA5OTkgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVlZICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNCw2ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZWVkgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgICB8IDEzMCB8IFIgICAgICAgfCAtNDMsIDEsIDE5MDAsIDIwMTcsIDk5OTksIC05OTk5ICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUiAgICAgIHwgLTQzLCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSICAgICB8IC0wNDMsIDAwMSwgMTIzLCA5OTksIC05OTkgICAgICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUlIgICAgfCAtMDA0MywgMDAwMSwgMjAxNywgOTk5OSwgLTk5OTkgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlJSUiAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0LDUgfFxuICogfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgIHwgMTMwIHwgdSAgICAgICB8IC00MywgMSwgMTkwMCwgMjAxNywgOTk5OSwgLTk5OSAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1ICAgICAgfCAtNDMsIDAxLCA5OSwgLTk5ICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXUgICAgIHwgLTA0MywgMDAxLCAxMjMsIDk5OSwgLTk5OSAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1dSAgICB8IC0wMDQzLCAwMDAxLCAyMDE3LCA5OTk5LCAtOTk5OSAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dXV1ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XG4gKiB8IFF1YXJ0ZXIgKGZvcm1hdHRpbmcpICAgICAgICAgICAgfCAxMjAgfCBRICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUW8gICAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRUSAgICB8IDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUVFRICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8IFF1YXJ0ZXIgKHN0YW5kLWFsb25lKSAgICAgICAgICAgfCAxMjAgfCBxICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcW8gICAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxcSAgICB8IDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcXFxICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IE1vbnRoIChmb3JtYXR0aW5nKSAgICAgICAgICAgICAgfCAxMTAgfCBNICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU0gICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NTSAgICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTU1NICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1vbnRoIChzdGFuZC1hbG9uZSkgICAgICAgICAgICAgfCAxMTAgfCBMICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTEwgICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMTCAgICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTExMICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgfCAxMDAgfCB3ICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgd28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDUzdGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHd3ICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICAgfCAxMDAgfCBJICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDUzdGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IElJICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICAgfCAgOTAgfCBkICAgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDMxc3QgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGRkICAgICAgfCAwMSwgMDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICAgfCAgOTAgfCBEICAgICAgIHwgMSwgMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDM2NXRoLCAzNjZ0aCAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEREICAgICAgfCAwMSwgMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEREQgICAgIHwgMDAxLCAwMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRERERCAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgICAgICB8ICA5MCB8IEUuLkVFRSAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRUUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUVFRSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XG4gKiB8IElTTyBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgfCAgOTAgfCBpICAgICAgIHwgMSwgMiwgMywgLi4uLCA3ICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDd0aCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpICAgICAgfCAwMSwgMDIsIC4uLiwgMDcgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWkgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWlpICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpaWkgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgNSAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgIHwgIDkwIHwgZSAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZSAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlZSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZWVlICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKHN0YW5kLWFsb25lKSB8ICA5MCB8IGMgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2MgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjYyAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjY2MgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2NjYyAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgODAgfCBhLi5hYWEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYWFhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgfCAgODAgfCBiLi5iYmIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCAgODAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEtLICAgICAgfCAxLCAyLCAuLi4sIDExLCAwICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgNjAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgNTAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCAgNDAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgICB8ICAzMCB8IFMgICAgICAgfCAwLCAxLCAuLi4sIDkgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTUyAgICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1NTICAgICB8IDAwMCwgMDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTU1MgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgfCAgMjAgfCBUICAgICAgIHwgNTEyOTY5NTIwOTAwICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvIFopICAgICAgICB8ICAxMCB8IFggICAgICAgfCAtMDgsICswNTMwLCBaICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWCAgICAgIHwgLTA4MDAsICswNTMwLCBaICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYICAgICB8IC0wODowMCwgKzA1OjMwLCBaICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWFggICAgfCAtMDgwMCwgKzA1MzAsIFosICsxMjM0NTYgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFhYWCAgIHwgLTA4OjAwLCArMDU6MzAsIFosICsxMjozNDo1NiAgICAgIHwgICAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgIHwgIDEwIHwgeCAgICAgICB8IC0wOCwgKzA1MzAsICswMCAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4ICAgICAgfCAtMDgwMCwgKzA1MzAsICswMDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHggICAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4eCAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAsICsxMjM0NTYgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eHh4ICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwLCArMTI6MzQ6NTYgfCAgICAgICB8XG4gKiB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICAgfCAgTkEgfCBQICAgICAgIHwgMDUvMjkvMTQ1MyAgICAgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFAgICAgICB8IE1heSAyOSwgMTQ1MyAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUCAgICAgfCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFBQICAgIHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgIHwgMiw1LDggfFxuICogfCBMb25nIGxvY2FsaXplZCB0aW1lICAgICAgICAgICAgIHwgIE5BIHwgcCAgICAgICB8IDEyOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHBwICAgICAgfCAxMjowMDowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCAgTkEgfCBQcCAgICAgIHwgMDUvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBwcCAgICB8IE1heSAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUHBwICAgfCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFBQcHAgIHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgIHwgMiw1LDggfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhci5cbiAqICAgIEluIGBmb3JtYXRgIGZ1bmN0aW9uLCB0aGV5IHdpbGwgcHJvZHVjZSBkaWZmZXJlbnQgcmVzdWx0OlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTExMTCcsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWQnYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTU1NTScsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWR1J2BcbiAqXG4gKiAgICBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIGJvdGggZm9ybWF0dGluZyBhbmQgc3RhbmQtYWxvbmUgdW5pdHMgaW50ZXJjaGFuZ2FibHkuXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlOlxuICogICAgLSBmb3IgbnVtZXJpY2FsIHVuaXRzIChgeXl5eXl5eXlgKSBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIGEgbnVtYmVyXG4gKiAgICAgIGFzIHdpZGUgYXMgdGhlIHNlcXVlbmNlXG4gKiAgICAtIGZvciB0ZXh0IHVuaXRzIChgTU1NTU1NTU1gKSBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIHRoZSB3aWRlc3QgdmFyaWF0aW9uIG9mIHRoZSB1bml0LlxuICogICAgICBUaGVzZSB2YXJpYXRpb25zIGFyZSBtYXJrZWQgd2l0aCBcIjJcIiBpbiB0aGUgbGFzdCBjb2x1bW4gb2YgdGhlIHRhYmxlLlxuICpcbiAqIDMuIGBRUVFRUWAgYW5kIGBxcXFxcWAgY291bGQgYmUgbm90IHN0cmljdGx5IG51bWVyaWNhbCBpbiBzb21lIGxvY2FsZXMuXG4gKiAgICBUaGVzZSB0b2tlbnMgcmVwcmVzZW50IHRoZSBzaG9ydGVzdCBmb3JtIG9mIHRoZSBxdWFydGVyLlxuICpcbiAqIDQuIFRoZSBtYWluIGRpZmZlcmVuY2UgYmV0d2VlbiBgeWAgYW5kIGB1YCBwYXR0ZXJucyBhcmUgQi5DLiB5ZWFyczpcbiAqXG4gKiAgICB8IFllYXIgfCBgeWAgfCBgdWAgfFxuICogICAgfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAqICAgIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gKiAgICB8IEJDIDEgfCAgIDEgfCAgIDAgfFxuICogICAgfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAqXG4gKiAgICBBbHNvIGB5eWAgd2lsbCB0cnkgdG8gZ3Vlc3MgdGhlIGNlbnR1cnkgb2YgdHdvIGRpZ2l0IHllYXIgYnkgcHJveGltaXR5IHdpdGggYGJhY2t1cERhdGVgOlxuICpcbiAqICAgIGBwYXJzZSgnNTAnLCAneXknLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBTYXQgSmFuIDAxIDIwNTAgMDA6MDA6MDBgXG4gKlxuICogICAgYHBhcnNlKCc3NScsICd5eScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFdlZCBKYW4gMDEgMTk3NSAwMDowMDowMGBcbiAqXG4gKiAgICB3aGlsZSBgdXVgIHdpbGwganVzdCBhc3NpZ24gdGhlIHllYXIgYXMgaXM6XG4gKlxuICogICAgYHBhcnNlKCc1MCcsICd1dScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFNhdCBKYW4gMDEgMDA1MCAwMDowMDowMGBcbiAqXG4gKiAgICBgcGFyc2UoJzc1JywgJ3V1JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gVHVlIEphbiAwMSAwMDc1IDAwOjAwOjAwYFxuICpcbiAqICAgIFRoZSBzYW1lIGRpZmZlcmVuY2UgaXMgdHJ1ZSBmb3IgbG9jYWwgYW5kIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyAoYFlgIGFuZCBgUmApLFxuICogICAgZXhjZXB0IGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJzIGFyZSBkZXBlbmRlbnQgb24gYG9wdGlvbnMud2Vla1N0YXJ0c09uYFxuICogICAgYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKGNvbXBhcmUgW3NldElTT1dlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3NldElTT1dlZWtZZWFyfVxuICogICAgYW5kIFtzZXRXZWVrWWVhcl17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9zZXRXZWVrWWVhcn0pLlxuICpcbiAqIDUuIFRoZXNlIHBhdHRlcm5zIGFyZSBub3QgaW4gdGhlIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqICAgIC0gYGlgOiBJU08gZGF5IG9mIHdlZWtcbiAqICAgIC0gYElgOiBJU08gd2VlayBvZiB5ZWFyXG4gKiAgICAtIGBSYDogSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqICAgIC0gYG9gOiBvcmRpbmFsIG51bWJlciBtb2RpZmllclxuICogICAgLSBgUGA6IGxvbmcgbG9jYWxpemVkIGRhdGVcbiAqICAgIC0gYHBgOiBsb25nIGxvY2FsaXplZCB0aW1lXG4gKlxuICogNi4gYFlZYCBhbmQgYFlZWVlgIHRva2VucyByZXByZXNlbnQgd2Vlay1udW1iZXJpbmcgeWVhcnMgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggeWVhcnMuXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogNy4gYERgIGFuZCBgRERgIHRva2VucyByZXByZXNlbnQgZGF5cyBvZiB0aGUgeWVhciBidXQgdGhleSBhcmUgb2Z0aGVuIGNvbmZ1c2VkIHdpdGggZGF5cyBvZiB0aGUgbW9udGguXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICpcbiAqIDguIGBQK2AgdG9rZW5zIGRvIG5vdCBoYXZlIGEgZGVmaW5lZCBwcmlvcml0eSBzaW5jZSB0aGV5IGFyZSBtZXJlbHkgYWxpYXNlcyB0byBvdGhlciB0b2tlbnMgYmFzZWRcbiAqICAgIG9uIHRoZSBnaXZlbiBsb2NhbGUuXG4gKlxuICogICAgdXNpbmcgYGVuLVVTYCBsb2NhbGU6IGBQYCA9PiBgTU0vZGQveXl5eWBcbiAqICAgIHVzaW5nIGBlbi1VU2AgbG9jYWxlOiBgcGAgPT4gYGhoOm1tIGFgXG4gKiAgICB1c2luZyBgcHQtQlJgIGxvY2FsZTogYFBgID0+IGBkZC9NTS95eXl5YFxuICogICAgdXNpbmcgYHB0LUJSYCBsb2NhbGU6IGBwYCA9PiBgSEg6bW1gXG4gKlxuICogVmFsdWVzIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGRhdGUgaW4gdGhlIGRlc2NlbmRpbmcgb3JkZXIgb2YgaXRzIHVuaXQncyBwcmlvcml0eS5cbiAqIFVuaXRzIG9mIGFuIGVxdWFsIHByaW9yaXR5IG92ZXJ3cml0ZSBlYWNoIG90aGVyIGluIHRoZSBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICpcbiAqIElmIG5vIHZhbHVlcyBvZiBoaWdoZXIgcHJpb3JpdHkgYXJlIHBhcnNlZCAoZS5nLiB3aGVuIHBhcnNpbmcgc3RyaW5nICdKYW51YXJ5IDFzdCcgd2l0aG91dCBhIHllYXIpLFxuICogdGhlIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gM3JkIGFyZ3VtZW50IGBiYWNrdXBEYXRlYCB3aGljaCB3b3JrcyBhcyBhIGNvbnRleHQgb2YgcGFyc2luZy5cbiAqXG4gKiBgYmFja3VwRGF0ZWAgbXVzdCBiZSBwYXNzZWQgZm9yIGNvcnJlY3Qgd29yayBvZiB0aGUgZnVuY3Rpb24uXG4gKiBJZiB5b3UncmUgbm90IHN1cmUgd2hpY2ggYGJhY2t1cERhdGVgIHRvIHN1cHBseSwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIERhdGU6XG4gKiBgcGFyc2UoJzAyLzExLzIwMTQnLCAnTU0vZGQveXl5eScsIG5ldyBEYXRlKCkpYFxuICogSW4gdGhpcyBjYXNlIHBhcnNpbmcgd2lsbCBiZSBkb25lIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjdXJyZW50IGRhdGUuXG4gKiBJZiBgYmFja3VwRGF0ZWAgaXMgYEludmFsaWQgRGF0ZWAgb3IgYSB2YWx1ZSBub3QgY29udmVydGlibGUgdG8gdmFsaWQgYERhdGVgLFxuICogdGhlbiBgSW52YWxpZCBEYXRlYCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIFRoZSByZXN1bHQgbWF5IHZhcnkgYnkgbG9jYWxlLlxuICpcbiAqIElmIGBmb3JtYXRTdHJpbmdgIG1hdGNoZXMgd2l0aCBgZGF0ZVN0cmluZ2AgYnV0IGRvZXMgbm90IHByb3ZpZGVzIHRva2VucywgYGJhY2t1cERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogSWYgcGFyc2luZyBmYWlsZWQsIGBJbnZhbGlkIERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBJbnZhbGlkIERhdGUgaXMgYSBEYXRlLCB3aG9zZSB0aW1lIHZhbHVlIGlzIE5hTi5cbiAqIFRpbWUgdmFsdWUgb2YgRGF0ZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS45LjEuMVxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogLSBPbGQgYHBhcnNlYCB3YXMgcmVuYW1lZCB0byBgdG9EYXRlYC5cbiAqICAgTm93IGBwYXJzZWAgaXMgYSBuZXcgZnVuY3Rpb24gd2hpY2ggcGFyc2VzIGEgc3RyaW5nIHVzaW5nIGEgcHJvdmlkZWQgZm9ybWF0LlxuICpcbiAqICAgYGBgamF2YXNjcmlwdFxuICogICAvLyBCZWZvcmUgdjIuMC4wXG4gKiAgIHBhcnNlKCcyMDE2LTAxLTAxJylcbiAqXG4gKiAgIC8vIHYyLjAuMCBvbndhcmRcbiAqICAgdG9EYXRlKCcyMDE2LTAxLTAxJylcbiAqICAgcGFyc2UoJzIwMTYtMDEtMDEnLCAneXl5eS1NTS1kZCcsIG5ldyBEYXRlKCkpXG4gKiAgIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlU3RyaW5nIC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFN0cmluZyAtIHRoZSBzdHJpbmcgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBiYWNrdXBEYXRlIC0gZGVmaW5lcyB2YWx1ZXMgbWlzc2luZyBmcm9tIHRoZSBwYXJzZWQgZGF0ZVN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXG4gKiBAcGFyYW0gezF8MnwzfDR8NXw2fDd9IFtvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZT0xXSAtIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgdGhlIHdlZWstbnVtYmVyaW5nIHllYXIgdG9rZW5zIGBZWWAgYW5kIGBZWVlZYDtcbiAqICAgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiB0aGUgZGF5IG9mIHllYXIgdG9rZW5zIGBEYCBhbmQgYEREYDtcbiAqICAgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAzIGFyZ3VtZW50cyByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMud2Vla1N0YXJ0c09uYCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgN1xuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYG1hdGNoYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCBmb3IgZm9ybWF0dGluZyB5ZWFyczsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGg7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBQYXJzZSAxMSBGZWJydWFyeSAyMDE0IGZyb20gbWlkZGxlLWVuZGlhbiBmb3JtYXQ6XG4gKiB2YXIgcmVzdWx0ID0gcGFyc2UoJzAyLzExLzIwMTQnLCAnTU0vZGQveXl5eScsIG5ldyBEYXRlKCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBQYXJzZSAyOHRoIG9mIEZlYnJ1YXJ5IGluIEVzcGVyYW50byBsb2NhbGUgaW4gdGhlIGNvbnRleHQgb2YgMjAxMCB5ZWFyOlxuICogaW1wb3J0IGVvIGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcbiAqIHZhciByZXN1bHQgPSBwYXJzZSgnMjgtYSBkZSBmZWJydWFybycsIFwiZG8gJ2RlJyBNTU1NXCIsIG5ldyBEYXRlKDIwMTAsIDAsIDEpLCB7XG4gKiAgIGxvY2FsZTogZW9cbiAqIH0pXG4gKiAvLz0+IFN1biBGZWIgMjggMjAxMCAwMDowMDowMFxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKGRpcnR5RGF0ZVN0cmluZywgZGlydHlGb3JtYXRTdHJpbmcsIGRpcnR5QmFja3VwRGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIGRhdGVTdHJpbmcgPSBTdHJpbmcoZGlydHlEYXRlU3RyaW5nKTtcbiAgdmFyIGZvcm1hdFN0cmluZyA9IFN0cmluZyhkaXJ0eUZvcm1hdFN0cmluZyk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlJDEgPSBvcHRpb25zLmxvY2FsZSB8fCBsb2NhbGU7XG5cbiAgaWYgKCFsb2NhbGUkMS5tYXRjaCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIG1hdGNoIHByb3BlcnR5Jyk7XG4gIH1cblxuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlJDEub3B0aW9ucyAmJiBsb2NhbGUkMS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIkMShsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIkMShvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMSBhbmQgNyBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEoZmlyc3RXZWVrQ29udGFpbnNEYXRlID49IDEgJiYgZmlyc3RXZWVrQ29udGFpbnNEYXRlIDw9IDcpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZpcnN0V2Vla0NvbnRhaW5zRGF0ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNyBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGxvY2FsZVdlZWtTdGFydHNPbiA9IGxvY2FsZSQxLm9wdGlvbnMgJiYgbG9jYWxlJDEub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyJDEobG9jYWxlV2Vla1N0YXJ0c09uKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyJDEob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIGlmIChmb3JtYXRTdHJpbmcgPT09ICcnKSB7XG4gICAgaWYgKGRhdGVTdHJpbmcgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdG9EYXRlKGRpcnR5QmFja3VwRGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdWJGbk9wdGlvbnMgPSB7XG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiBmaXJzdFdlZWtDb250YWluc0RhdGUsXG4gICAgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24sXG4gICAgbG9jYWxlOiBsb2NhbGUkMSAvLyBJZiB0aW1lem9uZSBpc24ndCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBzeXN0ZW0gdGltZXpvbmVcblxuICB9O1xuICB2YXIgc2V0dGVycyA9IFt7XG4gICAgcHJpb3JpdHk6IFRJTUVaT05FX1VOSVRfUFJJT1JJVFksXG4gICAgc2V0OiBkYXRlVG9TeXN0ZW1UaW1lem9uZSxcbiAgICBpbmRleDogMFxuICB9XTtcbiAgdmFyIGk7XG4gIHZhciB0b2tlbnMgPSBmb3JtYXRTdHJpbmcubWF0Y2gobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSkubWFwKGZ1bmN0aW9uIChzdWJzdHJpbmcpIHtcbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09ICdwJyB8fCBmaXJzdENoYXJhY3RlciA9PT0gJ1AnKSB7XG4gICAgICB2YXIgbG9uZ0Zvcm1hdHRlciA9IGxvbmdGb3JtYXR0ZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcbiAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlJDEuZm9ybWF0TG9uZywgc3ViRm5PcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic3RyaW5nO1xuICB9KS5qb2luKCcnKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zUmVnRXhwJDEpO1xuICB2YXIgdXNlZFRva2VucyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAoIW9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbih0b2tlbikpIHtcbiAgICAgIHRocm93UHJvdGVjdGVkRXJyb3IodG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4odG9rZW4pKSB7XG4gICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHRva2VuKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSB0b2tlblswXTtcbiAgICB2YXIgcGFyc2VyID0gcGFyc2Vyc1tmaXJzdENoYXJhY3Rlcl07XG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICB2YXIgaW5jb21wYXRpYmxlVG9rZW5zID0gcGFyc2VyLmluY29tcGF0aWJsZVRva2VucztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5jb21wYXRpYmxlVG9rZW5zKSkge1xuICAgICAgICB2YXIgaW5jb21wYXRpYmxlVG9rZW4gPSB2b2lkIDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHVzZWRUb2tlbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHVzZWRUb2tlbiA9IHVzZWRUb2tlbnNbX2ldLnRva2VuO1xuXG4gICAgICAgICAgaWYgKGluY29tcGF0aWJsZVRva2Vucy5pbmRleE9mKHVzZWRUb2tlbikgIT09IC0xIHx8IHVzZWRUb2tlbiA9PT0gZmlyc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIGluY29tcGF0aWJsZVRva2VuID0gdXNlZFRva2Vuc1tfaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jb21wYXRpYmxlVG9rZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBmb3JtYXQgc3RyaW5nIG11c3RuJ3QgY29udGFpbiBgXCIuY29uY2F0KGluY29tcGF0aWJsZVRva2VuLmZ1bGxUb2tlbiwgXCJgIGFuZCBgXCIpLmNvbmNhdCh0b2tlbiwgXCJgIGF0IHRoZSBzYW1lIHRpbWVcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlci5pbmNvbXBhdGlibGVUb2tlbnMgPT09ICcqJyAmJiB1c2VkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBmb3JtYXQgc3RyaW5nIG11c3RuJ3QgY29udGFpbiBgXCIuY29uY2F0KHRva2VuLCBcImAgYW5kIGFueSBvdGhlciB0b2tlbiBhdCB0aGUgc2FtZSB0aW1lXCIpKTtcbiAgICAgIH1cblxuICAgICAgdXNlZFRva2Vucy5wdXNoKHtcbiAgICAgICAgdG9rZW46IGZpcnN0Q2hhcmFjdGVyLFxuICAgICAgICBmdWxsVG9rZW46IHRva2VuXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHBhcnNlci5wYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbG9jYWxlJDEubWF0Y2gsIHN1YkZuT3B0aW9ucyk7XG5cbiAgICAgIGlmICghcGFyc2VSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgICB9XG5cbiAgICAgIHNldHRlcnMucHVzaCh7XG4gICAgICAgIHByaW9yaXR5OiBwYXJzZXIucHJpb3JpdHksXG4gICAgICAgIHNldDogcGFyc2VyLnNldCxcbiAgICAgICAgdmFsaWRhdGU6IHBhcnNlci52YWxpZGF0ZSxcbiAgICAgICAgdmFsdWU6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICBpbmRleDogc2V0dGVycy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgZGF0ZVN0cmluZyA9IHBhcnNlUmVzdWx0LnJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaXJzdENoYXJhY3Rlci5tYXRjaCh1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCQxKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyIGAnICsgZmlyc3RDaGFyYWN0ZXIgKyAnYCcpO1xuICAgICAgfSAvLyBSZXBsYWNlIHR3byBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyB3aXRoIG9uZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyXG5cblxuICAgICAgaWYgKHRva2VuID09PSBcIicnXCIpIHtcbiAgICAgICAgdG9rZW4gPSBcIidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgIHRva2VuID0gY2xlYW5Fc2NhcGVkU3RyaW5nJDEodG9rZW4pO1xuICAgICAgfSAvLyBDdXQgdG9rZW4gZnJvbSBzdHJpbmcsIG9yLCBpZiBzdHJpbmcgZG9lc24ndCBtYXRjaCB0aGUgdG9rZW4sIHJldHVybiBJbnZhbGlkIERhdGVcblxuXG4gICAgICBpZiAoZGF0ZVN0cmluZy5pbmRleE9mKHRva2VuKSA9PT0gMCkge1xuICAgICAgICBkYXRlU3RyaW5nID0gZGF0ZVN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZSByZW1haW5pbmcgaW5wdXQgY29udGFpbnMgc29tZXRoaW5nIG90aGVyIHRoYW4gd2hpdGVzcGFjZVxuXG5cbiAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoID4gMCAmJiBub3RXaGl0ZXNwYWNlUmVnRXhwLnRlc3QoZGF0ZVN0cmluZykpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHZhciB1bmlxdWVQcmlvcml0eVNldHRlcnMgPSBzZXR0ZXJzLm1hcChmdW5jdGlvbiAoc2V0dGVyKSB7XG4gICAgcmV0dXJuIHNldHRlci5wcmlvcml0eTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiIC0gYTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChwcmlvcml0eSwgaW5kZXgsIGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YocHJpb3JpdHkpID09PSBpbmRleDtcbiAgfSkubWFwKGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgIHJldHVybiBzZXR0ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2V0dGVyKSB7XG4gICAgICByZXR1cm4gc2V0dGVyLnByaW9yaXR5ID09PSBwcmlvcml0eTtcbiAgICB9KS5yZXZlcnNlKCk7XG4gIH0pLm1hcChmdW5jdGlvbiAoc2V0dGVyQXJyYXkpIHtcbiAgICByZXR1cm4gc2V0dGVyQXJyYXlbMF07XG4gIH0pO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eUJhY2t1cERhdGUpO1xuXG4gIGlmIChpc05hTihkYXRlKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9IC8vIENvbnZlcnQgdGhlIGRhdGUgaW4gc3lzdGVtIHRpbWV6b25lIHRvIHRoZSBzYW1lIGRhdGUgaW4gVVRDKzAwOjAwIHRpbWV6b25lLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxuICAvLyBTZWUgYW4gaXNzdWUgYWJvdXQgVVRDIGZ1bmN0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zN1xuXG5cbiAgdmFyIHV0Y0RhdGUgPSBzdWJNaWxsaXNlY29uZHMoZGF0ZSwgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkYXRlKSk7XG4gIHZhciBmbGFncyA9IHt9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB1bmlxdWVQcmlvcml0eVNldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2V0dGVyID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzW2ldO1xuXG4gICAgaWYgKHNldHRlci52YWxpZGF0ZSAmJiAhc2V0dGVyLnZhbGlkYXRlKHV0Y0RhdGUsIHNldHRlci52YWx1ZSwgc3ViRm5PcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHNldHRlci5zZXQodXRjRGF0ZSwgZmxhZ3MsIHNldHRlci52YWx1ZSwgc3ViRm5PcHRpb25zKTsgLy8gUmVzdWx0IGlzIHR1cGxlIChkYXRlLCBmbGFncylcblxuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgIHV0Y0RhdGUgPSByZXN1bHRbMF07XG4gICAgICBhc3NpZ24kMShmbGFncywgcmVzdWx0WzFdKTsgLy8gUmVzdWx0IGlzIGRhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgdXRjRGF0ZSA9IHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXRjRGF0ZTtcbn1cblxuZnVuY3Rpb24gZGF0ZVRvU3lzdGVtVGltZXpvbmUoZGF0ZSwgZmxhZ3MpIHtcbiAgaWYgKGZsYWdzLnRpbWVzdGFtcElzU2V0KSB7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICB2YXIgY29udmVydGVkRGF0ZSA9IG5ldyBEYXRlKDApO1xuICBjb252ZXJ0ZWREYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGNvbnZlcnRlZERhdGUuc2V0SG91cnMoZGF0ZS5nZXRVVENIb3VycygpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCksIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpO1xuICByZXR1cm4gY29udmVydGVkRGF0ZTtcbn1cblxuZnVuY3Rpb24gY2xlYW5Fc2NhcGVkU3RyaW5nJDEoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0Lm1hdGNoKGVzY2FwZWRTdHJpbmdSZWdFeHAkMSlbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCQxLCBcIidcIik7XG59XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fSE9VUiQxID0gMzYwMDAwMDtcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDIgPSA2MDAwMDtcbnZhciBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTID0gMjtcbnZhciBwYXR0ZXJucyA9IHtcbiAgZGF0ZVRpbWVEZWxpbWl0ZXI6IC9bVCBdLyxcbiAgdGltZVpvbmVEZWxpbWl0ZXI6IC9bWiBdL2ksXG4gIHRpbWV6b25lOiAvKFtaKy1dLiopJC9cbn07XG52YXIgZGF0ZVJlZ2V4ID0gL14tPyg/OihcXGR7M30pfChcXGR7Mn0pKD86LT8oXFxkezJ9KSk/fFcoXFxkezJ9KSg/Oi0/KFxcZHsxfSkpP3wpJC87XG52YXIgdGltZVJlZ2V4ID0gL14oXFxkezJ9KD86Wy4sXVxcZCopPykoPzo6PyhcXGR7Mn0oPzpbLixdXFxkKik/KSk/KD86Oj8oXFxkezJ9KD86Wy4sXVxcZCopPykpPyQvO1xudmFyIHRpbWV6b25lUmVnZXggPSAvXihbKy1dKShcXGR7Mn0pKD86Oj8oXFxkezJ9KSk/JC87XG4vKipcbiAqIEBuYW1lIHBhcnNlSVNPXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFBhcnNlIElTTyBzdHJpbmdcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgaW4gSVNPIDg2MDEgZm9ybWF0IGFuZCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBGdW5jdGlvbiBhY2NlcHRzIGNvbXBsZXRlIElTTyA4NjAxIGZvcm1hdHMgYXMgd2VsbCBhcyBwYXJ0aWFsIGltcGxlbWVudGF0aW9ucy5cbiAqIElTTyA4NjAxOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzbid0IGEgc3RyaW5nLCB0aGUgZnVuY3Rpb24gY2Fubm90IHBhcnNlIHRoZSBzdHJpbmcgb3JcbiAqIHRoZSB2YWx1ZXMgYXJlIGludmFsaWQsIGl0IHJldHVybnMgSW52YWxpZCBEYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogLSBUaGUgcHJldmlvdXMgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbiB3YXMgcmVuYW1lZCB0byBgcGFyc2VJU09gLlxuICpcbiAqICAgYGBgamF2YXNjcmlwdFxuICogICAvLyBCZWZvcmUgdjIuMC4wXG4gKiAgIHBhcnNlKCcyMDE2LTAxLTAxJylcbiAqXG4gKiAgIC8vIHYyLjAuMCBvbndhcmRcbiAqICAgcGFyc2VJU08oJzIwMTYtMDEtMDEnKVxuICogICBgYGBcbiAqXG4gKiAtIGBwYXJzZUlTT2Agbm93IHZhbGlkYXRlcyBzZXBhcmF0ZSBkYXRlIGFuZCB0aW1lIHZhbHVlcyBpbiBJU08tODYwMSBzdHJpbmdzXG4gKiAgIGFuZCByZXR1cm5zIGBJbnZhbGlkIERhdGVgIGlmIHRoZSBkYXRlIGlzIGludmFsaWQuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIHBhcnNlSVNPKCcyMDE4LTEzLTMyJylcbiAqICAgLy89PiBJbnZhbGlkIERhdGVcbiAqICAgYGBgXG4gKlxuICogLSBgcGFyc2VJU09gIG5vdyBkb2Vzbid0IGZhbGwgYmFjayB0byBgbmV3IERhdGVgIGNvbnN0cnVjdG9yXG4gKiAgIGlmIGl0IGZhaWxzIHRvIHBhcnNlIGEgc3RyaW5nIGFyZ3VtZW50LiBJbnN0ZWFkLCBpdCByZXR1cm5zIGBJbnZhbGlkIERhdGVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdFxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgc3RyaW5nICcyMDE0LTAyLTExVDExOjMwOjMwJyB0byBkYXRlOlxuICogdmFyIHJlc3VsdCA9IHBhcnNlSVNPKCcyMDE0LTAyLTExVDExOjMwOjMwJylcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgc3RyaW5nICcrMDIwMTQxMDEnIHRvIGRhdGUsXG4gKiAvLyBpZiB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdCBpcyAxOlxuICogdmFyIHJlc3VsdCA9IHBhcnNlSVNPKCcrMDIwMTQxMDEnLCB7IGFkZGl0aW9uYWxEaWdpdHM6IDEgfSlcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VJU08oYXJndW1lbnQsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09IG51bGwgPyBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIDogdG9JbnRlZ2VyJDEob3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzKTtcblxuICBpZiAoYWRkaXRpb25hbERpZ2l0cyAhPT0gMiAmJiBhZGRpdGlvbmFsRGlnaXRzICE9PSAxICYmIGFkZGl0aW9uYWxEaWdpdHMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYWRkaXRpb25hbERpZ2l0cyBtdXN0IGJlIDAsIDEgb3IgMicpO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBTdHJpbmddJykpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHZhciBkYXRlU3RyaW5ncyA9IHNwbGl0RGF0ZVN0cmluZyhhcmd1bWVudCk7XG4gIHZhciBkYXRlO1xuXG4gIGlmIChkYXRlU3RyaW5ncy5kYXRlKSB7XG4gICAgdmFyIHBhcnNlWWVhclJlc3VsdCA9IHBhcnNlWWVhcihkYXRlU3RyaW5ncy5kYXRlLCBhZGRpdGlvbmFsRGlnaXRzKTtcbiAgICBkYXRlID0gcGFyc2VEYXRlKHBhcnNlWWVhclJlc3VsdC5yZXN0RGF0ZVN0cmluZywgcGFyc2VZZWFyUmVzdWx0LnllYXIpO1xuICB9XG5cbiAgaWYgKGlzTmFOKGRhdGUpIHx8ICFkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gIHZhciB0aW1lID0gMDtcbiAgdmFyIG9mZnNldDtcblxuICBpZiAoZGF0ZVN0cmluZ3MudGltZSkge1xuICAgIHRpbWUgPSBwYXJzZVRpbWUoZGF0ZVN0cmluZ3MudGltZSk7XG5cbiAgICBpZiAoaXNOYU4odGltZSkgfHwgdGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGVTdHJpbmdzLnRpbWV6b25lKSB7XG4gICAgb2Zmc2V0ID0gcGFyc2VUaW1lem9uZShkYXRlU3RyaW5ncy50aW1lem9uZSk7XG5cbiAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBmdWxsVGltZSA9IHRpbWVzdGFtcCArIHRpbWU7XG4gICAgdmFyIGZ1bGxUaW1lRGF0ZSA9IG5ldyBEYXRlKGZ1bGxUaW1lKTtcbiAgICBvZmZzZXQgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGZ1bGxUaW1lRGF0ZSk7IC8vIEFkanVzdCB0aW1lIHdoZW4gaXQncyBjb21pbmcgZnJvbSBEU1RcblxuICAgIHZhciBmdWxsVGltZURhdGVOZXh0RGF5ID0gbmV3IERhdGUoZnVsbFRpbWUpO1xuICAgIGZ1bGxUaW1lRGF0ZU5leHREYXkuc2V0RGF0ZShmdWxsVGltZURhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgdmFyIG9mZnNldERpZmYgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGZ1bGxUaW1lRGF0ZU5leHREYXkpIC0gb2Zmc2V0O1xuXG4gICAgaWYgKG9mZnNldERpZmYgPiAwKSB7XG4gICAgICBvZmZzZXQgKz0gb2Zmc2V0RGlmZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0RGF0ZVN0cmluZyhkYXRlU3RyaW5nKSB7XG4gIHZhciBkYXRlU3RyaW5ncyA9IHt9O1xuICB2YXIgYXJyYXkgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLmRhdGVUaW1lRGVsaW1pdGVyKTtcbiAgdmFyIHRpbWVTdHJpbmc7XG5cbiAgaWYgKC86Ly50ZXN0KGFycmF5WzBdKSkge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBudWxsO1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gYXJyYXlbMF07XG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdO1xuXG4gICAgaWYgKHBhdHRlcm5zLnRpbWVab25lRGVsaW1pdGVyLnRlc3QoZGF0ZVN0cmluZ3MuZGF0ZSkpIHtcbiAgICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLnRpbWVab25lRGVsaW1pdGVyKVswXTtcbiAgICAgIHRpbWVTdHJpbmcgPSBkYXRlU3RyaW5nLnN1YnN0cihkYXRlU3RyaW5ncy5kYXRlLmxlbmd0aCwgZGF0ZVN0cmluZy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lU3RyaW5nKSB7XG4gICAgdmFyIHRva2VuID0gcGF0dGVybnMudGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpO1xuICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSB0b2tlblsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdeKD86KFxcXFxkezR9fFsrLV1cXFxcZHsnICsgKDQgKyBhZGRpdGlvbmFsRGlnaXRzKSArICd9KXwoXFxcXGR7Mn18WystXVxcXFxkeycgKyAoMiArIGFkZGl0aW9uYWxEaWdpdHMpICsgJ30pJCknKTtcbiAgdmFyIGNhcHR1cmVzID0gZGF0ZVN0cmluZy5tYXRjaChyZWdleCk7IC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG5cbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIHtcbiAgICB5ZWFyOiBudWxsXG4gIH07XG4gIHZhciB5ZWFyID0gY2FwdHVyZXNbMV0gJiYgcGFyc2VJbnQoY2FwdHVyZXNbMV0pO1xuICB2YXIgY2VudHVyeSA9IGNhcHR1cmVzWzJdICYmIHBhcnNlSW50KGNhcHR1cmVzWzJdKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBjZW50dXJ5ID09IG51bGwgPyB5ZWFyIDogY2VudHVyeSAqIDEwMCxcbiAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZSgoY2FwdHVyZXNbMV0gfHwgY2FwdHVyZXNbMl0pLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHJpbmcsIHllYXIpIHtcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcbiAgaWYgKHllYXIgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgY2FwdHVyZXMgPSBkYXRlU3RyaW5nLm1hdGNoKGRhdGVSZWdleCk7IC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCBzdHJpbmdcblxuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gbnVsbDtcbiAgdmFyIGlzV2Vla0RhdGUgPSAhIWNhcHR1cmVzWzRdO1xuICB2YXIgZGF5T2ZZZWFyID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1sxXSk7XG4gIHZhciBtb250aCA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbMl0pIC0gMTtcbiAgdmFyIGRheSA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbM10pO1xuICB2YXIgd2VlayA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbNF0pO1xuICB2YXIgZGF5T2ZXZWVrID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1s1XSkgLSAxO1xuXG4gIGlmIChpc1dlZWtEYXRlKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWssIGRheU9mV2VlaykpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWssIGRheU9mV2Vlayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcblxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXkpIHx8ICF2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBtb250aCwgTWF0aC5tYXgoZGF5T2ZZZWFyLCBkYXkpKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZURhdGVVbml0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHBhcnNlSW50KHZhbHVlKSA6IDE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSh0aW1lU3RyaW5nKSB7XG4gIHZhciBjYXB0dXJlcyA9IHRpbWVTdHJpbmcubWF0Y2godGltZVJlZ2V4KTtcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB0aW1lXG5cbiAgdmFyIGhvdXJzID0gcGFyc2VUaW1lVW5pdChjYXB0dXJlc1sxXSk7XG4gIHZhciBtaW51dGVzID0gcGFyc2VUaW1lVW5pdChjYXB0dXJlc1syXSk7XG4gIHZhciBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdChjYXB0dXJlc1szXSk7XG5cbiAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHJldHVybiBob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSJDEgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQyICsgc2Vjb25kcyAqIDEwMDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZSgnLCcsICcuJykpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmUodGltZXpvbmVTdHJpbmcpIHtcbiAgaWYgKHRpbWV6b25lU3RyaW5nID09PSAnWicpIHJldHVybiAwO1xuICB2YXIgY2FwdHVyZXMgPSB0aW1lem9uZVN0cmluZy5tYXRjaCh0aW1lem9uZVJlZ2V4KTtcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIDA7XG4gIHZhciBzaWduID0gY2FwdHVyZXNbMV0gPT09ICcrJyA/IC0xIDogMTtcbiAgdmFyIGhvdXJzID0gcGFyc2VJbnQoY2FwdHVyZXNbMl0pO1xuICB2YXIgbWludXRlcyA9IGNhcHR1cmVzWzNdICYmIHBhcnNlSW50KGNhcHR1cmVzWzNdKSB8fCAwO1xuXG4gIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycywgbWludXRlcykpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiAoaG91cnMgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiQxICsgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMik7XG59XG5cbmZ1bmN0aW9uIGRheU9mSVNPV2Vla1llYXIoaXNvV2Vla1llYXIsIHdlZWssIGRheSkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGlzb1dlZWtZZWFyLCAwLCA0KTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgdmFyIGRpZmYgPSAod2VlayAtIDEpICogNyArIGRheSArIDEgLSBmb3VydGhPZkphbnVhcnlEYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZTtcbn0gLy8gVmFsaWRhdGlvbiBmdW5jdGlvbnNcbi8vIEZlYnJ1YXJ5IGlzIG51bGwgdG8gaGFuZGxlIHRoZSBsZWFwIHllYXIgKHVzaW5nIHx8KVxuXG5cbnZhciBkYXlzSW5Nb250aHMgPSBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcblxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4JDEoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgcmV0dXJuIG1vbnRoID49IDAgJiYgbW9udGggPD0gMTEgJiYgZGF0ZSA+PSAxICYmIGRhdGUgPD0gKGRheXNJbk1vbnRoc1ttb250aF0gfHwgKGlzTGVhcFllYXJJbmRleCQxKHllYXIpID8gMjkgOiAyOCkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSB7XG4gIHJldHVybiBkYXlPZlllYXIgPj0gMSAmJiBkYXlPZlllYXIgPD0gKGlzTGVhcFllYXJJbmRleCQxKHllYXIpID8gMzY2IDogMzY1KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXZWVrRGF0ZShfeWVhciwgd2VlaywgZGF5KSB7XG4gIHJldHVybiB3ZWVrID49IDEgJiYgd2VlayA8PSA1MyAmJiBkYXkgPj0gMCAmJiBkYXkgPD0gNjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gIGlmIChob3VycyA9PT0gMjQpIHtcbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCAmJiBzZWNvbmRzID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHNlY29uZHMgPj0gMCAmJiBzZWNvbmRzIDwgNjAgJiYgbWludXRlcyA+PSAwICYmIG1pbnV0ZXMgPCA2MCAmJiBob3VycyA+PSAwICYmIGhvdXJzIDwgMjU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZXpvbmUoX2hvdXJzLCBtaW51dGVzKSB7XG4gIHJldHVybiBtaW51dGVzID49IDAgJiYgbWludXRlcyA8PSA1OTtcbn1cblxudmFyIHBhcnNlRGF0ZSQxID0gZnVuY3Rpb24gcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQpIHtcbiAgaWYgKGlzU3RyaW5nXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdCA/IHBhcnNlKHZhbHVlLCBmb3JtYXQsIG5ldyBEYXRlKCkpIDogcGFyc2VJU08odmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0RhdGUodmFsdWUpO1xuICB9XG59OyAvLyBXZSB3YW50IHRvIHNldCB0aGUgbWVzc2FnZXMgYSBzdXBlcmdsb2JhbCBzbyB0aGF0IGltcG9ydHMgYWNyb3NzIGZpbGVzXG4vLyByZWZlcmVuY2UgdGhlIHNhbWUgbWVzc2FnZXMgb2JqZWN0LlxuXG5cbnZhciBfZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwgfHwge307XG4vKipcbiAqIEdsb2JhbCB2YWxpZGF0aW9uIG1lc3NhZ2UgcmVnaXN0cnkuXG4gKi9cblxuXG52YXIgbWVzc2FnZXMgPSBfZ2xvYmFsLl9fdnVlbWNfdmFsaWRhdGlvbl9tZXNzYWdlcyA9IF9nbG9iYWwuX192dWVtY192YWxpZGF0aW9uX21lc3NhZ2VzIHx8IG5ldyAoXG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIGV2ZXJ5dGhpbmcgdG8gdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBbe1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuJGxvY2FsZSA9ICdlbi11cyc7XG4gICAgICB0aGlzLiRmYWxsYmFjayA9ICdlbi11cyc7XG4gICAgICB0aGlzLiRsb2NhbGVzID0ge307XG4gICAgICB0aGlzLnJlZ2lzdGVyKGVuX3VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbGUoX2xvY2FsZSkge1xuICAgICAgdGhpcy4kbG9jYWxlID0gdG9Mb3dlcl8xKF9sb2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsYW5ndWFnZSBwYWNrLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoYnVuZGxlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbG9jYWxlID0gdG9Mb3dlcl8xKGJ1bmRsZS5sb2NhbGUpO1xuICAgICAgZWFjaChnZXRfMShidW5kbGUsICdtZXNzYWdlcycsIHt9KSwgZnVuY3Rpb24gKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgICAgc2V0XzEoX3RoaXMuJGxvY2FsZXMsIFtsb2NhbGUsIG5hbWVdLCB0ZW1wbGF0ZV8xKG1lc3NhZ2UpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBvciBhZGRzIGEgbmV3IG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gbmFtZSBhbmQgb3B0aW9uYWwgbG9jYWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5hbWUsIGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICB2YXIgJHRlbXBsYXRlID0gaXNTdHJpbmdfMShmb3JtYXQpID8gdGVtcGxhdGVfMShmb3JtYXQpIDogZm9ybWF0OyAvLyBVc2UgdGhlIGdpdmVuIGxvY2FsZS5cblxuICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICBzZXRfMSh0aGlzLiRsb2NhbGVzLCBbbG9jYWxlLCBuYW1lXSwgJHRlbXBsYXRlKTsgLy8gT3RoZXJ3aXNlIHVzZSB0aGUgYWN0aXZlIGxvY2FsZS5cblxuICAgICAgfSBlbHNlIGlmICh0aGlzLiRsb2NhbGUpIHtcbiAgICAgICAgc2V0XzEodGhpcy4kbG9jYWxlcywgW3RoaXMuJGxvY2FsZSwgbmFtZV0sICR0ZW1wbGF0ZSk7IC8vIE90aGVyd2lzZSBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgbG9jYWxlLlxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRfMSh0aGlzLiRsb2NhbGVzLCBbdGhpcy4kZmFsbGJhY2ssIG5hbWVdLCAkdGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyBmb3IgYSBnaXZlbiBtZXNzYWdlIG5hbWUgYW5kIGNvbnRleHQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAvLyBBdHRlbXB0IHRvIGZpbmQgdGhlIG5hbWUgdXNpbmcgdGhlIGFjdGl2ZSBsb2NhbGUsIGZhbGxpbmcgYmFjayB0byB0aGVcbiAgICAgIC8vIGFjdGl2ZSBsb2NhbGUncyBsYW5ndWFnZSwgYW5kIGZpbmFsbHkgZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0LlxuICAgICAgdmFyIHRlbXBsYXRlID0gZ2V0XzEodGhpcy4kbG9jYWxlcywgW3RoaXMuJGxvY2FsZSwgbmFtZV0sIGdldF8xKHRoaXMuJGxvY2FsZXMsIFtzcGxpdF8xKHRoaXMuJGxvY2FsZSwgJy0nKVswXSwgbmFtZV0sIGdldF8xKHRoaXMuJGxvY2FsZXMsIFt0aGlzLiRmYWxsYmFjaywgbmFtZV0pKSk7IC8vIEZhbGwgYmFjayB0byBhIGJsYW5rIHN0cmluZyBzbyB0aGF0IHdlIGRvbid0IHBvdGVudGlhbGx5XG4gICAgICAvLyBsZWFrIG1lc3NhZ2UgbmFtZXMgb3IgY29udGV4dCBkYXRhIGludG8gdGhlIHRlbXBsYXRlLlxuXG5cbiAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGVtcGxhdGUoZGF0YSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9jbGFzcztcbn0oKSkoKTtcbi8qKlxuICogUnVsZSBoZWxwZXJzIGZvciBlYXN5IHZhbGlkYXRpb24uXG4gKiBUaGVzZSBjYW4gYWxsIGJlIHVzZWQgZGlyZWN0bHkgaW4gYSBtb2RlbCdzIHZhbGlkYXRpb24gY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCB7YXNjaWksIGxlbmd0aH0gZnJvbSAndnVlLW1jL3ZhbGlkYXRpb24nXG4gKlxuICogY2xhc3MgVXNlciBleHRlbmRzIE1vZGVsIHtcbiAqICAgICB2YWxpZGF0aW9uKCkge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgICAgcGFzc3dvcmQ6IGFzY2lpLmFuZChsZW5ndGgoNikpLFxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogfVxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2YWxpZGF0aW9uIHJ1bGUuXG4gKlxuICogUnVsZXMgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBjYW4gYmUgY2hhaW5lZCB3aXRoIGBvcmAgYW5kIGBhbmRgLlxuICogRm9yIGV4YW1wbGU6IGBydWxlQS5vcihydWxlQi5hbmQoUnVsZUMpKS5hbmQoUnVsZUQpYFxuICpcbiAqIFRoZSBlcnJvciBtZXNzYWdlIGNhbiBiZSBzZXQgb3IgcmVwbGFjZWQgdXNpbmcgYGZvcm1hdChtZXNzYWdlfHRlbXBsYXRlKWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzpcbiAqICAgICAtIG5hbWU6IE5hbWUgb2YgdGhlIGVycm9yIG1lc3NhZ2UuXG4gKiAgICAgLSBkYXRhOiBDb250ZXh0IGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqICAgICAtIHRlc3Q6IEZ1bmN0aW9uIGFjY2VwdGluZyAodmFsdWUsIG1vZGVsKSwgd2hpY2ggc2hvdWxkXG4gKiAgICAgICAgICAgICByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZC5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFZhbGlkYXRpb24gcnVsZS5cbiAqL1xuXG52YXIgcnVsZSA9IGZ1bmN0aW9uIHJ1bGUoY29uZmlnKSB7XG4gIHZhciBuYW1lID0gZ2V0XzEoY29uZmlnLCAnbmFtZScpO1xuXG4gIHZhciBkYXRhID0gZ2V0XzEoY29uZmlnLCAnZGF0YScsIHt9KTtcblxuICB2YXIgdGVzdCA9IGdldF8xKGNvbmZpZywgJ3Rlc3QnLCBzdHViVHJ1ZV8xKTtcbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdXNpbmcgdGhpcyBydWxlLlxuICAgKiBJdCBoYXMgc29tZSBleHRyYSBtZXRhZGF0YSB0byBhbGxvdyBydWxlIGNoYWluaW5nIGFuZCBjdXN0b20gZm9ybWF0cy5cbiAgICovXG5cblxuICB2YXIgJHJ1bGUgPSBmdW5jdGlvbiAkcnVsZSh2YWx1ZSwgYXR0cmlidXRlLCBtb2RlbCkge1xuICAgIC8vIGB0cnVlYCBpZiB0aGlzIHJ1bGUncyBjb3JlIGFjY2VwdGFuY2UgY3JpdGVyaWEgd2FzIG1ldC5cbiAgICB2YXIgdmFsaWQgPSB0ZXN0KHZhbHVlLCBhdHRyaWJ1dGUsIG1vZGVsKTsgLy8gSWYgdmFsaWQsIGNoZWNrIHRoYXQgYWxsIHJ1bGVzIGluIHRoZSBcImFuZFwiIGNoYWluIGFsc28gcGFzcy5cblxuICAgIGlmICh2YWxpZCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9ICRydWxlLl9hbmRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9hbmQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciByZXN1bHQgPSBfYW5kKHZhbHVlLCBhdHRyaWJ1dGUsIG1vZGVsKTsgLy8gSWYgYW55IG9mIHRoZSBjaGFpbmVkIHJ1bGVzIHJldHVybiBhIHN0cmluZywgd2Uga25vdyB0aGF0XG4gICAgICAgICAgLy8gdGhhdCBydWxlIGhhcyBmYWlsZWQsIGFuZCB0aGVyZWZvcmUgdGhpcyBjaGFpbiBpcyBpbnZhbGlkLlxuXG5cbiAgICAgICAgICBpZiAoaXNTdHJpbmdfMShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFaXRoZXIgdGhlcmUgd2VyZW4ndCBhbnkgXCJhbmRcIiBydWxlcyBvciB0aGV5IGFsbCBwYXNzZWQuXG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yW1wicmV0dXJuXCJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcltcInJldHVyblwiXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gVGhpcyBydWxlJ3MgYWNjZXB0YW5jZSBjcml0ZXJpYSB3YXMgbm90IG1ldCwgYnV0IHRoZXJlIGlzIGEgY2hhbmNlXG4gICAgICAvLyB0aGF0IGEgcnVsZSBpbiB0aGUgXCJvclwiIGNoYWluJ3MgbWlnaHQgcGFzcy5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSAkcnVsZS5fb3JbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX29yID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9yZXN1bHQgPSBfb3IodmFsdWUsIGF0dHJpYnV0ZSwgbW9kZWwpOyAvLyBBIHJ1bGUgc2hvdWxkIGVpdGhlciByZXR1cm4gdHJ1ZSBpbiB0aGUgZXZlbnQgb2YgYSBnZW5lcmFsXG4gICAgICAgICAgLy8gXCJwYXNzXCIsIG9yIG5vdGhpbmcgYXQgYWxsLiBBIGZhaWx1cmUgd291bGQgaGF2ZSB0byBiZSBhXG4gICAgICAgICAgLy8gc3RyaW5nIG1lc3NhZ2UgKHVzdWFsbHkgZnJvbSBhbm90aGVyIHJ1bGUpLlxuXG5cbiAgICAgICAgICBpZiAoX3Jlc3VsdCA9PT0gdHJ1ZSB8fCBpc1VuZGVmaW5lZF8xKF9yZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMltcInJldHVyblwiXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyW1wicmV0dXJuXCJdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEF0IHRoaXMgcG9pbnQgd2Ugd2FudCB0byByZXBvcnQgdGhhdCB0aGlzIHJ1bGUgaGFzIGZhaWxlZCwgYmVjYXVzZVxuICAgIC8vIG5vbmUgb2YgdGhlIFwiYW5kXCIgb3IgXCJvclwiIGNoYWlucyBwYXNzZWQgZWl0aGVyLlxuICAgIC8vIEFkZCB0aGUgaW52YWxpZCB2YWx1ZSB0byB0aGUgbWVzc2FnZSBjb250ZXh0LCB3aGljaCBpcyBtYWRlIGF2YWlsYWJsZVxuICAgIC8vIHRvIGFsbCBydWxlcyBieSBkZWZhdWx0LiBUaGlzIGFsbG93cyBmb3IgJHt2YWx1ZX0gaW50ZXJwb2xhdGlvbi5cblxuXG4gICAgYXNzaWduXzEoZGF0YSwge1xuICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTsgLy8gVGhpcyB3b3VsZCBiZSBhIGN1c3RvbSBmb3JtYXQgZXhwbGljaXRseSBzZXQgb24gdGhpcyBydWxlLlxuXG4gICAgdmFyIGZvcm1hdCA9IGdldF8xKCRydWxlLCAnX2Zvcm1hdCcpOyAvLyBVc2UgdGhlIGRlZmF1bHQgbWVzc2FnZSBpZiBhbiBleHBsaWNpdCBmb3JtYXQgaXNuJ3Qgc2V0LlxuXG5cbiAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzLmdldChuYW1lLCBkYXRhKTtcbiAgICB9IC8vIFJlcGxhY2UgdGhlIGN1c3RvbSBmb3JtYXQgd2l0aCBhIHRlbXBsYXRlIGlmIGl0J3Mgc3RpbGwgYSBzdHJpbmcuXG5cblxuICAgIGlmIChpc1N0cmluZ18xKGZvcm1hdCkpIHtcbiAgICAgICRydWxlLl9mb3JtYXQgPSBmb3JtYXQgPSB0ZW1wbGF0ZV8xKGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChkYXRhKTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBjb3B5IG9mIHRoaXMgcnVsZSwgc28gdGhhdCBhcHBlbmRpbmcgdG8gYSBjaGFpbiBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcgYSBjdXN0b20gZm9ybWF0IGRvZXNuJ3QgbW9kaWZ5IHRoZSBiYXNlIHJ1bGUuXG4gICAqL1xuXG5cbiAgJHJ1bGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXNzaWduXzEocnVsZSh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdGVzdDogdGVzdCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgcGlja18xKCRydWxlLCBbJ19mb3JtYXQnLCAnX2FuZCcsICdfb3InXSkpO1xuICB9O1xuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIGZvcm1hdCBvbiB0aGlzIHJ1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBmb3JtYXRcbiAgICovXG5cblxuICAkcnVsZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFzc2lnbl8xKCRydWxlLmNvcHkoKSwge1xuICAgICAgX2Zvcm1hdDogZm9ybWF0XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgcnVsZSBvciBmdW5jdGlvbiB0byB0aGlzIHJ1bGUncyBPUiBjaGFpbi4gSWYgdGhlIGdpdmVuIHJ1bGVcbiAgICogcGFzc2VzIHdoZW4gdGhpcyBvbmUgZmFpbHMsIHRoaXMgcnVsZSB3aWxsIHJldHVybiBgdHJ1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gcnVsZXMgT25lIG9yIG1vcmUgZnVuY3Rpb25zIHRvIGFkZCB0byB0aGUgY2hhaW4uXG4gICAqL1xuXG5cbiAgJHJ1bGUub3IgPSBmdW5jdGlvbiAocnVsZXMpIHtcbiAgICByZXR1cm4gYXNzaWduXzEoJHJ1bGUuY29weSgpLCB7XG4gICAgICBfb3I6IGNvbmNhdF8xKCRydWxlLl9vciwgcnVsZXMpXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgcnVsZSBvciBmdW5jdGlvbiB0byB0aGlzIHJ1bGUncyBBTkQgY2hhaW4uIElmIHRoZSBnaXZlbiBydWxlXG4gICAqIGZhaWxzIHdoZW4gdGhpcyBvbmUgcGFzc2VzLCB0aGlzIHJ1bGUgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfSBydWxlcyBPbmUgb3IgbW9yZSBmdW5jdGlvbnMgdG8gYWRkIHRvIHRoZSBjaGFpbi5cbiAgICovXG5cblxuICAkcnVsZS5hbmQgPSBmdW5jdGlvbiAocnVsZXMpIHtcbiAgICByZXR1cm4gYXNzaWduXzEoJHJ1bGUuY29weSgpLCB7XG4gICAgICBfYW5kOiBjb25jYXRfMSgkcnVsZS5fYW5kLCBydWxlcylcbiAgICB9KTtcbiAgfTtcblxuICAkcnVsZS5fYW5kID0gW107IC8vIFwiYW5kXCIgY2hhaW5cblxuICAkcnVsZS5fb3IgPSBbXTsgLy8gXCJvclwiIGNoYWluXG5cbiAgJHJ1bGUuX2Zvcm1hdCA9IG51bGw7IC8vIEN1c3RvbSBmb3JtYXRcblxuICByZXR1cm4gJHJ1bGU7XG59O1xuLyoqXG4gKiBBVkFJTEFCTEUgUlVMRVNcbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYWZ0ZXIgYSBnaXZlbiBkYXRlIHN0cmluZyBvciBgRGF0ZWAgb2JqZWN0LlxuICovXG5cbnZhciBhZnRlciA9IGZ1bmN0aW9uIGFmdGVyKGRhdGUpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdhZnRlcicsXG4gICAgZGF0YToge1xuICAgICAgZGF0ZTogZGF0ZVxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQWZ0ZXIocGFyc2VEYXRlJDEodmFsdWUpLCBwYXJzZURhdGUkMShkYXRlKSk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIG9ubHkgaGFzIGxldHRlcnMuXG4gKi9cblxudmFyIGFscGhhID0gcnVsZSh7XG4gIG5hbWU6ICdhbHBoYScsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNBbHBoYShkZWJ1cnJfMSh2YWx1ZSkpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgb25seSBoYXMgbGV0dGVycyBvciBudW1iZXJzLlxuICovXG5cbnZhciBhbHBoYW51bWVyaWMgPSBydWxlKHtcbiAgbmFtZTogJ2FscGhhbnVtZXJpYycsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNBbHBoYW51bWVyaWMoZGVidXJyXzEodmFsdWUpKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGFuIGFycmF5LlxuICovXG5cbnZhciBhcnJheSA9IHJ1bGUoe1xuICBuYW1lOiAnYXJyYXknLFxuICB0ZXN0OiBpc0FycmF5XzFcbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyBjb25zaXN0aW5nIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycy5cbiAqL1xuXG52YXIgYXNjaWkgPSBydWxlKHtcbiAgbmFtZTogJ2FzY2lpJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiAvXltcXHgwMC1cXHg3Rl0rJC8udGVzdCh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIEJhc2U2NCBzdHJpbmcuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJ1bGUoe1xuICBuYW1lOiAnYmFzZTY0JyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0Jhc2U2NCh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBiZWZvcmUgYSBnaXZlbiBkYXRlIHN0cmluZyBvciBgRGF0ZWAgb2JqZWN0LlxuICovXG5cbnZhciBiZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoZGF0ZSkge1xuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2JlZm9yZScsXG4gICAgZGF0YToge1xuICAgICAgZGF0ZTogZGF0ZVxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQmVmb3JlKHBhcnNlRGF0ZSQxKHZhbHVlKSwgcGFyc2VEYXRlJDEoZGF0ZSkpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBiZXR3ZWVuIGEgZ2l2ZW4gbWluaW11bSBvciBtYXhpbXVtLCBpbmNsdXNpdmUgYnkgZGVmYXVsdC5cbiAqL1xuXG52YXIgYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4obWluLCBtYXgpIHtcbiAgdmFyIGluY2x1c2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICB2YXIgX21pbiA9ICsoaXNTdHJpbmdfMShtaW4pID8gcGFyc2VEYXRlJDEobWluKSA6IG1pbik7XG5cbiAgdmFyIF9tYXggPSArKGlzU3RyaW5nXzEobWF4KSA/IHBhcnNlRGF0ZSQxKG1heCkgOiBtYXgpO1xuXG4gIHJldHVybiBydWxlKHtcbiAgICBkYXRhOiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfSxcbiAgICBuYW1lOiBpbmNsdXNpdmUgPyAnYmV0d2Vlbl9pbmNsdXNpdmUnIDogJ2JldHdlZW4nLFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHZhciBfdmFsdWUgPSArKGlzU3RyaW5nXzEodmFsdWUpID8gcGFyc2VEYXRlJDEodmFsdWUpIDogdmFsdWUpO1xuXG4gICAgICByZXR1cm4gaW5jbHVzaXZlID8gZ3RlXzEoX3ZhbHVlLCBfbWluKSAmJiBsdGVfMShfdmFsdWUsIF9tYXgpIDogZ3RfMShfdmFsdWUsIF9taW4pICYmIGx0XzEoX3ZhbHVlLCBfbWF4KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSBib29sZWFuIChzdHJpY3RseSB0cnVlIG9yIGZhbHNlKS5cbiAqL1xuXG52YXIgX2Jvb2xlYW4gPSBydWxlKHtcbiAgbmFtZTogJ2Jvb2xlYW4nLFxuICB0ZXN0OiBpc0Jvb2xlYW5fMVxufSk7XG52YXIgY3JlZGl0Y2FyZCA9IHJ1bGUoe1xuICBuYW1lOiAnY3JlZGl0Y2FyZCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNDcmVkaXRDYXJkKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIHBhcnNlYWJsZSBhcyBhIGRhdGUuXG4gKi9cblxudmFyIGRhdGUgPSBydWxlKHtcbiAgbmFtZTogJ2RhdGUnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQocGFyc2VEYXRlJDEodmFsdWUpKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIG1hdGNoZXMgdGhlIGdpdmVuIGRhdGUgZm9ybWF0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kYXRlLWZucy5vcmcvdjIuMC4wLWFscGhhLjkvZG9jcy9mb3JtYXRcbiAqL1xuXG52YXIgZGF0ZWZvcm1hdCA9IGZ1bmN0aW9uIGRhdGVmb3JtYXQoZm9ybWF0JDEpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdkYXRlZm9ybWF0JyxcbiAgICBkYXRhOiB7XG4gICAgICBmb3JtYXQ6IGZvcm1hdCQxXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZChwYXJzZURhdGUkMSh2YWx1ZS50b1N0cmluZygpLCBmb3JtYXQkMSkpICYmIGZvcm1hdChwYXJzZURhdGUkMSh2YWx1ZS50b1N0cmluZygpLCBmb3JtYXQkMSksIGZvcm1hdCQxKSA9PT0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgXG4gKi9cblxudmFyIGRlZmluZWQgPSBydWxlKHtcbiAgbmFtZTogJ2RlZmluZWQnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZF8xKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAqL1xuXG52YXIgZW1haWwgPSBydWxlKHtcbiAgbmFtZTogJ2VtYWlsJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0VtYWlsKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiB2YWx1ZSBpcyBjb25zaWRlcmVkIGVtcHR5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvI2lzRW1wdHlcbiAqL1xuXG52YXIgZW1wdHkgPSBydWxlKHtcbiAgbmFtZTogJ2VtcHR5JyxcbiAgdGVzdDogaXNFbXB0eV8xXG59KTtcbi8qKlxuICogQWxpYXMgZm9yIGBlcXVhbHNgXG4gKi9cblxudmFyIGVxdWFsID0gZnVuY3Rpb24gZXF1YWwob3RoZXIpIHtcbiAgcmV0dXJuIGVxdWFscyhvdGhlcik7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBlcXVhbHMgdGhlIGdpdmVuIHZhbHVlLlxuICovXG5cbnZhciBlcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdlcXVhbHMnLFxuICAgIGRhdGE6IHtcbiAgICAgIG90aGVyOiBvdGhlclxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzRXF1YWxfMSh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gYSBnaXZlbiBtaW5pbXVtLlxuICovXG5cbnZhciBndCQxID0gZnVuY3Rpb24gZ3QobWluKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnZ3QnLFxuICAgIGRhdGE6IHtcbiAgICAgIG1pbjogbWluXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ3RfMSh2YWx1ZSwgbWluKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGEgZ2l2ZW4gbWluaW11bS5cbiAqL1xuXG52YXIgZ3RlJDEgPSBmdW5jdGlvbiBndGUobWluKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnZ3RlJyxcbiAgICBkYXRhOiB7XG4gICAgICBtaW46IG1pblxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGd0ZV8xKHZhbHVlLCBtaW4pO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICovXG5cbnZhciBpbnRlZ2VyID0gcnVsZSh7XG4gIG5hbWU6ICdpbnRlZ2VyJyxcbiAgdGVzdDogaXNJbnRlZ2VyXzFcbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIElQIGFkZHJlc3MuXG4gKi9cblxudmFyIGlwID0gcnVsZSh7XG4gIG5hbWU6ICdpcCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNJUCh2YWx1ZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHplcm8tbGVuZ3RoIHN0cmluZy5cbiAqL1xuXG52YXIgaXNibGFuayA9IHJ1bGUoe1xuICBuYW1lOiAnaXNibGFuaycsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICovXG5cbnZhciBpc25pbCA9IHJ1bGUoe1xuICBuYW1lOiAnaXNuaWwnLFxuICB0ZXN0OiBpc05pbF8xXG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYG51bGxgLlxuICovXG5cbnZhciBpc251bGwgPSBydWxlKHtcbiAgbmFtZTogJ2lzbnVsbCcsXG4gIHRlc3Q6IGlzTnVsbF8xXG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBJU084NjAxIGRhdGUgc3RyaW5nLlxuICovXG5cbnZhciBpc284NjAxID0gcnVsZSh7XG4gIG5hbWU6ICdpc284NjAxJyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHZhbHVlKSAmJiBpc0lTTzg2MDEodmFsdWUpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgdmFsaWQgSlNPTi5cbiAqL1xuXG52YXIganNvbiA9IHJ1bGUoe1xuICBuYW1lOiAnanNvbicsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNKU09OKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlJ3MgbGVuZ3RoIGlzIGF0IGxlYXN0IGEgZ2l2ZW4gbWluaW11bSwgYW5kIG5vIG1vcmUgdGhhbiBhblxuICogb3B0aW9uYWwgbWF4aW11bS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzLyN0b0xlbmd0aFxuICovXG5cbnZhciBsZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgobWluLCBtYXgpIHtcbiAgLy8gTm8gbWF4aW11bSBtZWFucyB0aGUgdmFsdWUgbXVzdCBiZSAqYXQgbGVhc3QqIHRoZSBtaW5pbXVtLlxuICBpZiAoaXNVbmRlZmluZWRfMShtYXgpKSB7XG4gICAgcmV0dXJuIHJ1bGUoe1xuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heFxuICAgICAgfSxcbiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNpemVfMSh2YWx1ZSkgPj0gbWluO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIE1pbmltdW0gYW5kIG1heGltdW0gZ2l2ZW4sIHNvIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIHdpdGhpbiB0aGUgcmFuZ2UuXG5cblxuICByZXR1cm4gcnVsZSh7XG4gICAgbmFtZTogJ2xlbmd0aF9iZXR3ZWVuJyxcbiAgICBkYXRhOiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gc2l6ZV8xKHZhbHVlKTtcbiAgICAgIHJldHVybiBsZW5ndGggPj0gbWluICYmIGxlbmd0aCA8PSBtYXg7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGxlc3MgdGhhbiBhIGdpdmVuIG1heGltdW0uXG4gKi9cblxudmFyIGx0JDEgPSBmdW5jdGlvbiBsdChtYXgpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdsdCcsXG4gICAgZGF0YToge1xuICAgICAgbWF4OiBtYXhcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBsdF8xKHZhbHVlLCBtYXgpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYSBnaXZlbiBtYXhpbXVtLlxuICovXG5cbnZhciBsdGUkMSA9IGZ1bmN0aW9uIGx0ZShtYXgpIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdsdGUnLFxuICAgIGRhdGE6IHtcbiAgICAgIG1heDogbWF4XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gbHRlXzEodmFsdWUsIG1heCk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIG9yIFJlZ0V4cC5cbiAqL1xuXG52YXIgbWF0Y2gkMSA9IGZ1bmN0aW9uIG1hdGNoKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHJ1bGUoe1xuICAgIG5hbWU6ICdtYXRjaCcsXG4gICAgZGF0YToge1xuICAgICAgcGF0dGVybjogcGF0dGVyblxuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybikudGVzdCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIEFsaWFzIGZvciBgbHRlYC5cbiAqL1xuXG52YXIgbWF4ID0gZnVuY3Rpb24gbWF4KF9tYXgyKSB7XG4gIHJldHVybiBsdGUkMShfbWF4Mik7XG59O1xuLyoqXG4gKiBBbGlhcyBmb3IgYGd0ZWAuXG4gKi9cblxudmFyIG1pbiA9IGZ1bmN0aW9uIG1pbihfbWluMikge1xuICByZXR1cm4gZ3RlJDEoX21pbjIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgbmVnYXRpdmUuXG4gKi9cblxudmFyIG5lZ2F0aXZlID0gcnVsZSh7XG4gIG5hbWU6ICduZWdhdGl2ZScsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdG9OdW1iZXJfMSh2YWx1ZSkgPCAwO1xuICB9XG59KTtcbi8qKlxuICpcbiAqL1xuXG52YXIgbm90ID0gZnVuY3Rpb24gbm90KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnbm90JyxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gIWluY2x1ZGVzXzEodmFsdWVzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIChpbnRlZ2VyIG9yIGZsb2F0KSwgZXhjbHVkaW5nIGBOYU5gLlxuICovXG5cbnZhciBudW1iZXIgPSBydWxlKHtcbiAgbmFtZTogJ251bWJlcicsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gX2lzRmluaXRlKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9yIG51bWVyaWMgc3RyaW5nLCBleGNsdWRpbmcgYE5hTmAuXG4gKi9cblxudmFyIG51bWVyaWMgPSBydWxlKHtcbiAgbmFtZTogJ251bWVyaWMnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyXzEodmFsdWUpICYmICFfaXNOYU4odmFsdWUpIHx8IHZhbHVlICYmIGlzU3RyaW5nXzEodmFsdWUpICYmICFfaXNOYU4odG9OdW1iZXJfMSh2YWx1ZSkpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYW4gb2JqZWN0LCBleGNsdWRpbmcgYXJyYXlzIGFuZCBmdW5jdGlvbnMuXG4gKi9cblxudmFyIG9iamVjdCA9IHJ1bGUoe1xuICBuYW1lOiAnb2JqZWN0JyxcbiAgdGVzdDogZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdF8xKHZhbHVlKSAmJiAhaXNBcnJheV8xKHZhbHVlKSAmJiAhaXNGdW5jdGlvbl8xKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIHBvc2l0aXZlLlxuICovXG5cbnZhciBwb3NpdGl2ZSA9IHJ1bGUoe1xuICBuYW1lOiAncG9zaXRpdmUnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyXzEodmFsdWUpID4gMDtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIHByZXNlbnQsIGllLiBub3QgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3IgYSBibGFuayBzdHJpbmcuXG4gKi9cblxudmFyIHJlcXVpcmVkID0gcnVsZSh7XG4gIG5hbWU6ICdyZXF1aXJlZCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gIShpc05pbF8xKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpO1xuICB9XG59KTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgZXF1YWxzIGFub3RoZXIgYXR0cmlidXRlJ3MgdmFsdWUuXG4gKi9cblxudmFyIHNhbWUgPSBmdW5jdGlvbiBzYW1lKG90aGVyKSB7XG4gIHJldHVybiBydWxlKHtcbiAgICBuYW1lOiAnc2FtZScsXG4gICAgZGF0YToge1xuICAgICAgb3RoZXI6IG90aGVyXG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlLCBhdHRyaWJ1dGUsIG1vZGVsKSB7XG4gICAgICByZXR1cm4gaXNFcXVhbF8xKHZhbHVlLCBtb2RlbC5nZXQob3RoZXIpKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cblxudmFyIHN0cmluZyA9IHJ1bGUoe1xuICBuYW1lOiAnc3RyaW5nJyxcbiAgdGVzdDogaXNTdHJpbmdfMVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgVVJMIHN0cmluZy5cbiAqL1xuXG52YXIgdXJsID0gcnVsZSh7XG4gIG5hbWU6ICd1cmwnLFxuICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodmFsdWUpICYmIGlzVVJMKHZhbHVlKTtcbiAgfVxufSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgVVVJRC5cbiAqL1xuXG52YXIgdXVpZCA9IHJ1bGUoe1xuICBuYW1lOiAndXVpZCcsXG4gIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh2YWx1ZSkgJiYgaXNVVUlEKHZhbHVlKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuYWZ0ZXIgPSBhZnRlcjtcbmV4cG9ydHMuYWxwaGEgPSBhbHBoYTtcbmV4cG9ydHMuYWxwaGFudW1lcmljID0gYWxwaGFudW1lcmljO1xuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZXhwb3J0cy5hc2NpaSA9IGFzY2lpO1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG5leHBvcnRzLmJlZm9yZSA9IGJlZm9yZTtcbmV4cG9ydHMuYmV0d2VlbiA9IGJldHdlZW47XG5leHBvcnRzLmJvb2xlYW4gPSBfYm9vbGVhbjtcbmV4cG9ydHMuY3JlZGl0Y2FyZCA9IGNyZWRpdGNhcmQ7XG5leHBvcnRzLmRhdGUgPSBkYXRlO1xuZXhwb3J0cy5kYXRlZm9ybWF0ID0gZGF0ZWZvcm1hdDtcbmV4cG9ydHMuZGVmaW5lZCA9IGRlZmluZWQ7XG5leHBvcnRzLmVtYWlsID0gZW1haWw7XG5leHBvcnRzLmVtcHR5ID0gZW1wdHk7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZ3QgPSBndCQxO1xuZXhwb3J0cy5ndGUgPSBndGUkMTtcbmV4cG9ydHMuaW50ZWdlciA9IGludGVnZXI7XG5leHBvcnRzLmlwID0gaXA7XG5leHBvcnRzLmlzYmxhbmsgPSBpc2JsYW5rO1xuZXhwb3J0cy5pc25pbCA9IGlzbmlsO1xuZXhwb3J0cy5pc251bGwgPSBpc251bGw7XG5leHBvcnRzLmlzbzg2MDEgPSBpc284NjAxO1xuZXhwb3J0cy5qc29uID0ganNvbjtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sdCA9IGx0JDE7XG5leHBvcnRzLmx0ZSA9IGx0ZSQxO1xuZXhwb3J0cy5tYXRjaCA9IG1hdGNoJDE7XG5leHBvcnRzLm1heCA9IG1heDtcbmV4cG9ydHMubWVzc2FnZXMgPSBtZXNzYWdlcztcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5uZWdhdGl2ZSA9IG5lZ2F0aXZlO1xuZXhwb3J0cy5ub3QgPSBub3Q7XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMubnVtZXJpYyA9IG51bWVyaWM7XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbmV4cG9ydHMucG9zaXRpdmUgPSBwb3NpdGl2ZTtcbmV4cG9ydHMucmVxdWlyZWQgPSByZXF1aXJlZDtcbmV4cG9ydHMucnVsZSA9IHJ1bGU7XG5leHBvcnRzLnNhbWUgPSBzYW1lO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5leHBvcnRzLnVybCA9IHVybDtcbmV4cG9ydHMudXVpZCA9IHV1aWQ7XG4iLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJlbl91cyIsImxvY2FsZSIsIm1lc3NhZ2VzIiwiYWZ0ZXIiLCJhbHBoYSIsImFscGhhbnVtZXJpYyIsImFycmF5IiwiYXNjaWkiLCJiYXNlNjQiLCJiZWZvcmUiLCJiZXR3ZWVuIiwiYmV0d2Vlbl9pbmNsdXNpdmUiLCJjcmVkaXRjYXJkIiwiZGF0ZSIsImRhdGVmb3JtYXQiLCJkZWZpbmVkIiwiZW1haWwiLCJlbXB0eSIsImVxdWFscyIsImd0IiwiZ3RlIiwiaW50ZWdlciIsImlwIiwiaXNibGFuayIsImlzbmlsIiwiaXNudWxsIiwiaXNvODYwMSIsImpzb24iLCJsZW5ndGhfYmV0d2VlbiIsImx0IiwibHRlIiwibWF0Y2giLCJuZWdhdGl2ZSIsIm5vdCIsIm51bWJlciIsIm51bWVyaWMiLCJvYmplY3QiLCJwb3NpdGl2ZSIsInJlcXVpcmVkIiwic2FtZSIsInN0cmluZyIsInVybCIsInV1aWQiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwidW53cmFwRXhwb3J0cyIsIngiLCJfX2VzTW9kdWxlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJmbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJhc3NlcnRTdHJpbmdfMSIsImFzc2VydFN0cmluZyIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJfdHlwZW9mMiIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImlzU3RyaW5nIiwiU3RyaW5nIiwiaW52YWxpZFR5cGUiLCJuYW1lIiwiY29uY2F0IiwiYWxwaGFfMSIsImNvbW1hRGVjaW1hbCIsImRvdERlY2ltYWwiLCJhcmFiaWNMb2NhbGVzIiwiZW5nbGlzaExvY2FsZXMiLCJkZWNpbWFsIiwiYXIiLCJfbG9jYWxlIiwiX2kiLCJfaTIiLCJfaTMiLCJpc0FscGhhXzEiLCJpc0FscGhhIiwibG9jYWxlcyIsIl9hc3NlcnRTdHJpbmciLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwic3RyIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidGVzdCIsIkVycm9yIiwia2V5cyIsImlzQWxwaGFudW1lcmljXzEiLCJpc0FscGhhbnVtZXJpYyIsImlzQmFzZTY0XzEiLCJpc0Jhc2U2NCIsIm5vdEJhc2U2NCIsImxlbiIsImZpcnN0UGFkZGluZ0NoYXIiLCJpbmRleE9mIiwiaXNDcmVkaXRDYXJkXzEiLCJpc0NyZWRpdENhcmQiLCJjcmVkaXRDYXJkIiwic2FuaXRpemVkIiwicmVwbGFjZSIsInN1bSIsImRpZ2l0IiwidG1wTnVtIiwic2hvdWxkRG91YmxlIiwic3Vic3RyaW5nIiwicGFyc2VJbnQiLCJtZXJnZV8xIiwibWVyZ2UiLCJkZWZhdWx0cyIsImlzQnl0ZUxlbmd0aF8xIiwiaXNCeXRlTGVuZ3RoIiwib3B0aW9ucyIsIm1pbiIsIm1heCIsImVuY29kZVVSSSIsInNwbGl0IiwiaXNGUUROXzEiLCJpc0ZRRE4iLCJfbWVyZ2UiLCJkZWZhdWx0X2ZxZG5fb3B0aW9ucyIsInJlcXVpcmVfdGxkIiwiYWxsb3dfdW5kZXJzY29yZXMiLCJhbGxvd190cmFpbGluZ19kb3QiLCJwYXJ0cyIsInRsZCIsInBvcCIsInBhcnQiLCJpc0lQXzEiLCJpc0lQIiwiaXB2NE1heWJlIiwiaXB2NkJsb2NrIiwidmVyc2lvbiIsInNvcnQiLCJhIiwiYiIsImJsb2NrcyIsImZvdW5kT21pc3Npb25CbG9jayIsImZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayIsImV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MiLCJzdWJzdHIiLCJzaGlmdCIsImlzRW1haWxfMSIsImlzRW1haWwiLCJfaXNCeXRlTGVuZ3RoIiwiX2lzRlFETiIsIl9pc0lQIiwiZGVmYXVsdF9lbWFpbF9vcHRpb25zIiwiYWxsb3dfZGlzcGxheV9uYW1lIiwicmVxdWlyZV9kaXNwbGF5X25hbWUiLCJhbGxvd191dGY4X2xvY2FsX3BhcnQiLCJkaXNwbGF5TmFtZSIsImVtYWlsVXNlclBhcnQiLCJnbWFpbFVzZXJQYXJ0IiwicXVvdGVkRW1haWxVc2VyIiwiZW1haWxVc2VyVXRmOFBhcnQiLCJxdW90ZWRFbWFpbFVzZXJVdGY4IiwiZGlzcGxheV9lbWFpbCIsImRvbWFpbiIsInVzZXIiLCJqb2luIiwibG93ZXJfZG9tYWluIiwidG9Mb3dlckNhc2UiLCJkb21haW5fc3BlY2lmaWNfdmFsaWRhdGlvbiIsInVzZXJuYW1lIiwiX3VzZXJfcGFydHMiLCJhbGxvd19pcF9kb21haW4iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJub0JyYWNrZXRkb21haW4iLCJzbGljZSIsInBhdHRlcm4iLCJ1c2VyX3BhcnRzIiwiaXNJU084NjAxXzEiLCJpc0lTTzg2MDEiLCJpc1ZhbGlkRGF0ZSIsIm9yZGluYWxNYXRjaCIsIm9ZZWFyIiwiTnVtYmVyIiwib0RheSIsIm1hcCIsInllYXIiLCJtb250aCIsImRheSIsIm1vbnRoU3RyaW5nIiwiZGF5U3RyaW5nIiwiZCIsIkRhdGUiLCJpc05hTiIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiY2hlY2siLCJzdHJpY3QiLCJpc0pTT05fMSIsImlzSlNPTiIsIkpTT04iLCJwYXJzZSIsImUiLCJpc1VSTF8xIiwiaXNVUkwiLCJkZWZhdWx0X3VybF9vcHRpb25zIiwicHJvdG9jb2xzIiwicmVxdWlyZV9wcm90b2NvbCIsInJlcXVpcmVfaG9zdCIsInJlcXVpcmVfdmFsaWRfcHJvdG9jb2wiLCJhbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzIiwid3JhcHBlZF9pcHY2IiwiaXNSZWdFeHAiLCJ0b1N0cmluZyIsImNoZWNrSG9zdCIsImhvc3QiLCJtYXRjaGVzIiwicHJvdG9jb2wiLCJhdXRoIiwiaG9zdG5hbWUiLCJwb3J0IiwicG9ydF9zdHIiLCJpcHY2IiwiZGlzYWxsb3dfYXV0aCIsImlwdjZfbWF0Y2giLCJob3N0X3doaXRlbGlzdCIsImhvc3RfYmxhY2tsaXN0IiwiaXNVVUlEXzEiLCJpc1VVSUQiLCJhbGwiLCJmcmVlR2xvYmFsIiwiX2ZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsIl9yb290IiwiU3ltYm9sJDEiLCJfU3ltYm9sIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInRhZyIsInVubWFza2VkIiwicmVzdWx0IiwiX2dldFJhd1RhZyIsIm9iamVjdFByb3RvJDEiLCJuYXRpdmVPYmplY3RUb1N0cmluZyQxIiwib2JqZWN0VG9TdHJpbmciLCJfb2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWckMSIsImJhc2VHZXRUYWciLCJfYmFzZUdldFRhZyIsImlzT2JqZWN0IiwidHlwZSIsImlzT2JqZWN0XzEiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJpc0Z1bmN0aW9uXzEiLCJjb3JlSnNEYXRhIiwiX2NvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJmdW5jIiwiX2lzTWFza2VkIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJfdG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJmdW5jUHJvdG8kMSIsIm9iamVjdFByb3RvJDIiLCJmdW5jVG9TdHJpbmckMSIsImhhc093blByb3BlcnR5JDEiLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwiYmFzZUlzTmF0aXZlIiwiX2Jhc2VJc05hdGl2ZSIsImdldFZhbHVlIiwiX2dldFZhbHVlIiwiZ2V0TmF0aXZlIiwiX2dldE5hdGl2ZSIsIl9kZWZpbmVQcm9wZXJ0eSIsImJhc2VBc3NpZ25WYWx1ZSIsIl9iYXNlQXNzaWduVmFsdWUiLCJlcSIsIm90aGVyIiwiZXFfMSIsIm9iamVjdFByb3RvJDMiLCJoYXNPd25Qcm9wZXJ0eSQyIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsIl9hc3NpZ25WYWx1ZSIsImNvcHlPYmplY3QiLCJzb3VyY2UiLCJjdXN0b21pemVyIiwiaXNOZXciLCJpbmRleCIsIm5ld1ZhbHVlIiwiX2NvcHlPYmplY3QiLCJpZGVudGl0eSIsImlkZW50aXR5XzEiLCJhcHBseSIsInRoaXNBcmciLCJhcmdzIiwiX2FwcGx5IiwibmF0aXZlTWF4IiwiTWF0aCIsIm92ZXJSZXN0Iiwic3RhcnQiLCJ0cmFuc2Zvcm0iLCJBcnJheSIsIm90aGVyQXJncyIsIl9vdmVyUmVzdCIsImNvbnN0YW50IiwiY29uc3RhbnRfMSIsImJhc2VTZXRUb1N0cmluZyIsIl9iYXNlU2V0VG9TdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIm5vdyIsInNob3J0T3V0IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJfc2hvcnRPdXQiLCJzZXRUb1N0cmluZyIsIl9zZXRUb1N0cmluZyIsImJhc2VSZXN0IiwiX2Jhc2VSZXN0IiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoIiwiaXNMZW5ndGhfMSIsImlzQXJyYXlMaWtlIiwiaXNBcnJheUxpa2VfMSIsIk1BWF9TQUZFX0lOVEVHRVIkMSIsInJlSXNVaW50IiwiaXNJbmRleCIsIl9pc0luZGV4IiwiaXNJdGVyYXRlZUNhbGwiLCJfaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVBc3NpZ25lciIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwiX2NyZWF0ZUFzc2lnbmVyIiwib2JqZWN0UHJvdG8kNCIsImlzUHJvdG90eXBlIiwiQ3RvciIsInByb3RvIiwiX2lzUHJvdG90eXBlIiwiYmFzZVRpbWVzIiwibiIsIml0ZXJhdGVlIiwiX2Jhc2VUaW1lcyIsImlzT2JqZWN0TGlrZSIsImlzT2JqZWN0TGlrZV8xIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsIl9iYXNlSXNBcmd1bWVudHMiLCJvYmplY3RQcm90byQ1IiwiaGFzT3duUHJvcGVydHkkMyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJpc0FyZ3VtZW50c18xIiwiaXNBcnJheSIsImlzQXJyYXlfMSIsInN0dWJGYWxzZSIsInN0dWJGYWxzZV8xIiwiaXNCdWZmZXJfMSIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJhcmdzVGFnJDEiLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnJDEiLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsIl9iYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiX2Jhc2VVbmFyeSIsIl9ub2RlVXRpbCIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJyZXF1aXJlIiwiYmluZGluZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXlfMSIsIm9iamVjdFByb3RvJDYiLCJoYXNPd25Qcm9wZXJ0eSQ0IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsInB1c2giLCJfYXJyYXlMaWtlS2V5cyIsIm92ZXJBcmciLCJhcmciLCJfb3ZlckFyZyIsIm5hdGl2ZUtleXMiLCJfbmF0aXZlS2V5cyIsIm9iamVjdFByb3RvJDciLCJoYXNPd25Qcm9wZXJ0eSQ1IiwiYmFzZUtleXMiLCJfYmFzZUtleXMiLCJrZXlzXzEiLCJvYmplY3RQcm90byQ4IiwiaGFzT3duUHJvcGVydHkkNiIsImFzc2lnbiIsImFzc2lnbl8xIiwiYXJyYXlQdXNoIiwidmFsdWVzIiwib2Zmc2V0IiwiX2FycmF5UHVzaCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJpc0ZsYXR0ZW5hYmxlIiwiX2lzRmxhdHRlbmFibGUiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwicHJlZGljYXRlIiwiaXNTdHJpY3QiLCJfYmFzZUZsYXR0ZW4iLCJjb3B5QXJyYXkiLCJfY29weUFycmF5IiwiY29uY2F0XzEiLCJiYXNlUHJvcGVydHlPZiIsIl9iYXNlUHJvcGVydHlPZiIsImRlYnVycmVkTGV0dGVycyIsImRlYnVyckxldHRlciIsIl9kZWJ1cnJMZXR0ZXIiLCJhcnJheU1hcCIsIl9hcnJheU1hcCIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwiaXNTeW1ib2xfMSIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsIl9iYXNlVG9TdHJpbmciLCJ0b1N0cmluZ18xIiwicmVMYXRpbiIsInJzQ29tYm9NYXJrc1JhbmdlIiwicmVDb21ib0hhbGZNYXJrc1JhbmdlIiwicnNDb21ib1N5bWJvbHNSYW5nZSIsInJzQ29tYm9SYW5nZSIsInJzQ29tYm8iLCJyZUNvbWJvTWFyayIsImRlYnVyciIsImRlYnVycl8xIiwiYXJyYXlFYWNoIiwiX2FycmF5RWFjaCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiX2NyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yIiwiX2Jhc2VGb3IiLCJiYXNlRm9yT3duIiwiX2Jhc2VGb3JPd24iLCJjcmVhdGVCYXNlRWFjaCIsImVhY2hGdW5jIiwiY29sbGVjdGlvbiIsIl9jcmVhdGVCYXNlRWFjaCIsImJhc2VFYWNoIiwiX2Jhc2VFYWNoIiwiY2FzdEZ1bmN0aW9uIiwiX2Nhc3RGdW5jdGlvbiIsImZvckVhY2giLCJmb3JFYWNoXzEiLCJlYWNoIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiX2lzS2V5IiwibmF0aXZlQ3JlYXRlIiwiX25hdGl2ZUNyZWF0ZSIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwic2l6ZSIsIl9oYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzIiwiX2hhc2hEZWxldGUiLCJIQVNIX1VOREVGSU5FRCIsIm9iamVjdFByb3RvJDkiLCJoYXNPd25Qcm9wZXJ0eSQ3IiwiaGFzaEdldCIsImRhdGEiLCJfaGFzaEdldCIsIm9iamVjdFByb3RvJGEiLCJoYXNPd25Qcm9wZXJ0eSQ4IiwiaGFzaEhhcyIsIl9oYXNoSGFzIiwiSEFTSF9VTkRFRklORUQkMSIsImhhc2hTZXQiLCJfaGFzaFNldCIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsInNldCIsImdldCIsIl9IYXNoIiwibGlzdENhY2hlQ2xlYXIiLCJfbGlzdENhY2hlQ2xlYXIiLCJhc3NvY0luZGV4T2YiLCJfYXNzb2NJbmRleE9mIiwiYXJyYXlQcm90byIsInNwbGljZSIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsIl9saXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJfbGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwiX2xpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIl9saXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJfTGlzdENhY2hlIiwiTWFwIiwiX01hcCIsIm1hcENhY2hlQ2xlYXIiLCJfbWFwQ2FjaGVDbGVhciIsImlzS2V5YWJsZSIsIl9pc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX2dldE1hcERhdGEiLCJtYXBDYWNoZURlbGV0ZSIsIl9tYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwiX21hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJfbWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIl9tYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiX01hcENhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwibWVtb2l6ZSIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJjYWNoZSIsIkNhY2hlIiwibWVtb2l6ZV8xIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJfbWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJjaGFyQ29kZUF0IiwicXVvdGUiLCJzdWJTdHJpbmciLCJfc3RyaW5nVG9QYXRoIiwiY2FzdFBhdGgiLCJfY2FzdFBhdGgiLCJJTkZJTklUWSQxIiwidG9LZXkiLCJfdG9LZXkiLCJiYXNlR2V0IiwicGF0aCIsIl9iYXNlR2V0IiwiZGVmYXVsdFZhbHVlIiwiZ2V0XzEiLCJiYXNlR3QiLCJfYmFzZUd0IiwiTkFOIiwicmVUcmltIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzT2N0YWwiLCJmcmVlUGFyc2VJbnQiLCJ0b051bWJlciIsInZhbHVlT2YiLCJpc0JpbmFyeSIsInRvTnVtYmVyXzEiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwib3BlcmF0b3IiLCJfY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsImd0XzEiLCJndGVfMSIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJfYmFzZUZpbmRJbmRleCIsImJhc2VJc05hTiIsIl9iYXNlSXNOYU4iLCJzdHJpY3RJbmRleE9mIiwiX3N0cmljdEluZGV4T2YiLCJiYXNlSW5kZXhPZiIsIl9iYXNlSW5kZXhPZiIsInN0cmluZ1RhZyQxIiwiaXNTdHJpbmdfMSIsIklORklOSVRZJDIiLCJNQVhfSU5URUdFUiIsInRvRmluaXRlIiwic2lnbiIsInRvRmluaXRlXzEiLCJ0b0ludGVnZXIiLCJyZW1haW5kZXIiLCJ0b0ludGVnZXJfMSIsImJhc2VWYWx1ZXMiLCJfYmFzZVZhbHVlcyIsInZhbHVlc18xIiwibmF0aXZlTWF4JDEiLCJpbmNsdWRlcyIsImluY2x1ZGVzXzEiLCJib29sVGFnJDEiLCJpc0Jvb2xlYW4iLCJpc0Jvb2xlYW5fMSIsIkRhdGFWaWV3IiwiX0RhdGFWaWV3IiwiUHJvbWlzZSIsIl9Qcm9taXNlIiwiU2V0IiwiX1NldCIsIldlYWtNYXAiLCJfV2Vha01hcCIsIm1hcFRhZyQxIiwib2JqZWN0VGFnJDEiLCJwcm9taXNlVGFnIiwic2V0VGFnJDEiLCJ3ZWFrTWFwVGFnJDEiLCJkYXRhVmlld1RhZyQxIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnIiwiQXJyYXlCdWZmZXIiLCJyZXNvbHZlIiwiY3RvclN0cmluZyIsIl9nZXRUYWciLCJtYXBUYWckMiIsInNldFRhZyQyIiwib2JqZWN0UHJvdG8kYiIsImhhc093blByb3BlcnR5JDkiLCJpc0VtcHR5IiwiaXNFbXB0eV8xIiwic3RhY2tDbGVhciIsIl9zdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJfc3RhY2tEZWxldGUiLCJzdGFja0dldCIsIl9zdGFja0dldCIsInN0YWNrSGFzIiwiX3N0YWNrSGFzIiwiTEFSR0VfQVJSQVlfU0laRSIsInN0YWNrU2V0IiwicGFpcnMiLCJfc3RhY2tTZXQiLCJTdGFjayIsIl9TdGFjayIsIkhBU0hfVU5ERUZJTkVEJDIiLCJzZXRDYWNoZUFkZCIsIl9zZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiX3NldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhZGQiLCJfU2V0Q2FjaGUiLCJhcnJheVNvbWUiLCJfYXJyYXlTb21lIiwiY2FjaGVIYXMiLCJfY2FjaGVIYXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImJpdG1hc2siLCJlcXVhbEZ1bmMiLCJzdGFjayIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJfZXF1YWxBcnJheXMiLCJVaW50OEFycmF5IiwiX1VpbnQ4QXJyYXkiLCJtYXBUb0FycmF5IiwiX21hcFRvQXJyYXkiLCJzZXRUb0FycmF5IiwiX3NldFRvQXJyYXkiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyQxIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyQxIiwiYm9vbFRhZyQyIiwiZGF0ZVRhZyQxIiwiZXJyb3JUYWckMSIsIm1hcFRhZyQzIiwibnVtYmVyVGFnJDEiLCJyZWdleHBUYWckMSIsInNldFRhZyQzIiwic3RyaW5nVGFnJDIiLCJzeW1ib2xUYWckMSIsImFycmF5QnVmZmVyVGFnJDEiLCJkYXRhVmlld1RhZyQyIiwic3ltYm9sUHJvdG8kMSIsInN5bWJvbFZhbHVlT2YiLCJlcXVhbEJ5VGFnIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJtZXNzYWdlIiwiY29udmVydCIsIl9lcXVhbEJ5VGFnIiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsIl9iYXNlR2V0QWxsS2V5cyIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJfYXJyYXlGaWx0ZXIiLCJzdHViQXJyYXkiLCJzdHViQXJyYXlfMSIsIm9iamVjdFByb3RvJGMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSQxIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFN5bWJvbHMiLCJzeW1ib2wiLCJfZ2V0U3ltYm9scyIsImdldEFsbEtleXMiLCJfZ2V0QWxsS2V5cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDIiLCJvYmplY3RQcm90byRkIiwiaGFzT3duUHJvcGVydHkkYSIsImVxdWFsT2JqZWN0cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiX2VxdWFsT2JqZWN0cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDMiLCJhcmdzVGFnJDIiLCJhcnJheVRhZyQxIiwib2JqZWN0VGFnJDIiLCJvYmplY3RQcm90byRlIiwiaGFzT3duUHJvcGVydHkkYiIsImJhc2VJc0VxdWFsRGVlcCIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiX2Jhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwiX2Jhc2VJc0VxdWFsIiwiaXNFcXVhbCIsImlzRXF1YWxfMSIsIm5hdGl2ZUlzRmluaXRlIiwiaXNGaW5pdGUiLCJfaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0ludGVnZXJfMSIsIm51bWJlclRhZyQyIiwiaXNOdW1iZXIiLCJpc051bWJlcl8xIiwiaXNOYU4kMSIsIl9pc05hTiIsImlzTmlsIiwiaXNOaWxfMSIsImlzTnVsbCIsImlzTnVsbF8xIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZF8xIiwiYmFzZUx0IiwiX2Jhc2VMdCIsImx0XzEiLCJsdGVfMSIsImJhc2VTZXQiLCJuZXN0ZWQiLCJfYmFzZVNldCIsImJhc2VQaWNrQnkiLCJwYXRocyIsIl9iYXNlUGlja0J5IiwiYmFzZUhhc0luIiwiX2Jhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiX2hhc1BhdGgiLCJoYXNJbiIsImhhc0luXzEiLCJiYXNlUGljayIsIl9iYXNlUGljayIsImZsYXR0ZW4iLCJmbGF0dGVuXzEiLCJmbGF0UmVzdCIsIl9mbGF0UmVzdCIsInBpY2siLCJwaWNrXzEiLCJzZXRfMSIsImJhc2VQcm9wZXJ0eSIsIl9iYXNlUHJvcGVydHkiLCJhc2NpaVNpemUiLCJfYXNjaWlTaXplIiwicnNBc3RyYWxSYW5nZSIsInJzQ29tYm9NYXJrc1JhbmdlJDEiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMSIsInJzQ29tYm9SYW5nZSQxIiwicnNWYXJSYW5nZSIsInJzWldKIiwicmVIYXNVbmljb2RlIiwiaGFzVW5pY29kZSIsIl9oYXNVbmljb2RlIiwicnNBc3RyYWxSYW5nZSQxIiwicnNDb21ib01hcmtzUmFuZ2UkMiIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQyIiwicnNDb21ib1N5bWJvbHNSYW5nZSQyIiwicnNDb21ib1JhbmdlJDIiLCJyc1ZhclJhbmdlJDEiLCJyc0FzdHJhbCIsInJzQ29tYm8kMSIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNaV0okMSIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwidW5pY29kZVNpemUiLCJfdW5pY29kZVNpemUiLCJzdHJpbmdTaXplIiwiX3N0cmluZ1NpemUiLCJtYXBUYWckNCIsInNldFRhZyQ0Iiwic2l6ZV8xIiwiYmFzZVNsaWNlIiwiZW5kIiwiX2Jhc2VTbGljZSIsImNhc3RTbGljZSIsIl9jYXN0U2xpY2UiLCJyZWdleHBUYWckMiIsImJhc2VJc1JlZ0V4cCIsIl9iYXNlSXNSZWdFeHAiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cF8xIiwiYXNjaWlUb0FycmF5IiwiX2FzY2lpVG9BcnJheSIsInJzQXN0cmFsUmFuZ2UkMiIsInJzQ29tYm9NYXJrc1JhbmdlJDMiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMyIsInJzQ29tYm9SYW5nZSQzIiwicnNWYXJSYW5nZSQyIiwicnNBc3RyYWwkMSIsInJzQ29tYm8kMiIsInJzRml0eiQxIiwicnNNb2RpZmllciQxIiwicnNOb25Bc3RyYWwkMSIsInJzUmVnaW9uYWwkMSIsInJzU3VyclBhaXIkMSIsInJzWldKJDIiLCJyZU9wdE1vZCQxIiwicnNPcHRWYXIkMSIsInJzT3B0Sm9pbiQxIiwicnNTZXEkMSIsInJzU3ltYm9sJDEiLCJyZVVuaWNvZGUkMSIsInVuaWNvZGVUb0FycmF5IiwiX3VuaWNvZGVUb0FycmF5Iiwic3RyaW5nVG9BcnJheSIsIl9zdHJpbmdUb0FycmF5IiwiTUFYX0FSUkFZX0xFTkdUSCIsInNlcGFyYXRvciIsImxpbWl0Iiwic3BsaXRfMSIsInN0dWJUcnVlIiwic3R1YlRydWVfMSIsIm5hdGl2ZUtleXNJbiIsIl9uYXRpdmVLZXlzSW4iLCJvYmplY3RQcm90byRmIiwiaGFzT3duUHJvcGVydHkkYyIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwiX2Jhc2VLZXlzSW4iLCJrZXlzSW4iLCJrZXlzSW5fMSIsImFzc2lnbkluV2l0aCIsInNyY0luZGV4IiwiYXNzaWduSW5XaXRoXzEiLCJnZXRQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGUiLCJvYmplY3RUYWckMyIsImZ1bmNQcm90byQyIiwib2JqZWN0UHJvdG8kZyIsImZ1bmNUb1N0cmluZyQyIiwiaGFzT3duUHJvcGVydHkkZCIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNQbGFpbk9iamVjdF8xIiwiZG9tRXhjVGFnIiwiZXJyb3JUYWckMiIsImlzRXJyb3IiLCJpc0Vycm9yXzEiLCJhdHRlbXB0IiwiYXR0ZW1wdF8xIiwib2JqZWN0UHJvdG8kaCIsImhhc093blByb3BlcnR5JGUiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwic3JjVmFsdWUiLCJfY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsInN0cmluZ0VzY2FwZXMiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiX2VzY2FwZVN0cmluZ0NoYXIiLCJyZUludGVycG9sYXRlIiwiX3JlSW50ZXJwb2xhdGUiLCJodG1sRXNjYXBlcyIsImVzY2FwZUh0bWxDaGFyIiwiX2VzY2FwZUh0bWxDaGFyIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwiZXNjYXBlIiwiX2VzY2FwZSIsInJlRXNjYXBlIiwiX3JlRXNjYXBlIiwicmVFdmFsdWF0ZSIsIl9yZUV2YWx1YXRlIiwidGVtcGxhdGVTZXR0aW5ncyIsInRlbXBsYXRlU2V0dGluZ3NfMSIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNUZW1wbGF0ZSIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwib2JqZWN0UHJvdG8kaSIsImhhc093blByb3BlcnR5JGYiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsIl8iLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJ2YXJpYWJsZSIsInRlbXBsYXRlXzEiLCJ0b0xvd2VyIiwidG9Mb3dlcl8xIiwidG9EYXRlIiwiYXJndW1lbnQiLCJhcmdTdHIiLCJnZXRUaW1lIiwiY29uc29sZSIsIndhcm4iLCJOYU4iLCJ0b0ludGVnZXIkMSIsImRpcnR5TnVtYmVyIiwiY2VpbCIsImZsb29yIiwiYWRkTWlsbGlzZWNvbmRzIiwiZGlydHlEYXRlIiwiZGlydHlBbW91bnQiLCJ0aW1lc3RhbXAiLCJhbW91bnQiLCJNSUxMSVNFQ09ORFNfSU5fTUlOVVRFIiwiZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyIsImJhc2VUaW1lem9uZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0U2Vjb25kcyIsIm1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0IiwiaXNWYWxpZCIsImZvcm1hdERpc3RhbmNlTG9jYWxlIiwibGVzc1RoYW5YU2Vjb25kcyIsIm9uZSIsInhTZWNvbmRzIiwiaGFsZkFNaW51dGUiLCJsZXNzVGhhblhNaW51dGVzIiwieE1pbnV0ZXMiLCJhYm91dFhIb3VycyIsInhIb3VycyIsInhEYXlzIiwiYWJvdXRYTW9udGhzIiwieE1vbnRocyIsImFib3V0WFllYXJzIiwieFllYXJzIiwib3ZlclhZZWFycyIsImFsbW9zdFhZZWFycyIsImZvcm1hdERpc3RhbmNlIiwidG9rZW4iLCJhZGRTdWZmaXgiLCJjb21wYXJpc29uIiwiYnVpbGRGb3JtYXRMb25nRm4iLCJkaXJ0eU9wdGlvbnMiLCJ3aWR0aCIsImRlZmF1bHRXaWR0aCIsImZvcm1hdCIsImZvcm1hdHMiLCJkYXRlRm9ybWF0cyIsImZ1bGwiLCJtZWRpdW0iLCJ0aW1lRm9ybWF0cyIsImRhdGVUaW1lRm9ybWF0cyIsImZvcm1hdExvbmciLCJ0aW1lIiwiZGF0ZVRpbWUiLCJmb3JtYXRSZWxhdGl2ZUxvY2FsZSIsImxhc3RXZWVrIiwieWVzdGVyZGF5IiwidG9kYXkiLCJ0b21vcnJvdyIsIm5leHRXZWVrIiwiZm9ybWF0UmVsYXRpdmUiLCJfZGF0ZSIsIl9iYXNlRGF0ZSIsIl9vcHRpb25zIiwiYnVpbGRMb2NhbGl6ZUZuIiwiZGlydHlJbmRleCIsImNvbnRleHQiLCJ2YWx1ZXNBcnJheSIsImZvcm1hdHRpbmdWYWx1ZXMiLCJkZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIiwiX2RlZmF1bHRXaWR0aCIsIl93aWR0aCIsImFyZ3VtZW50Q2FsbGJhY2siLCJlcmFWYWx1ZXMiLCJuYXJyb3ciLCJhYmJyZXZpYXRlZCIsIndpZGUiLCJxdWFydGVyVmFsdWVzIiwibW9udGhWYWx1ZXMiLCJkYXlWYWx1ZXMiLCJkYXlQZXJpb2RWYWx1ZXMiLCJhbSIsInBtIiwibWlkbmlnaHQiLCJub29uIiwibW9ybmluZyIsImFmdGVybm9vbiIsImV2ZW5pbmciLCJuaWdodCIsImZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMiLCJvcmRpbmFsTnVtYmVyIiwiX2RpcnR5T3B0aW9ucyIsInJlbTEwMCIsImxvY2FsaXplIiwiZXJhIiwicXVhcnRlciIsImRheVBlcmlvZCIsImJ1aWxkTWF0Y2hQYXR0ZXJuRm4iLCJkaXJ0eVN0cmluZyIsIm1hdGNoUmVzdWx0IiwibWF0Y2hQYXR0ZXJuIiwibWF0Y2hlZFN0cmluZyIsInBhcnNlUmVzdWx0IiwicGFyc2VQYXR0ZXJuIiwidmFsdWVDYWxsYmFjayIsInJlc3QiLCJidWlsZE1hdGNoRm4iLCJtYXRjaFBhdHRlcm5zIiwiZGVmYXVsdE1hdGNoV2lkdGgiLCJwYXJzZVBhdHRlcm5zIiwiZGVmYXVsdFBhcnNlV2lkdGgiLCJmaW5kSW5kZXgiLCJmaW5kS2V5IiwibWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiIsInBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4iLCJtYXRjaEVyYVBhdHRlcm5zIiwicGFyc2VFcmFQYXR0ZXJucyIsImFueSIsIm1hdGNoUXVhcnRlclBhdHRlcm5zIiwicGFyc2VRdWFydGVyUGF0dGVybnMiLCJtYXRjaE1vbnRoUGF0dGVybnMiLCJwYXJzZU1vbnRoUGF0dGVybnMiLCJtYXRjaERheVBhdHRlcm5zIiwicGFyc2VEYXlQYXR0ZXJucyIsIm1hdGNoRGF5UGVyaW9kUGF0dGVybnMiLCJwYXJzZURheVBlcmlvZFBhdHRlcm5zIiwid2Vla1N0YXJ0c09uIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIiwic3ViTWlsbGlzZWNvbmRzIiwiYWRkTGVhZGluZ1plcm9zIiwidGFyZ2V0TGVuZ3RoIiwib3V0cHV0IiwiYWJzIiwiZm9ybWF0dGVycyIsInkiLCJzaWduZWRZZWFyIiwiTSIsImRheVBlcmlvZEVudW1WYWx1ZSIsImdldFVUQ0hvdXJzIiwidG9VcHBlckNhc2UiLCJoIiwiSCIsIm0iLCJnZXRVVENNaW51dGVzIiwicyIsImdldFVUQ1NlY29uZHMiLCJTIiwibnVtYmVyT2ZEaWdpdHMiLCJtaWxsaXNlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJmcmFjdGlvbmFsU2Vjb25kcyIsInBvdyIsIk1JTExJU0VDT05EU19JTl9EQVkiLCJnZXRVVENEYXlPZlllYXIiLCJzZXRVVENNb250aCIsInNldFVUQ0hvdXJzIiwic3RhcnRPZlllYXJUaW1lc3RhbXAiLCJkaWZmZXJlbmNlIiwic3RhcnRPZlVUQ0lTT1dlZWsiLCJnZXRVVENEYXkiLCJkaWZmIiwic2V0VVRDRGF0ZSIsImdldFVUQ0lTT1dlZWtZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciIsInNldFVUQ0Z1bGxZZWFyIiwic3RhcnRPZk5leHRZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciIsInN0YXJ0T2ZUaGlzWWVhciIsInN0YXJ0T2ZVVENJU09XZWVrWWVhciIsImZvdXJ0aE9mSmFudWFyeSIsIk1JTExJU0VDT05EU19JTl9XRUVLIiwiZ2V0VVRDSVNPV2VlayIsInJvdW5kIiwic3RhcnRPZlVUQ1dlZWsiLCJsb2NhbGVXZWVrU3RhcnRzT24iLCJkZWZhdWx0V2Vla1N0YXJ0c09uIiwiUmFuZ2VFcnJvciIsImdldFVUQ1dlZWtZZWFyIiwibG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlIiwiZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSIsImZpcnN0V2Vla09mTmV4dFllYXIiLCJmaXJzdFdlZWtPZlRoaXNZZWFyIiwic3RhcnRPZlVUQ1dlZWtZZWFyIiwiZmlyc3RXZWVrIiwiTUlMTElTRUNPTkRTX0lOX1dFRUskMSIsImdldFVUQ1dlZWsiLCJkYXlQZXJpb2RFbnVtIiwiZm9ybWF0dGVycyQxIiwiRyIsInVuaXQiLCJZIiwic2lnbmVkV2Vla1llYXIiLCJ3ZWVrWWVhciIsInR3b0RpZ2l0WWVhciIsIlIiLCJpc29XZWVrWWVhciIsInUiLCJRIiwicSIsIkwiLCJ3Iiwid2VlayIsIkkiLCJpc29XZWVrIiwiRCIsImRheU9mWWVhciIsIkUiLCJkYXlPZldlZWsiLCJsb2NhbERheU9mV2VlayIsImMiLCJpc29EYXlPZldlZWsiLCJob3VycyIsIkIiLCJLIiwiayIsIlgiLCJfbG9jYWxpemUiLCJvcmlnaW5hbERhdGUiLCJfb3JpZ2luYWxEYXRlIiwidGltZXpvbmVPZmZzZXQiLCJmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXMiLCJmb3JtYXRUaW1lem9uZSIsIk8iLCJmb3JtYXRUaW1lem9uZVNob3J0IiwieiIsInQiLCJUIiwiZGlydHlEZWxpbWl0ZXIiLCJhYnNPZmZzZXQiLCJtaW51dGVzIiwiZGVsaW1pdGVyIiwiZGF0ZUxvbmdGb3JtYXR0ZXIiLCJ0aW1lTG9uZ0Zvcm1hdHRlciIsImRhdGVUaW1lTG9uZ0Zvcm1hdHRlciIsImRhdGVQYXR0ZXJuIiwidGltZVBhdHRlcm4iLCJkYXRlVGltZUZvcm1hdCIsImxvbmdGb3JtYXR0ZXJzIiwicCIsIlAiLCJwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMiLCJwcm90ZWN0ZWRXZWVrWWVhclRva2VucyIsImlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4iLCJpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4iLCJ0aHJvd1Byb3RlY3RlZEVycm9yIiwiZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCIsImxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwIiwiZXNjYXBlZFN0cmluZ1JlZ0V4cCIsImRvdWJsZVF1b3RlUmVnRXhwIiwidW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAiLCJkaXJ0eUZvcm1hdFN0ciIsImZvcm1hdFN0ciIsImxvY2FsZSQxIiwidXRjRGF0ZSIsImZvcm1hdHRlck9wdGlvbnMiLCJmaXJzdENoYXJhY3RlciIsImxvbmdGb3JtYXR0ZXIiLCJjbGVhbkVzY2FwZWRTdHJpbmciLCJmb3JtYXR0ZXIiLCJ1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMiLCJ1c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zIiwiYXNzaWduJDEiLCJkaXJ0eU9iamVjdCIsInByb3BlcnR5IiwiaXNBZnRlciIsImRpcnR5RGF0ZVRvQ29tcGFyZSIsImRhdGVUb0NvbXBhcmUiLCJpc0JlZm9yZSIsInNldFVUQ0RheSIsImRpcnR5RGF5IiwiY3VycmVudERheSIsImRheUluZGV4Iiwic2V0VVRDSVNPRGF5Iiwic2V0VVRDSVNPV2VlayIsImRpcnR5SVNPV2VlayIsInNldFVUQ1dlZWsiLCJkaXJ0eVdlZWsiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiIsIk1JTExJU0VDT05EU19JTl9NSU5VVEUkMSIsIk1JTExJU0VDT05EU19JTl9TRUNPTkQiLCJudW1lcmljUGF0dGVybnMiLCJob3VyMjNoIiwiaG91cjI0aCIsImhvdXIxMWgiLCJob3VyMTJoIiwibWludXRlIiwic2Vjb25kIiwic2luZ2xlRGlnaXQiLCJ0d29EaWdpdHMiLCJ0aHJlZURpZ2l0cyIsImZvdXJEaWdpdHMiLCJhbnlEaWdpdHNTaWduZWQiLCJzaW5nbGVEaWdpdFNpZ25lZCIsInR3b0RpZ2l0c1NpZ25lZCIsInRocmVlRGlnaXRzU2lnbmVkIiwiZm91ckRpZ2l0c1NpZ25lZCIsInRpbWV6b25lUGF0dGVybnMiLCJiYXNpY09wdGlvbmFsTWludXRlcyIsImJhc2ljIiwiYmFzaWNPcHRpb25hbFNlY29uZHMiLCJleHRlbmRlZCIsImV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzIiwicGFyc2VOdW1lcmljUGF0dGVybiIsInBhcnNlVGltZXpvbmVQYXR0ZXJuIiwic2Vjb25kcyIsInBhcnNlQW55RGlnaXRzU2lnbmVkIiwicGFyc2VORGlnaXRzIiwicGFyc2VORGlnaXRzU2lnbmVkIiwiZGF5UGVyaW9kRW51bVRvSG91cnMiLCJlbnVtVmFsdWUiLCJub3JtYWxpemVUd29EaWdpdFllYXIiLCJjdXJyZW50WWVhciIsImlzQ29tbW9uRXJhIiwiYWJzQ3VycmVudFllYXIiLCJyYW5nZUVuZCIsInJhbmdlRW5kQ2VudHVyeSIsImlzUHJldmlvdXNDZW50dXJ5IiwiREFZU19JTl9NT05USCIsIkRBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSIiwiaXNMZWFwWWVhckluZGV4IiwicGFyc2VycyIsInByaW9yaXR5IiwiZmxhZ3MiLCJpbmNvbXBhdGlibGVUb2tlbnMiLCJpc1R3b0RpZ2l0WWVhciIsInZhbGlkYXRlIiwibm9ybWFsaXplZFR3b0RpZ2l0WWVhciIsIl9tYXRjaCIsIl9mbGFncyIsImZpcnN0V2Vla09mWWVhciIsImlzTGVhcFllYXIiLCJ3aG9sZVdlZWtEYXlzIiwiaXNQTSIsInNldFVUQ01pbnV0ZXMiLCJzZXRVVENTZWNvbmRzIiwic2V0VVRDTWlsbGlzZWNvbmRzIiwidGltZXN0YW1wSXNTZXQiLCJfdG9rZW4iLCJUSU1FWk9ORV9VTklUX1BSSU9SSVRZIiwiZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxIiwibG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSIsImVzY2FwZWRTdHJpbmdSZWdFeHAkMSIsImRvdWJsZVF1b3RlUmVnRXhwJDEiLCJub3RXaGl0ZXNwYWNlUmVnRXhwIiwidW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAkMSIsImRpcnR5RGF0ZVN0cmluZyIsImRpcnR5Rm9ybWF0U3RyaW5nIiwiZGlydHlCYWNrdXBEYXRlIiwiZGF0ZVN0cmluZyIsImZvcm1hdFN0cmluZyIsInN1YkZuT3B0aW9ucyIsInNldHRlcnMiLCJkYXRlVG9TeXN0ZW1UaW1lem9uZSIsInRva2VucyIsInVzZWRUb2tlbnMiLCJwYXJzZXIiLCJpbmNvbXBhdGlibGVUb2tlbiIsInVzZWRUb2tlbiIsImZ1bGxUb2tlbiIsImNsZWFuRXNjYXBlZFN0cmluZyQxIiwidW5pcXVlUHJpb3JpdHlTZXR0ZXJzIiwic2V0dGVyIiwiZmlsdGVyIiwicmV2ZXJzZSIsInNldHRlckFycmF5IiwiY29udmVydGVkRGF0ZSIsInNldEZ1bGxZZWFyIiwic2V0SG91cnMiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiQxIiwiTUlMTElTRUNPTkRTX0lOX01JTlVURSQyIiwiREVGQVVMVF9BRERJVElPTkFMX0RJR0lUUyIsInBhdHRlcm5zIiwiZGF0ZVRpbWVEZWxpbWl0ZXIiLCJ0aW1lWm9uZURlbGltaXRlciIsInRpbWV6b25lIiwiZGF0ZVJlZ2V4IiwidGltZVJlZ2V4IiwidGltZXpvbmVSZWdleCIsInBhcnNlSVNPIiwiYWRkaXRpb25hbERpZ2l0cyIsImRhdGVTdHJpbmdzIiwic3BsaXREYXRlU3RyaW5nIiwicGFyc2VZZWFyUmVzdWx0IiwicGFyc2VZZWFyIiwicGFyc2VEYXRlIiwicmVzdERhdGVTdHJpbmciLCJwYXJzZVRpbWUiLCJwYXJzZVRpbWV6b25lIiwiZnVsbFRpbWUiLCJmdWxsVGltZURhdGUiLCJmdWxsVGltZURhdGVOZXh0RGF5Iiwic2V0RGF0ZSIsImdldERhdGUiLCJvZmZzZXREaWZmIiwidGltZVN0cmluZyIsInJlZ2V4IiwiY2FwdHVyZXMiLCJjZW50dXJ5IiwiaXNXZWVrRGF0ZSIsInBhcnNlRGF0ZVVuaXQiLCJ2YWxpZGF0ZVdlZWtEYXRlIiwiZGF5T2ZJU09XZWVrWWVhciIsInZhbGlkYXRlRGF0ZSIsInZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSIsInBhcnNlVGltZVVuaXQiLCJ2YWxpZGF0ZVRpbWUiLCJwYXJzZUZsb2F0IiwidGltZXpvbmVTdHJpbmciLCJ2YWxpZGF0ZVRpbWV6b25lIiwiZm91cnRoT2ZKYW51YXJ5RGF5IiwiZGF5c0luTW9udGhzIiwiaXNMZWFwWWVhckluZGV4JDEiLCJfeWVhciIsIl9ob3VycyIsInBhcnNlRGF0ZSQxIiwiX2dsb2JhbCIsIl9fdnVlbWNfdmFsaWRhdGlvbl9tZXNzYWdlcyIsIl9jbGFzcyIsInJlc2V0IiwiJGxvY2FsZSIsIiRmYWxsYmFjayIsIiRsb2NhbGVzIiwicmVnaXN0ZXIiLCJidW5kbGUiLCJfdGhpcyIsIiR0ZW1wbGF0ZSIsInJ1bGUiLCJjb25maWciLCIkcnVsZSIsImF0dHJpYnV0ZSIsIm1vZGVsIiwidmFsaWQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9hbmQiLCJfc3RlcCIsIm5leHQiLCJkb25lIiwiZXJyIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIiLCJfZGlkSXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3IyIiwiX29yIiwiX3N0ZXAyIiwiX3Jlc3VsdCIsIl9mb3JtYXQiLCJjb3B5Iiwib3IiLCJydWxlcyIsImFuZCIsImluY2x1c2l2ZSIsIl9taW4iLCJfbWF4IiwiX3ZhbHVlIiwiX2Jvb2xlYW4iLCJmb3JtYXQkMSIsImVycm9yIiwiZXF1YWwiLCJndCQxIiwiZ3RlJDEiLCJsdCQxIiwibHRlJDEiLCJtYXRjaCQxIiwiX21heDIiLCJfbWluMiIsIl9sZW4iLCJfa2V5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQUEsRUFBQUEsTUFBTSxDQUFDQyxjQUFQLFFBQUEsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsSUFBQUEsS0FBSyxFQUFFO0FBQVQsR0FBN0M7O0FBRUEsV0FBU0MsZUFBVCxDQUF5QkMsUUFBekIsRUFBbUNDLFdBQW5DLEVBQWdEO0FBQzlDLFFBQUksRUFBRUQsUUFBUSxZQUFZQyxXQUF0QixDQUFKLEVBQXdDO0FBQ3RDLFlBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFDRDtBQUNGOztBQUVELFdBQVNDLGlCQUFULENBQTJCQyxNQUEzQixFQUFtQ0MsS0FBbkMsRUFBMEM7QUFDeEMsU0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRCxLQUFLLENBQUNFLE1BQTFCLEVBQWtDRCxDQUFDLEVBQW5DLEVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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
